"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethers";
exports.ids = ["vendor-chunks/ethers"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethers/lib.esm/_version.js":
/*!*************************************************!*\
  !*** ./node_modules/ethers/lib.esm/_version.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */ /**\n *  The current version of Ethers.\n */ const version = \"6.15.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFpRSxHQUNqRTs7Q0FFQyxHQUNNLE1BQU1BLFVBQVUsU0FBUyxDQUNoQyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95aWQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vX3ZlcnNpb24uanM/NmUxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBEbyBOT1QgbW9kaWZ5IHRoaXMgZmlsZTsgc2VlIC9zcmMudHMvX2FkbWluL3VwZGF0ZS12ZXJzaW9uLnRzICovXG4vKipcbiAqICBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIEV0aGVycy5cbiAqL1xuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcIjYuMTUuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/abi-coder.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/abi-coder.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbiCoder: () => (/* binding */ AbiCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _coders_address_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./coders/address.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/address.js\");\n/* harmony import */ var _coders_array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./coders/array.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/array.js\");\n/* harmony import */ var _coders_boolean_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./coders/boolean.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/boolean.js\");\n/* harmony import */ var _coders_bytes_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./coders/bytes.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/bytes.js\");\n/* harmony import */ var _coders_fixed_bytes_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./coders/fixed-bytes.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js\");\n/* harmony import */ var _coders_null_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./coders/null.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/null.js\");\n/* harmony import */ var _coders_number_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./coders/number.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/number.js\");\n/* harmony import */ var _coders_string_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coders/string.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/string.js\");\n/* harmony import */ var _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./coders/tuple.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/tuple.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./fragments.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  When sending values to or receiving values from a [[Contract]], the\n *  data is generally encoded using the [ABI standard](link-solc-abi).\n *\n *  The AbiCoder provides a utility to encode values to ABI data and\n *  decode values from ABI data.\n *\n *  Most of the time, developers should favour the [[Contract]] class,\n *  which further abstracts a lot of the finer details of ABI data.\n *\n *  @_section api/abi/abi-coder:ABI Encoding\n */ // See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// https://docs.soliditylang.org/en/v0.8.17/control-structures.html\nconst PanicReasons = new Map();\nPanicReasons.set(0x00, \"GENERIC_PANIC\");\nPanicReasons.set(0x01, \"ASSERT_FALSE\");\nPanicReasons.set(0x11, \"OVERFLOW\");\nPanicReasons.set(0x12, \"DIVIDE_BY_ZERO\");\nPanicReasons.set(0x21, \"ENUM_RANGE_ERROR\");\nPanicReasons.set(0x22, \"BAD_STORAGE_DATA\");\nPanicReasons.set(0x31, \"STACK_UNDERFLOW\");\nPanicReasons.set(0x32, \"ARRAY_RANGE_ERROR\");\nPanicReasons.set(0x41, \"OUT_OF_MEMORY\");\nPanicReasons.set(0x51, \"UNINITIALIZED_FUNCTION_CALL\");\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nlet defaultCoder = null;\nlet defaultMaxInflation = 1024;\nfunction getBuiltinCallException(action, tx, data, abiCoder) {\n    let message = \"missing revert data\";\n    let reason = null;\n    const invocation = null;\n    let revert = null;\n    if (data) {\n        message = \"execution reverted\";\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)(data);\n        data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(data);\n        if (bytes.length === 0) {\n            message += \" (no data present; likely require(false) occurred\";\n            reason = \"require(false)\";\n        } else if (bytes.length % 32 !== 4) {\n            message += \" (could not decode reason; invalid data length)\";\n        } else if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4)) === \"0x08c379a0\") {\n            // Error(string)\n            try {\n                reason = abiCoder.decode([\n                    \"string\"\n                ], bytes.slice(4))[0];\n                revert = {\n                    signature: \"Error(string)\",\n                    name: \"Error\",\n                    args: [\n                        reason\n                    ]\n                };\n                message += `: ${JSON.stringify(reason)}`;\n            } catch (error) {\n                message += \" (could not decode reason; invalid string data)\";\n            }\n        } else if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes.slice(0, 4)) === \"0x4e487b71\") {\n            // Panic(uint256)\n            try {\n                const code = Number(abiCoder.decode([\n                    \"uint256\"\n                ], bytes.slice(4))[0]);\n                revert = {\n                    signature: \"Panic(uint256)\",\n                    name: \"Panic\",\n                    args: [\n                        code\n                    ]\n                };\n                reason = `Panic due to ${PanicReasons.get(code) || \"UNKNOWN\"}(${code})`;\n                message += `: ${reason}`;\n            } catch (error) {\n                message += \" (could not decode panic code)\";\n            }\n        } else {\n            message += \" (unknown custom error)\";\n        }\n    }\n    const transaction = {\n        to: tx.to ? (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(tx.to) : null,\n        data: tx.data || \"0x\"\n    };\n    if (tx.from) {\n        transaction.from = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.getAddress)(tx.from);\n    }\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.makeError)(message, \"CALL_EXCEPTION\", {\n        action,\n        data,\n        reason,\n        transaction,\n        invocation,\n        revert\n    });\n}\n/**\n *  The **AbiCoder** is a low-level class responsible for encoding JavaScript\n *  values into binary data and decoding binary data into JavaScript values.\n */ class AbiCoder {\n    #getCoder(param) {\n        if (param.isArray()) {\n            return new _coders_array_js__WEBPACK_IMPORTED_MODULE_3__.ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);\n        }\n        if (param.isTuple()) {\n            return new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(param.components.map((c)=>this.#getCoder(c)), param.name);\n        }\n        switch(param.baseType){\n            case \"address\":\n                return new _coders_address_js__WEBPACK_IMPORTED_MODULE_5__.AddressCoder(param.name);\n            case \"bool\":\n                return new _coders_boolean_js__WEBPACK_IMPORTED_MODULE_6__.BooleanCoder(param.name);\n            case \"string\":\n                return new _coders_string_js__WEBPACK_IMPORTED_MODULE_7__.StringCoder(param.name);\n            case \"bytes\":\n                return new _coders_bytes_js__WEBPACK_IMPORTED_MODULE_8__.BytesCoder(param.name);\n            case \"\":\n                return new _coders_null_js__WEBPACK_IMPORTED_MODULE_9__.NullCoder(param.name);\n        }\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, \"invalid \" + match[1] + \" bit length\", \"param\", param);\n            return new _coders_number_js__WEBPACK_IMPORTED_MODULE_10__.NumberCoder(size / 8, match[1] === \"int\", param.name);\n        }\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(size !== 0 && size <= 32, \"invalid bytes length\", \"param\", param);\n            return new _coders_fixed_bytes_js__WEBPACK_IMPORTED_MODULE_11__.FixedBytesCoder(size, param.name);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid type\", \"type\", param.type);\n    }\n    /**\n     *  Get the default values for the given %%types%%.\n     *\n     *  For example, a ``uint`` is by default ``0`` and ``bool``\n     *  is by default ``false``.\n     */ getDefaultValue(types) {\n        const coders = types.map((type)=>this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_12__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n    /**\n     *  Encode the %%values%% as the %%types%% into ABI data.\n     *\n     *  @returns DataHexstring\n     */ encode(types, values) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgumentCount)(values.length, types.length, \"types/values length mismatch\");\n        const coders = types.map((type)=>this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_12__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(coders, \"_\");\n        const writer = new _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_13__.Writer();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n    /**\n     *  Decode the ABI %%data%% as the %%types%% into values.\n     *\n     *  If %%loose%% decoding is enabled, then strict padding is\n     *  not enforced. Some older versions of Solidity incorrectly\n     *  padded event data emitted from ``external`` functions.\n     */ decode(types, data, loose) {\n        const coders = types.map((type)=>this.#getCoder(_fragments_js__WEBPACK_IMPORTED_MODULE_12__.ParamType.from(type)));\n        const coder = new _coders_tuple_js__WEBPACK_IMPORTED_MODULE_4__.TupleCoder(coders, \"_\");\n        return coder.decode(new _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_13__.Reader(data, loose, defaultMaxInflation));\n    }\n    static _setDefaultMaxInflation(value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof value === \"number\" && Number.isInteger(value), \"invalid defaultMaxInflation factor\", \"value\", value);\n        defaultMaxInflation = value;\n    }\n    /**\n     *  Returns the shared singleton instance of a default [[AbiCoder]].\n     *\n     *  On the first call, the instance is created internally.\n     */ static defaultAbiCoder() {\n        if (defaultCoder == null) {\n            defaultCoder = new AbiCoder();\n        }\n        return defaultCoder;\n    }\n    /**\n     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given\n     *  result %%data%% for the [[CallExceptionAction]] %%action%% against\n     *  the Transaction %%tx%%.\n     */ static getBuiltinCallException(action, tx, data) {\n        return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());\n    }\n} //# sourceMappingURL=abi-coder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2FiaS1jb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELG1FQUFtRTtBQUNLO0FBQ1o7QUFDVDtBQUNKO0FBQ0k7QUFDSjtBQUNXO0FBQ2I7QUFDSTtBQUNBO0FBQ0Y7QUFDSjtBQUNNO0FBQ2dCO0FBQ2pFLG1FQUFtRTtBQUNuRSxNQUFNa0IsZUFBZSxJQUFJQztBQUN6QkQsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkJGLGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkJGLGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkJGLGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkIsTUFBTUMsaUJBQWlCLElBQUlDLE9BQU87QUFDbEMsTUFBTUMsa0JBQWtCLElBQUlELE9BQU87QUFDbkMsSUFBSUUsZUFBZTtBQUNuQixJQUFJQyxzQkFBc0I7QUFDMUIsU0FBU0Msd0JBQXdCQyxNQUFNLEVBQUVDLEVBQUUsRUFBRUMsSUFBSSxFQUFFQyxRQUFRO0lBQ3ZELElBQUlDLFVBQVU7SUFDZCxJQUFJQyxTQUFTO0lBQ2IsTUFBTUMsYUFBYTtJQUNuQixJQUFJQyxTQUFTO0lBQ2IsSUFBSUwsTUFBTTtRQUNORSxVQUFVO1FBQ1YsTUFBTUksUUFBUXBCLHlEQUFRQSxDQUFDYztRQUN2QkEsT0FBT2Isd0RBQU9BLENBQUNhO1FBQ2YsSUFBSU0sTUFBTUMsTUFBTSxLQUFLLEdBQUc7WUFDcEJMLFdBQVc7WUFDWEMsU0FBUztRQUNiLE9BQ0ssSUFBSUcs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O1FBQ2pFLE1BQU1NLFFBQVMsSUFBSXpELHdEQUFVQSxDQUFDd0QsUUFBUTtRQUN0QyxNQUFNSyxTQUFTLElBQUl0RSw4REFBTUE7UUFDekJrRSxNQUFNRSxNQUFNLENBQUNFLFFBQVFEO1FBQ3JCLE9BQU9DLE9BQU81QyxJQUFJO0lBQ3RCO0lBQ0E7Ozs7OztLQU1DLEdBQ0RTLE9BQU82QixLQUFLLEVBQUV0QyxJQUFJLEVBQUU2QyxLQUFLLEVBQUU7UUFDdkIsTUFBTU4sU0FBU0QsTUFBTVIsR0FBRyxDQUFDLENBQUNJLE9BQVMsSUFBSSxDQUFDLENBQUNYLFFBQVEsQ0FBQ3ZDLHFEQUFTQSxDQUFDcUMsSUFBSSxDQUFDYTtRQUNqRSxNQUFNTSxRQUFRLElBQUl6RCx3REFBVUEsQ0FBQ3dELFFBQVE7UUFDckMsT0FBT0MsTUFBTS9CLE1BQU0sQ0FBQyxJQUFJcEMsOERBQU1BLENBQUMyQixNQUFNNkMsT0FBT2pEO0lBQ2hEO0lBQ0EsT0FBT2tELHdCQUF3QkMsS0FBSyxFQUFFO1FBQ2xDM0UsK0RBQWNBLENBQUMsT0FBUTJFLFVBQVcsWUFBWTlCLE9BQU8rQixTQUFTLENBQUNELFFBQVEsc0NBQXNDLFNBQVNBO1FBQ3RIbkQsc0JBQXNCbUQ7SUFDMUI7SUFDQTs7OztLQUlDLEdBQ0QsT0FBT0Usa0JBQWtCO1FBQ3JCLElBQUl0RCxnQkFBZ0IsTUFBTTtZQUN0QkEsZUFBZSxJQUFJMkI7UUFDdkI7UUFDQSxPQUFPM0I7SUFDWDtJQUNBOzs7O0tBSUMsR0FDRCxPQUFPRSx3QkFBd0JDLE1BQU0sRUFBRUMsRUFBRSxFQUFFQyxJQUFJLEVBQUU7UUFDN0MsT0FBT0gsd0JBQXdCQyxRQUFRQyxJQUFJQyxNQUFNc0IsU0FBUzJCLGVBQWU7SUFDN0U7QUFDSixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3lpZC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvYWJpLWNvZGVyLmpzP2ZkNDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgV2hlbiBzZW5kaW5nIHZhbHVlcyB0byBvciByZWNlaXZpbmcgdmFsdWVzIGZyb20gYSBbW0NvbnRyYWN0XV0sIHRoZVxuICogIGRhdGEgaXMgZ2VuZXJhbGx5IGVuY29kZWQgdXNpbmcgdGhlIFtBQkkgc3RhbmRhcmRdKGxpbmstc29sYy1hYmkpLlxuICpcbiAqICBUaGUgQWJpQ29kZXIgcHJvdmlkZXMgYSB1dGlsaXR5IHRvIGVuY29kZSB2YWx1ZXMgdG8gQUJJIGRhdGEgYW5kXG4gKiAgZGVjb2RlIHZhbHVlcyBmcm9tIEFCSSBkYXRhLlxuICpcbiAqICBNb3N0IG9mIHRoZSB0aW1lLCBkZXZlbG9wZXJzIHNob3VsZCBmYXZvdXIgdGhlIFtbQ29udHJhY3RdXSBjbGFzcyxcbiAqICB3aGljaCBmdXJ0aGVyIGFic3RyYWN0cyBhIGxvdCBvZiB0aGUgZmluZXIgZGV0YWlscyBvZiBBQkkgZGF0YS5cbiAqXG4gKiAgQF9zZWN0aW9uIGFwaS9hYmkvYWJpLWNvZGVyOkFCSSBFbmNvZGluZ1xuICovXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvRXRoZXJldW0tQ29udHJhY3QtQUJJXG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudENvdW50LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUmVhZGVyLCBXcml0ZXIgfSBmcm9tIFwiLi9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanNcIjtcbmltcG9ydCB7IEFkZHJlc3NDb2RlciB9IGZyb20gXCIuL2NvZGVycy9hZGRyZXNzLmpzXCI7XG5pbXBvcnQgeyBBcnJheUNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2FycmF5LmpzXCI7XG5pbXBvcnQgeyBCb29sZWFuQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYm9vbGVhbi5qc1wiO1xuaW1wb3J0IHsgQnl0ZXNDb2RlciB9IGZyb20gXCIuL2NvZGVycy9ieXRlcy5qc1wiO1xuaW1wb3J0IHsgRml4ZWRCeXRlc0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2ZpeGVkLWJ5dGVzLmpzXCI7XG5pbXBvcnQgeyBOdWxsQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvbnVsbC5qc1wiO1xuaW1wb3J0IHsgTnVtYmVyQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvbnVtYmVyLmpzXCI7XG5pbXBvcnQgeyBTdHJpbmdDb2RlciB9IGZyb20gXCIuL2NvZGVycy9zdHJpbmcuanNcIjtcbmltcG9ydCB7IFR1cGxlQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvdHVwbGUuanNcIjtcbmltcG9ydCB7IFBhcmFtVHlwZSB9IGZyb20gXCIuL2ZyYWdtZW50cy5qc1wiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXRCeXRlcywgaGV4bGlmeSwgbWFrZUVycm9yIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG4vLyBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi92MC44LjE3L2NvbnRyb2wtc3RydWN0dXJlcy5odG1sXG5jb25zdCBQYW5pY1JlYXNvbnMgPSBuZXcgTWFwKCk7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MDAsIFwiR0VORVJJQ19QQU5JQ1wiKTtcblBhbmljUmVhc29ucy5zZXQoMHgwMSwgXCJBU1NFUlRfRkFMU0VcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MTEsIFwiT1ZFUkZMT1dcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MTIsIFwiRElWSURFX0JZX1pFUk9cIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MjEsIFwiRU5VTV9SQU5HRV9FUlJPUlwiKTtcblBhbmljUmVhc29ucy5zZXQoMHgyMiwgXCJCQURfU1RPUkFHRV9EQVRBXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDMxLCBcIlNUQUNLX1VOREVSRkxPV1wiKTtcblBhbmljUmVhc29ucy5zZXQoMHgzMiwgXCJBUlJBWV9SQU5HRV9FUlJPUlwiKTtcblBhbmljUmVhc29ucy5zZXQoMHg0MSwgXCJPVVRfT0ZfTUVNT1JZXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDUxLCBcIlVOSU5JVElBTElaRURfRlVOQ1RJT05fQ0FMTFwiKTtcbmNvbnN0IHBhcmFtVHlwZUJ5dGVzID0gbmV3IFJlZ0V4cCgvXmJ5dGVzKFswLTldKikkLyk7XG5jb25zdCBwYXJhbVR5cGVOdW1iZXIgPSBuZXcgUmVnRXhwKC9eKHU/aW50KShbMC05XSopJC8pO1xubGV0IGRlZmF1bHRDb2RlciA9IG51bGw7XG5sZXQgZGVmYXVsdE1heEluZmxhdGlvbiA9IDEwMjQ7XG5mdW5jdGlvbiBnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihhY3Rpb24sIHR4LCBkYXRhLCBhYmlDb2Rlcikge1xuICAgIGxldCBtZXNzYWdlID0gXCJtaXNzaW5nIHJldmVydCBkYXRhXCI7XG4gICAgbGV0IHJlYXNvbiA9IG51bGw7XG4gICAgY29uc3QgaW52b2NhdGlvbiA9IG51bGw7XG4gICAgbGV0IHJldmVydCA9IG51bGw7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiZXhlY3V0aW9uIHJldmVydGVkXCI7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgICAgIGRhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChubyBkYXRhIHByZXNlbnQ7IGxpa2VseSByZXF1aXJlKGZhbHNlKSBvY2N1cnJlZFwiO1xuICAgICAgICAgICAgcmVhc29uID0gXCJyZXF1aXJlKGZhbHNlKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCAlIDMyICE9PSA0KSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChjb3VsZCBub3QgZGVjb2RlIHJlYXNvbjsgaW52YWxpZCBkYXRhIGxlbmd0aClcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDQpKSA9PT0gXCIweDA4YzM3OWEwXCIpIHtcbiAgICAgICAgICAgIC8vIEVycm9yKHN0cmluZylcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVhc29uID0gYWJpQ29kZXIuZGVjb2RlKFtcInN0cmluZ1wiXSwgYnl0ZXMuc2xpY2UoNCkpWzBdO1xuICAgICAgICAgICAgICAgIHJldmVydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIkVycm9yKHN0cmluZylcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJFcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVhc29uXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgOiAke0pTT04uc3RyaW5naWZ5KHJlYXNvbil9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKGNvdWxkIG5vdCBkZWNvZGUgcmVhc29uOyBpbnZhbGlkIHN0cmluZyBkYXRhKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgNCkpID09PSBcIjB4NGU0ODdiNzFcIikge1xuICAgICAgICAgICAgLy8gUGFuaWModWludDI1NilcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IE51bWJlcihhYmlDb2Rlci5kZWNvZGUoW1widWludDI1NlwiXSwgYnl0ZXMuc2xpY2UoNCkpWzBdKTtcbiAgICAgICAgICAgICAgICByZXZlcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJQYW5pYyh1aW50MjU2KVwiLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlBhbmljXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtjb2RlXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVhc29uID0gYFBhbmljIGR1ZSB0byAke1BhbmljUmVhc29ucy5nZXQoY29kZSkgfHwgXCJVTktOT1dOXCJ9KCR7Y29kZX0pYDtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGA6ICR7cmVhc29ufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIChjb3VsZCBub3QgZGVjb2RlIHBhbmljIGNvZGUpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiICh1bmtub3duIGN1c3RvbSBlcnJvcilcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgdG86ICh0eC50byA/IGdldEFkZHJlc3ModHgudG8pIDogbnVsbCksXG4gICAgICAgIGRhdGE6ICh0eC5kYXRhIHx8IFwiMHhcIilcbiAgICB9O1xuICAgIGlmICh0eC5mcm9tKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmZyb20gPSBnZXRBZGRyZXNzKHR4LmZyb20pO1xuICAgIH1cbiAgICByZXR1cm4gbWFrZUVycm9yKG1lc3NhZ2UsIFwiQ0FMTF9FWENFUFRJT05cIiwge1xuICAgICAgICBhY3Rpb24sIGRhdGEsIHJlYXNvbiwgdHJhbnNhY3Rpb24sIGludm9jYXRpb24sIHJldmVydFxuICAgIH0pO1xufVxuLyoqXG4gKiAgVGhlICoqQWJpQ29kZXIqKiBpcyBhIGxvdy1sZXZlbCBjbGFzcyByZXNwb25zaWJsZSBmb3IgZW5jb2RpbmcgSmF2YVNjcmlwdFxuICogIHZhbHVlcyBpbnRvIGJpbmFyeSBkYXRhIGFuZCBkZWNvZGluZyBiaW5hcnkgZGF0YSBpbnRvIEphdmFTY3JpcHQgdmFsdWVzLlxuICovXG5leHBvcnQgY2xhc3MgQWJpQ29kZXIge1xuICAgICNnZXRDb2RlcihwYXJhbSkge1xuICAgICAgICBpZiAocGFyYW0uaXNBcnJheSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5Q29kZXIodGhpcy4jZ2V0Q29kZXIocGFyYW0uYXJyYXlDaGlsZHJlbiksIHBhcmFtLmFycmF5TGVuZ3RoLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW0uaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlQ29kZXIocGFyYW0uY29tcG9uZW50cy5tYXAoKGMpID0+IHRoaXMuI2dldENvZGVyKGMpKSwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChwYXJhbS5iYXNlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3NDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJieXRlc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZXNDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE51bGxDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1P2ludFswLTldKlxuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJhbS50eXBlLm1hdGNoKHBhcmFtVHlwZU51bWJlcik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsyXSB8fCBcIjI1NlwiKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHNpemUgIT09IDAgJiYgc2l6ZSA8PSAyNTYgJiYgKHNpemUgJSA4KSA9PT0gMCwgXCJpbnZhbGlkIFwiICsgbWF0Y2hbMV0gKyBcIiBiaXQgbGVuZ3RoXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb2RlcihzaXplIC8gOCwgKG1hdGNoWzFdID09PSBcImludFwiKSwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnl0ZXNbMC05XStcbiAgICAgICAgbWF0Y2ggPSBwYXJhbS50eXBlLm1hdGNoKHBhcmFtVHlwZUJ5dGVzKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHNpemUgIT09IDAgJiYgc2l6ZSA8PSAzMiwgXCJpbnZhbGlkIGJ5dGVzIGxlbmd0aFwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRml4ZWRCeXRlc0NvZGVyKHNpemUsIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgdHlwZVwiLCBcInR5cGVcIiwgcGFyYW0udHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGRlZmF1bHQgdmFsdWVzIGZvciB0aGUgZ2l2ZW4gJSV0eXBlcyUlLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLCBhIGBgdWludGBgIGlzIGJ5IGRlZmF1bHQgYGAwYGAgYW5kIGBgYm9vbGBgXG4gICAgICogIGlzIGJ5IGRlZmF1bHQgYGBmYWxzZWBgLlxuICAgICAqL1xuICAgIGdldERlZmF1bHRWYWx1ZSh0eXBlcykge1xuICAgICAgICBjb25zdCBjb2RlcnMgPSB0eXBlcy5tYXAoKHR5cGUpID0+IHRoaXMuI2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7XG4gICAgICAgIGNvbnN0IGNvZGVyID0gbmV3IFR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIik7XG4gICAgICAgIHJldHVybiBjb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZSB0aGUgJSV2YWx1ZXMlJSBhcyB0aGUgJSV0eXBlcyUlIGludG8gQUJJIGRhdGEuXG4gICAgICpcbiAgICAgKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICAgICAqL1xuICAgIGVuY29kZSh0eXBlcywgdmFsdWVzKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50Q291bnQodmFsdWVzLmxlbmd0aCwgdHlwZXMubGVuZ3RoLCBcInR5cGVzL3ZhbHVlcyBsZW5ndGggbWlzbWF0Y2hcIik7XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy4jZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSAobmV3IFR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIikpO1xuICAgICAgICBjb25zdCB3cml0ZXIgPSBuZXcgV3JpdGVyKCk7XG4gICAgICAgIGNvZGVyLmVuY29kZSh3cml0ZXIsIHZhbHVlcyk7XG4gICAgICAgIHJldHVybiB3cml0ZXIuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZSB0aGUgQUJJICUlZGF0YSUlIGFzIHRoZSAlJXR5cGVzJSUgaW50byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAgSWYgJSVsb29zZSUlIGRlY29kaW5nIGlzIGVuYWJsZWQsIHRoZW4gc3RyaWN0IHBhZGRpbmcgaXNcbiAgICAgKiAgbm90IGVuZm9yY2VkLiBTb21lIG9sZGVyIHZlcnNpb25zIG9mIFNvbGlkaXR5IGluY29ycmVjdGx5XG4gICAgICogIHBhZGRlZCBldmVudCBkYXRhIGVtaXR0ZWQgZnJvbSBgYGV4dGVybmFsYGAgZnVuY3Rpb25zLlxuICAgICAqL1xuICAgIGRlY29kZSh0eXBlcywgZGF0YSwgbG9vc2UpIHtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLiNnZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuICAgICAgICByZXR1cm4gY29kZXIuZGVjb2RlKG5ldyBSZWFkZXIoZGF0YSwgbG9vc2UsIGRlZmF1bHRNYXhJbmZsYXRpb24pKTtcbiAgICB9XG4gICAgc3RhdGljIF9zZXREZWZhdWx0TWF4SW5mbGF0aW9uKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiICYmIE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcImludmFsaWQgZGVmYXVsdE1heEluZmxhdGlvbiBmYWN0b3JcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIGRlZmF1bHRNYXhJbmZsYXRpb24gPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHNoYXJlZCBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYSBkZWZhdWx0IFtbQWJpQ29kZXJdXS5cbiAgICAgKlxuICAgICAqICBPbiB0aGUgZmlyc3QgY2FsbCwgdGhlIGluc3RhbmNlIGlzIGNyZWF0ZWQgaW50ZXJuYWxseS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVmYXVsdEFiaUNvZGVyKCkge1xuICAgICAgICBpZiAoZGVmYXVsdENvZGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmF1bHRDb2RlciA9IG5ldyBBYmlDb2RlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0Q29kZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGFuIGV0aGVycy1jb21wYXRpYmxlIFtbQ2FsbEV4Y2VwdGlvbkVycm9yXV0gRXJyb3IgZm9yIHRoZSBnaXZlblxuICAgICAqICByZXN1bHQgJSVkYXRhJSUgZm9yIHRoZSBbW0NhbGxFeGNlcHRpb25BY3Rpb25dXSAlJWFjdGlvbiUlIGFnYWluc3RcbiAgICAgKiAgdGhlIFRyYW5zYWN0aW9uICUldHglJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oYWN0aW9uLCB0eCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gZ2V0QnVpbHRpbkNhbGxFeGNlcHRpb24oYWN0aW9uLCB0eCwgZGF0YSwgQWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyKCkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFiaS1jb2Rlci5qcy5tYXAiXSwibmFtZXMiOlsiYXNzZXJ0QXJndW1lbnRDb3VudCIsImFzc2VydEFyZ3VtZW50IiwiUmVhZGVyIiwiV3JpdGVyIiwiQWRkcmVzc0NvZGVyIiwiQXJyYXlDb2RlciIsIkJvb2xlYW5Db2RlciIsIkJ5dGVzQ29kZXIiLCJGaXhlZEJ5dGVzQ29kZXIiLCJOdWxsQ29kZXIiLCJOdW1iZXJDb2RlciIsIlN0cmluZ0NvZGVyIiwiVHVwbGVDb2RlciIsIlBhcmFtVHlwZSIsImdldEFkZHJlc3MiLCJnZXRCeXRlcyIsImhleGxpZnkiLCJtYWtlRXJyb3IiLCJQYW5pY1JlYXNvbnMiLCJNYXAiLCJzZXQiLCJwYXJhbVR5cGVCeXRlcyIsIlJlZ0V4cCIsInBhcmFtVHlwZU51bWJlciIsImRlZmF1bHRDb2RlciIsImRlZmF1bHRNYXhJbmZsYXRpb24iLCJnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbiIsImFjdGlvbiIsInR4IiwiZGF0YSIsImFiaUNvZGVyIiwibWVzc2FnZSIsInJlYXNvbiIsImludm9jYXRpb24iLCJyZXZlcnQiLCJieXRlcyIsImxlbmd0aCIsInNsaWNlIiwiZGVjb2RlIiwic2lnbmF0dXJlIiwibmFtZSIsImFyZ3MiLCJKU09OIiwic3RyaW5naWZ5IiwiZXJyb3IiLCJjb2RlIiwiTnVtYmVyIiwiZ2V0IiwidHJhbnNhY3Rpb24iLCJ0byIsImZyb20iLCJBYmlDb2RlciIsImdldENvZGVyIiwicGFyYW0iLCJpc0FycmF5IiwiYXJyYXlDaGlsZHJlbiIsImFycmF5TGVuZ3RoIiwiaXNUdXBsZSIsImNvbXBvbmVudHMiLCJtYXAiLCJjIiwiYmFzZVR5cGUiLCJtYXRjaCIsInR5cGUiLCJzaXplIiwicGFyc2VJbnQiLCJnZXREZWZhdWx0VmFsdWUiLCJ0eXBlcyIsImNvZGVycyIsImNvZGVyIiwiZGVmYXVsdFZhbHVlIiwiZW5jb2RlIiwidmFsdWVzIiwid3JpdGVyIiwibG9vc2UiLCJfc2V0RGVmYXVsdE1heEluZmxhdGlvbiIsInZhbHVlIiwiaXNJbnRlZ2VyIiwiZGVmYXVsdEFiaUNvZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/abi-coder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Coder: () => (/* binding */ Coder),\n/* harmony export */   Reader: () => (/* binding */ Reader),\n/* harmony export */   Result: () => (/* binding */ Result),\n/* harmony export */   WordSize: () => (/* binding */ WordSize),\n/* harmony export */   Writer: () => (/* binding */ Writer),\n/* harmony export */   checkResultErrors: () => (/* binding */ checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n\n/**\n * @_ignore:\n */ const WordSize = 32;\nconst Padding = new Uint8Array(WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [\n    \"then\"\n];\nconst _guard = {};\nconst resultNames = new WeakMap();\nfunction getNames(result) {\n    return resultNames.get(result);\n}\nfunction setNames(result, names) {\n    resultNames.set(result, names);\n}\nfunction throwError(name, error) {\n    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);\n    wrapped.error = error;\n    throw wrapped;\n}\nfunction toObject(names, items, deep) {\n    if (names.indexOf(null) >= 0) {\n        return items.map((item, index)=>{\n            if (item instanceof Result) {\n                return toObject(getNames(item), item, deep);\n            }\n            return item;\n        });\n    }\n    return names.reduce((accum, name, index)=>{\n        let item = items.getValue(name);\n        if (!(name in accum)) {\n            if (deep && item instanceof Result) {\n                item = toObject(getNames(item), item, deep);\n            }\n            accum[name] = item;\n        }\n        return accum;\n    }, {});\n}\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */ class Result extends Array {\n    // No longer used; but cannot be removed as it will remove the\n    // #private field from the .d.ts which may break backwards\n    // compatibility\n    #names;\n    /**\n     *  @private\n     */ constructor(...args){\n        // To properly sub-class Array so the other built-in\n        // functions work, the constructor has to behave fairly\n        // well. So, in the event we are created via fromItems()\n        // we build the read-only Result object we want, but on\n        // any other input, we use the default constructor\n        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n        const guard = args[0];\n        let items = args[1];\n        let names = (args[2] || []).slice();\n        let wrap = true;\n        if (guard !== _guard) {\n            items = args;\n            names = [];\n            wrap = false;\n        }\n        // Can't just pass in ...items since an array of length 1\n        // is a special case in the super.\n        super(items.length);\n        items.forEach((item, index)=>{\n            this[index] = item;\n        });\n        // Find all unique keys\n        const nameCounts = names.reduce((accum, name)=>{\n            if (typeof name === \"string\") {\n                accum.set(name, (accum.get(name) || 0) + 1);\n            }\n            return accum;\n        }, new Map());\n        // Remove any key thats not unique\n        setNames(this, Object.freeze(items.map((item, index)=>{\n            const name = names[index];\n            if (name != null && nameCounts.get(name) === 1) {\n                return name;\n            }\n            return null;\n        })));\n        // Dummy operations to prevent TypeScript from complaining\n        this.#names = [];\n        if (this.#names == null) {\n            void this.#names;\n        }\n        if (!wrap) {\n            return;\n        }\n        // A wrapped Result is immutable\n        Object.freeze(this);\n        // Proxy indices and names so we can trap deferred errors\n        const proxy = new Proxy(this, {\n            get: (target, prop, receiver)=>{\n                if (typeof prop === \"string\") {\n                    // Index accessor\n                    if (prop.match(/^[0-9]+$/)) {\n                        const index = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(prop, \"%index\");\n                        if (index < 0 || index >= this.length) {\n                            throw new RangeError(\"out of result range\");\n                        }\n                        const item = target[index];\n                        if (item instanceof Error) {\n                            throwError(`index ${index}`, item);\n                        }\n                        return item;\n                    }\n                    // Pass important checks (like `then` for Promise) through\n                    if (passProperties.indexOf(prop) >= 0) {\n                        return Reflect.get(target, prop, receiver);\n                    }\n                    const value = target[prop];\n                    if (value instanceof Function) {\n                        // Make sure functions work with private variables\n                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n                        return function(...args) {\n                            return value.apply(this === receiver ? target : this, args);\n                        };\n                    } else if (!(prop in target)) {\n                        // Possible name accessor\n                        return target.getValue.apply(this === receiver ? target : this, [\n                            prop\n                        ]);\n                    }\n                }\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n        setNames(proxy, getNames(this));\n        return proxy;\n    }\n    /**\n     *  Returns the Result as a normal Array. If %%deep%%, any children\n     *  which are Result objects are also converted to a normal Array.\n     *\n     *  This will throw if there are any outstanding deferred\n     *  errors.\n     */ toArray(deep) {\n        const result = [];\n        this.forEach((item, index)=>{\n            if (item instanceof Error) {\n                throwError(`index ${index}`, item);\n            }\n            if (deep && item instanceof Result) {\n                item = item.toArray(deep);\n            }\n            result.push(item);\n        });\n        return result;\n    }\n    /**\n     *  Returns the Result as an Object with each name-value pair. If\n     *  %%deep%%, any children which are Result objects are also\n     *  converted to an Object.\n     *\n     *  This will throw if any value is unnamed, or if there are\n     *  any outstanding deferred errors.\n     */ toObject(deep) {\n        const names = getNames(this);\n        return names.reduce((accum, name, index)=>{\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(name != null, `value at index ${index} unnamed`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"toObject()\"\n            });\n            return toObject(names, this, deep);\n        }, {});\n    }\n    /**\n     *  @_ignore\n     */ slice(start, end) {\n        if (start == null) {\n            start = 0;\n        }\n        if (start < 0) {\n            start += this.length;\n            if (start < 0) {\n                start = 0;\n            }\n        }\n        if (end == null) {\n            end = this.length;\n        }\n        if (end < 0) {\n            end += this.length;\n            if (end < 0) {\n                end = 0;\n            }\n        }\n        if (end > this.length) {\n            end = this.length;\n        }\n        const _names = getNames(this);\n        const result = [], names = [];\n        for(let i = start; i < end; i++){\n            result.push(this[i]);\n            names.push(_names[i]);\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */ filter(callback, thisArg) {\n        const _names = getNames(this);\n        const result = [], names = [];\n        for(let i = 0; i < this.length; i++){\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            if (callback.call(thisArg, item, i, this)) {\n                result.push(item);\n                names.push(_names[i]);\n            }\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */ map(callback, thisArg) {\n        const result = [];\n        for(let i = 0; i < this.length; i++){\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            result.push(callback.call(thisArg, item, i, this));\n        }\n        return result;\n    }\n    /**\n     *  Returns the value for %%name%%.\n     *\n     *  Since it is possible to have a key whose name conflicts with\n     *  a method on a [[Result]] or its superclass Array, or any\n     *  JavaScript keyword, this ensures all named values are still\n     *  accessible by name.\n     */ getValue(name) {\n        const index = getNames(this).indexOf(name);\n        if (index === -1) {\n            return undefined;\n        }\n        const value = this[index];\n        if (value instanceof Error) {\n            throwError(`property ${JSON.stringify(name)}`, value.error);\n        }\n        return value;\n    }\n    /**\n     *  Creates a new [[Result]] for %%items%% with each entry\n     *  also accessible by its corresponding name in %%keys%%.\n     */ static fromItems(items, keys) {\n        return new Result(_guard, items, keys);\n    }\n}\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */ function checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function(path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for(let key in object){\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({\n                    path: childPath,\n                    error: error\n                });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nfunction getValue(value) {\n    let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBeArray)(value);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(bytes.length <= WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", {\n        buffer: bytes,\n        length: WordSize,\n        offset: bytes.length\n    });\n    if (bytes.length !== WordSize) {\n        bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\n            Padding.slice(bytes.length % WordSize),\n            bytes\n        ]));\n    }\n    return bytes;\n}\n/**\n *  @_ignore\n */ class Coder {\n    constructor(name, type, localName, dynamic){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            name,\n            type,\n            localName,\n            dynamic\n        }, {\n            name: \"string\",\n            type: \"string\",\n            localName: \"string\",\n            dynamic: \"boolean\"\n        });\n    }\n    _throwError(message, value) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, message, this.localName, value);\n    }\n}\n/**\n *  @_ignore\n */ class Writer {\n    // An array of WordSize lengthed objects to concatenation\n    #data;\n    #dataLength;\n    constructor(){\n        this.#data = [];\n        this.#dataLength = 0;\n    }\n    get data() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)(this.#data);\n    }\n    get length() {\n        return this.#dataLength;\n    }\n    #writeData(data) {\n        this.#data.push(data);\n        this.#dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this.#writeData((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(writer.data));\n    }\n    // Arrayish item; pad on the right to *nearest* WordSize\n    writeBytes(value) {\n        let bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(value);\n        const paddingOffset = bytes.length % WordSize;\n        if (paddingOffset) {\n            bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.concat)([\n                bytes,\n                Padding.slice(paddingOffset)\n            ]));\n        }\n        return this.#writeData(bytes);\n    }\n    // Numeric item; pad on the left *to* WordSize\n    writeValue(value) {\n        return this.#writeData(getValue(value));\n    }\n    // Inserts a numeric place-holder, returning a callback that can\n    // be used to asjust the value later\n    writeUpdatableValue() {\n        const offset = this.#data.length;\n        this.#data.push(Padding);\n        this.#dataLength += WordSize;\n        return (value)=>{\n            this.#data[offset] = getValue(value);\n        };\n    }\n}\n/**\n *  @_ignore\n */ class Reader {\n    #data;\n    #offset;\n    #bytesRead;\n    #parent;\n    #maxInflation;\n    constructor(data, allowLoose, maxInflation){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.defineProperties)(this, {\n            allowLoose: !!allowLoose\n        });\n        this.#data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(data);\n        this.#bytesRead = 0;\n        this.#parent = null;\n        this.#maxInflation = maxInflation != null ? maxInflation : 1024;\n        this.#offset = 0;\n    }\n    get data() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(this.#data);\n    }\n    get dataLength() {\n        return this.#data.length;\n    }\n    get consumed() {\n        return this.#offset;\n    }\n    get bytes() {\n        return new Uint8Array(this.#data);\n    }\n    #incrementBytesRead(count) {\n        if (this.#parent) {\n            return this.#parent.#incrementBytesRead(count);\n        }\n        this.#bytesRead += count;\n        // Check for excessive inflation (see: #4537)\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https:/\\/github.com/ethers-io/ethers.js/issues/4537 )`, \"BUFFER_OVERRUN\", {\n            buffer: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(this.#data),\n            offset: this.#offset,\n            length: count,\n            info: {\n                bytesRead: this.#bytesRead,\n                dataLength: this.dataLength\n            }\n        });\n    }\n    #peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / WordSize) * WordSize;\n        if (this.#offset + alignedLength > this.#data.length) {\n            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n                alignedLength = length;\n            } else {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n                    buffer: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(this.#data),\n                    length: this.#data.length,\n                    offset: this.#offset + alignedLength\n                });\n            }\n        }\n        return this.#data.slice(this.#offset, this.#offset + alignedLength);\n    }\n    // Create a sub-reader with the same underlying data, but offset\n    subReader(offset) {\n        const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);\n        reader.#parent = this;\n        return reader;\n    }\n    // Read bytes\n    readBytes(length, loose) {\n        let bytes = this.#peekBytes(0, length, !!loose);\n        this.#incrementBytesRead(length);\n        this.#offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    // Read a numeric values\n    readValue() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toBigInt)(this.readBytes(WordSize));\n    }\n    readIndex() {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.toNumber)(this.readBytes(WordSize));\n    }\n} //# sourceMappingURL=abstract-coder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBRStCO0FBQy9COztDQUVDLEdBQ00sTUFBTVUsV0FBVyxHQUFHO0FBQzNCLE1BQU1DLFVBQVUsSUFBSUMsV0FBV0Y7QUFDL0IscUVBQXFFO0FBQ3JFLGlFQUFpRTtBQUNqRSxNQUFNRyxpQkFBaUI7SUFBQztDQUFPO0FBQy9CLE1BQU1DLFNBQVMsQ0FBQztBQUNoQixNQUFNQyxjQUFjLElBQUlDO0FBQ3hCLFNBQVNDLFNBQVNDLE1BQU07SUFDcEIsT0FBT0gsWUFBWUksR0FBRyxDQUFDRDtBQUMzQjtBQUNBLFNBQVNFLFNBQVNGLE1BQU0sRUFBRUcsS0FBSztJQUMzQk4sWUFBWU8sR0FBRyxDQUFDSixRQUFRRztBQUM1QjtBQUNBLFNBQVNFLFdBQVdDLElBQUksRUFBRUMsS0FBSztJQUMzQixNQUFNQyxVQUFVLElBQUlDLE1BQU0sQ0FBQyx1REFBdUQsRUFBRUgsS0FBSyxDQUFDO0lBQzFGRSxRQUFRRCxLQUFLLEdBQUdBO0lBQ2hCLE1BQU1DO0FBQ1Y7QUFDQSxTQUFTRSxTQUFTUCxLQUFLLEVBQUVRLEtBQUssRUFBRUMsSUFBSTtJQUNoQyxJQUFJVCxNQUFNVSxPQUFPLENBQUMsU0FBUyxHQUFHO1FBQzFCLE9BQU9GLE1BQU1HLEdBQUcsQ0FBQyxDQUFDQyxNQUFNQztZQUNwQixJQUFJRCxnQkFBZ0JFLFFBQVE7Z0JBQ3hCLE9BQU9QLFNBQVNYLFNBQVNnQixPQUFPQSxNQUFNSDtZQUMxQztZQUNBLE9BQU9HO1FBQ1g7SUFDSjtJQUNBLE9BQU9aLE1BQU1lLE1BQU0sQ0FBQyxDQUFDQyxPQUFPYixNQUFNVTtRQUM5QixJQUFJRCxPQUFPSixNQUFNUyxRQUFRLENBQUNkO1FBQzFCLElBQUksQ0FBRUEsQ0FBQUEsUUFBUWEsS0FBSSxHQUFJO1lBQ2xCLElBQUlQLFFBQVFHLGdCQUFnQkUsUUFBUTtn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R0FBR3JFLFFBQVEsQ0FBQyxDQUFDc0U7UUFDekMsSUFBSSxDQUFDLENBQUNKLGtCQUFrQixDQUFDbEU7UUFDekIsSUFBSSxDQUFDLENBQUMyQyxNQUFNLElBQUlGLE1BQU16QyxNQUFNO1FBQzVCLG9EQUFvRDtRQUNwRCxPQUFPeUMsTUFBTTNDLEtBQUssQ0FBQyxHQUFHRTtJQUMxQjtJQUNBLHdCQUF3QjtJQUN4QjZFLFlBQVk7UUFDUixPQUFPcEgseURBQVFBLENBQUMsSUFBSSxDQUFDbUgsU0FBUyxDQUFDL0c7SUFDbkM7SUFDQWlILFlBQVk7UUFDUixPQUFPcEgseURBQVFBLENBQUMsSUFBSSxDQUFDa0gsU0FBUyxDQUFDL0c7SUFDbkM7QUFDSixFQUNBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL3lpZC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzP2NlZjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgY29uY2F0LCBnZXRCeXRlc0NvcHksIGdldE51bWJlciwgaGV4bGlmeSwgdG9CZUFycmF5LCB0b0JpZ0ludCwgdG9OdW1iZXIsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnRcbi8qLCBpc0Vycm9yKi9cbiB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0IGNvbnN0IFdvcmRTaXplID0gMzI7XG5jb25zdCBQYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoV29yZFNpemUpO1xuLy8gUHJvcGVydGllcyB1c2VkIHRvIGltbWVkaWF0ZSBwYXNzIHRocm91Z2ggdG8gdGhlIHVuZGVybHlpbmcgb2JqZWN0XG4vLyAtIGB0aGVuYCBpcyB1c2VkIHRvIGRldGVjdCBpZiBhbiBvYmplY3QgaXMgYSBQcm9taXNlIGZvciBhd2FpdFxuY29uc3QgcGFzc1Byb3BlcnRpZXMgPSBbXCJ0aGVuXCJdO1xuY29uc3QgX2d1YXJkID0ge307XG5jb25zdCByZXN1bHROYW1lcyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBnZXROYW1lcyhyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0TmFtZXMuZ2V0KHJlc3VsdCk7XG59XG5mdW5jdGlvbiBzZXROYW1lcyhyZXN1bHQsIG5hbWVzKSB7XG4gICAgcmVzdWx0TmFtZXMuc2V0KHJlc3VsdCwgbmFtZXMpO1xufVxuZnVuY3Rpb24gdGhyb3dFcnJvcihuYW1lLCBlcnJvcikge1xuICAgIGNvbnN0IHdyYXBwZWQgPSBuZXcgRXJyb3IoYGRlZmVycmVkIGVycm9yIGR1cmluZyBBQkkgZGVjb2RpbmcgdHJpZ2dlcmVkIGFjY2Vzc2luZyAke25hbWV9YCk7XG4gICAgd3JhcHBlZC5lcnJvciA9IGVycm9yO1xuICAgIHRocm93IHdyYXBwZWQ7XG59XG5mdW5jdGlvbiB0b09iamVjdChuYW1lcywgaXRlbXMsIGRlZXApIHtcbiAgICBpZiAobmFtZXMuaW5kZXhPZihudWxsKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b09iamVjdChnZXROYW1lcyhpdGVtKSwgaXRlbSwgZGVlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5yZWR1Y2UoKGFjY3VtLCBuYW1lLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgaXRlbSA9IGl0ZW1zLmdldFZhbHVlKG5hbWUpO1xuICAgICAgICBpZiAoIShuYW1lIGluIGFjY3VtKSkge1xuICAgICAgICAgICAgaWYgKGRlZXAgJiYgaXRlbSBpbnN0YW5jZW9mIFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB0b09iamVjdChnZXROYW1lcyhpdGVtKSwgaXRlbSwgZGVlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2N1bVtuYW1lXSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sIHt9KTtcbn1cbi8qKlxuICogIEEgW1tSZXN1bHRdXSBpcyBhIHN1Yi1jbGFzcyBvZiBBcnJheSwgd2hpY2ggYWxsb3dzIGFjY2Vzc2luZyBhbnlcbiAqICBvZiBpdHMgdmFsdWVzIGVpdGhlciBwb3NpdGlvbmFsbHkgYnkgaXRzIGluZGV4IG9yLCBpZiBrZXlzIGFyZVxuICogIHByb3ZpZGVkIGJ5IGl0cyBuYW1lLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2FiaVxuICovXG5leHBvcnQgY2xhc3MgUmVzdWx0IGV4dGVuZHMgQXJyYXkge1xuICAgIC8vIE5vIGxvbmdlciB1c2VkOyBidXQgY2Fubm90IGJlIHJlbW92ZWQgYXMgaXQgd2lsbCByZW1vdmUgdGhlXG4gICAgLy8gI3ByaXZhdGUgZmllbGQgZnJvbSB0aGUgLmQudHMgd2hpY2ggbWF5IGJyZWFrIGJhY2t3YXJkc1xuICAgIC8vIGNvbXBhdGliaWxpdHlcbiAgICAjbmFtZXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICAvLyBUbyBwcm9wZXJseSBzdWItY2xhc3MgQXJyYXkgc28gdGhlIG90aGVyIGJ1aWx0LWluXG4gICAgICAgIC8vIGZ1bmN0aW9ucyB3b3JrLCB0aGUgY29uc3RydWN0b3IgaGFzIHRvIGJlaGF2ZSBmYWlybHlcbiAgICAgICAgLy8gd2VsbC4gU28sIGluIHRoZSBldmVudCB3ZSBhcmUgY3JlYXRlZCB2aWEgZnJvbUl0ZW1zKClcbiAgICAgICAgLy8gd2UgYnVpbGQgdGhlIHJlYWQtb25seSBSZXN1bHQgb2JqZWN0IHdlIHdhbnQsIGJ1dCBvblxuICAgICAgICAvLyBhbnkgb3RoZXIgaW5wdXQsIHdlIHVzZSB0aGUgZGVmYXVsdCBjb25zdHJ1Y3RvclxuICAgICAgICAvLyBjb25zdHJ1Y3RvcihndWFyZDogYW55LCBpdGVtczogQXJyYXk8YW55Piwga2V5cz86IEFycmF5PG51bGwgfCBzdHJpbmc+KTtcbiAgICAgICAgY29uc3QgZ3VhcmQgPSBhcmdzWzBdO1xuICAgICAgICBsZXQgaXRlbXMgPSBhcmdzWzFdO1xuICAgICAgICBsZXQgbmFtZXMgPSAoYXJnc1syXSB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgbGV0IHdyYXAgPSB0cnVlO1xuICAgICAgICBpZiAoZ3VhcmQgIT09IF9ndWFyZCkge1xuICAgICAgICAgICAgaXRlbXMgPSBhcmdzO1xuICAgICAgICAgICAgbmFtZXMgPSBbXTtcbiAgICAgICAgICAgIHdyYXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYW4ndCBqdXN0IHBhc3MgaW4gLi4uaXRlbXMgc2luY2UgYW4gYXJyYXkgb2YgbGVuZ3RoIDFcbiAgICAgICAgLy8gaXMgYSBzcGVjaWFsIGNhc2UgaW4gdGhlIHN1cGVyLlxuICAgICAgICBzdXBlcihpdGVtcy5sZW5ndGgpO1xuICAgICAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4geyB0aGlzW2luZGV4XSA9IGl0ZW07IH0pO1xuICAgICAgICAvLyBGaW5kIGFsbCB1bmlxdWUga2V5c1xuICAgICAgICBjb25zdCBuYW1lQ291bnRzID0gbmFtZXMucmVkdWNlKChhY2N1bSwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAobmFtZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBhY2N1bS5zZXQobmFtZSwgKGFjY3VtLmdldChuYW1lKSB8fCAwKSArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCAobmV3IE1hcCgpKSk7XG4gICAgICAgIC8vIFJlbW92ZSBhbnkga2V5IHRoYXRzIG5vdCB1bmlxdWVcbiAgICAgICAgc2V0TmFtZXModGhpcywgT2JqZWN0LmZyZWV6ZShpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiBuYW1lQ291bnRzLmdldChuYW1lKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pKSk7XG4gICAgICAgIC8vIER1bW15IG9wZXJhdGlvbnMgdG8gcHJldmVudCBUeXBlU2NyaXB0IGZyb20gY29tcGxhaW5pbmdcbiAgICAgICAgdGhpcy4jbmFtZXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuI25hbWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHZvaWQgKHRoaXMuI25hbWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXdyYXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHdyYXBwZWQgUmVzdWx0IGlzIGltbXV0YWJsZVxuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICAvLyBQcm94eSBpbmRpY2VzIGFuZCBuYW1lcyBzbyB3ZSBjYW4gdHJhcCBkZWZlcnJlZCBlcnJvcnNcbiAgICAgICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluZGV4IGFjY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldE51bWJlcihwcm9wLCBcIiVpbmRleFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByZXN1bHQgcmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGFyZ2V0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2luZGV4fWAsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyBpbXBvcnRhbnQgY2hlY2tzIChsaWtlIGB0aGVuYCBmb3IgUHJvbWlzZSkgdGhyb3VnaFxuICAgICAgICAgICAgICAgICAgICBpZiAocGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0YXJnZXRbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgZnVuY3Rpb25zIHdvcmsgd2l0aCBwcml2YXRlIHZhcmlhYmxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm94eSNub19wcml2YXRlX3Byb3BlcnR5X2ZvcndhcmRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSgodGhpcyA9PT0gcmVjZWl2ZXIpID8gdGFyZ2V0IDogdGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEocHJvcCBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NzaWJsZSBuYW1lIGFjY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmdldFZhbHVlLmFwcGx5KCh0aGlzID09PSByZWNlaXZlcikgPyB0YXJnZXQgOiB0aGlzLCBbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNldE5hbWVzKHByb3h5LCBnZXROYW1lcyh0aGlzKSk7XG4gICAgICAgIHJldHVybiBwcm94eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIFJlc3VsdCBhcyBhIG5vcm1hbCBBcnJheS4gSWYgJSVkZWVwJSUsIGFueSBjaGlsZHJlblxuICAgICAqICB3aGljaCBhcmUgUmVzdWx0IG9iamVjdHMgYXJlIGFsc28gY29udmVydGVkIHRvIGEgbm9ybWFsIEFycmF5LlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgYW55IG91dHN0YW5kaW5nIGRlZmVycmVkXG4gICAgICogIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b0FycmF5KGRlZXApIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2luZGV4fWAsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZXAgJiYgaXRlbSBpbnN0YW5jZW9mIFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnRvQXJyYXkoZGVlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBSZXN1bHQgYXMgYW4gT2JqZWN0IHdpdGggZWFjaCBuYW1lLXZhbHVlIHBhaXIuIElmXG4gICAgICogICUlZGVlcCUlLCBhbnkgY2hpbGRyZW4gd2hpY2ggYXJlIFJlc3VsdCBvYmplY3RzIGFyZSBhbHNvXG4gICAgICogIGNvbnZlcnRlZCB0byBhbiBPYmplY3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIGFueSB2YWx1ZSBpcyB1bm5hbWVkLCBvciBpZiB0aGVyZSBhcmVcbiAgICAgKiAgYW55IG91dHN0YW5kaW5nIGRlZmVycmVkIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b09iamVjdChkZWVwKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gZ2V0TmFtZXModGhpcyk7XG4gICAgICAgIHJldHVybiBuYW1lcy5yZWR1Y2UoKGFjY3VtLCBuYW1lLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0KG5hbWUgIT0gbnVsbCwgYHZhbHVlIGF0IGluZGV4ICR7aW5kZXh9IHVubmFtZWRgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRvT2JqZWN0KClcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdG9PYmplY3QobmFtZXMsIHRoaXMsIGRlZXApO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZVxuICAgICAqL1xuICAgIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCArPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICAgICAgZW5kICs9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgICAgICAgICBlbmQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX25hbWVzID0gZ2V0TmFtZXModGhpcyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdLCBuYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpc1tpXSk7XG4gICAgICAgICAgICBuYW1lcy5wdXNoKF9uYW1lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoX2d1YXJkLCByZXN1bHQsIG5hbWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlXG4gICAgICovXG4gICAgZmlsdGVyKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IF9uYW1lcyA9IGdldE5hbWVzKHRoaXMpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXSwgbmFtZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBpbmRleCAke2l9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBpdGVtLCBpLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIG5hbWVzLnB1c2goX25hbWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfZ3VhcmQsIHJlc3VsdCwgbmFtZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmVcbiAgICAgKi9cbiAgICBtYXAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpfWAsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBpdGVtLCBpLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHZhbHVlIGZvciAlJW5hbWUlJS5cbiAgICAgKlxuICAgICAqICBTaW5jZSBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIGEga2V5IHdob3NlIG5hbWUgY29uZmxpY3RzIHdpdGhcbiAgICAgKiAgYSBtZXRob2Qgb24gYSBbW1Jlc3VsdF1dIG9yIGl0cyBzdXBlcmNsYXNzIEFycmF5LCBvciBhbnlcbiAgICAgKiAgSmF2YVNjcmlwdCBrZXl3b3JkLCB0aGlzIGVuc3VyZXMgYWxsIG5hbWVkIHZhbHVlcyBhcmUgc3RpbGxcbiAgICAgKiAgYWNjZXNzaWJsZSBieSBuYW1lLlxuICAgICAqL1xuICAgIGdldFZhbHVlKG5hbWUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXROYW1lcyh0aGlzKS5pbmRleE9mKG5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1tpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIHZhbHVlLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFtbUmVzdWx0XV0gZm9yICUlaXRlbXMlJSB3aXRoIGVhY2ggZW50cnlcbiAgICAgKiAgYWxzbyBhY2Nlc3NpYmxlIGJ5IGl0cyBjb3JyZXNwb25kaW5nIG5hbWUgaW4gJSVrZXlzJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21JdGVtcyhpdGVtcywga2V5cykge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdChfZ3VhcmQsIGl0ZW1zLCBrZXlzKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGFsbCBlcnJvcnMgZm91bmQgaW4gYSBbW1Jlc3VsdF1dLlxuICpcbiAqICBTaW5jZSBjZXJ0YWluIGVycm9ycyBlbmNvdW50ZXJlZCB3aGVuIGNyZWF0aW5nIGEgW1tSZXN1bHRdXSBkb1xuICogIG5vdCBpbXBhY3QgdGhlIGFiaWxpdHkgdG8gY29udGludWUgcGFyc2luZyBkYXRhLCB0aGV5IGFyZVxuICogIGRlZmVycmVkIHVudGlsIHRoZXkgYXJlIGFjdHVhbGx5IGFjY2Vzc2VkLiBIZW5jZSBhIGZhdWx0eSBzdHJpbmdcbiAqICBpbiBhbiBFdmVudCB0aGF0IGlzIG5ldmVyIHVzZWQgZG9lcyBub3QgaW1wYWN0IHRoZSBwcm9ncmFtIGZsb3cuXG4gKlxuICogIEhvd2V2ZXIsIHNvbWV0aW1lcyBpdCBtYXkgYmUgdXNlZnVsIHRvIGFjY2VzcywgaWRlbnRpZnkgb3JcbiAqICB2YWxpZGF0ZSBjb3JyZWN0bmVzcyBvZiBhIFtbUmVzdWx0XV0uXG4gKlxuICogIEBfZG9jbG9jIGFwaS9hYmlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmVzdWx0RXJyb3JzKHJlc3VsdCkge1xuICAgIC8vIEZpbmQgdGhlIGZpcnN0IGVycm9yIChpZiBhbnkpXG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3QgY2hlY2tFcnJvcnMgPSBmdW5jdGlvbiAocGF0aCwgb2JqZWN0KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aC5zbGljZSgpO1xuICAgICAgICAgICAgY2hpbGRQYXRoLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2hlY2tFcnJvcnMoY2hpbGRQYXRoLCBvYmplY3Rba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7IHBhdGg6IGNoaWxkUGF0aCwgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjaGVja0Vycm9ycyhbXSwgcmVzdWx0KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWUodmFsdWUpIHtcbiAgICBsZXQgYnl0ZXMgPSB0b0JlQXJyYXkodmFsdWUpO1xuICAgIGFzc2VydChieXRlcy5sZW5ndGggPD0gV29yZFNpemUsIFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHsgYnVmZmVyOiBieXRlcywgbGVuZ3RoOiBXb3JkU2l6ZSwgb2Zmc2V0OiBieXRlcy5sZW5ndGggfSk7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gV29yZFNpemUpIHtcbiAgICAgICAgYnl0ZXMgPSBnZXRCeXRlc0NvcHkoY29uY2F0KFtQYWRkaW5nLnNsaWNlKGJ5dGVzLmxlbmd0aCAlIFdvcmRTaXplKSwgYnl0ZXNdKSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2RlciB7XG4gICAgLy8gVGhlIGNvZGVyIG5hbWU6XG4gICAgLy8gICAtIGFkZHJlc3MsIHVpbnQyNTYsIHR1cGxlLCBhcnJheSwgZXRjLlxuICAgIG5hbWU7XG4gICAgLy8gVGhlIGZ1bGx5IGV4cGFuZGVkIHR5cGUsIGluY2x1ZGluZyBjb21wb3NpdGUgdHlwZXM6XG4gICAgLy8gICAtIGFkZHJlc3MsIHVpbnQyNTYsIHR1cGxlKGFkZHJlc3MsYnl0ZXMpLCB1aW50MjU2WzNdWzRdW10sICBldGMuXG4gICAgdHlwZTtcbiAgICAvLyBUaGUgbG9jYWxOYW1lIGJvdW5kIGluIHRoZSBzaWduYXR1cmUsIGluIHRoaXMgZXhhbXBsZSBpdCBpcyBcImJhelwiOlxuICAgIC8vICAgLSB0dXBsZShhZGRyZXNzIGZvbywgdWludCBiYXIpIGJhelxuICAgIGxvY2FsTmFtZTtcbiAgICAvLyBXaGV0aGVyIHRoaXMgdHlwZSBpcyBkeW5hbWljOlxuICAgIC8vICAtIER5bmFtaWM6IGJ5dGVzLCBzdHJpbmcsIGFkZHJlc3NbXSwgdHVwbGUoYm9vbGVhbltdKSwgZXRjLlxuICAgIC8vICAtIE5vdCBEeW5hbWljOiBhZGRyZXNzLCB1aW50MjU2LCBib29sZWFuWzNdLCB0dXBsZShhZGRyZXNzLCB1aW50OClcbiAgICBkeW5hbWljO1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYykge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwic3RyaW5nXCIsIHR5cGU6IFwic3RyaW5nXCIsIGxvY2FsTmFtZTogXCJzdHJpbmdcIiwgZHluYW1pYzogXCJib29sZWFuXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF90aHJvd0Vycm9yKG1lc3NhZ2UsIHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBtZXNzYWdlLCB0aGlzLmxvY2FsTmFtZSwgdmFsdWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBXcml0ZXIge1xuICAgIC8vIEFuIGFycmF5IG9mIFdvcmRTaXplIGxlbmd0aGVkIG9iamVjdHMgdG8gY29uY2F0ZW5hdGlvblxuICAgICNkYXRhO1xuICAgICNkYXRhTGVuZ3RoO1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLiNkYXRhID0gW107XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggPSAwO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdCh0aGlzLiNkYXRhKTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI2RhdGFMZW5ndGg7IH1cbiAgICAjd3JpdGVEYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy4jZGF0YS5wdXNoKGRhdGEpO1xuICAgICAgICB0aGlzLiNkYXRhTGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIGFwcGVuZFdyaXRlcih3cml0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YShnZXRCeXRlc0NvcHkod3JpdGVyLmRhdGEpKTtcbiAgICB9XG4gICAgLy8gQXJyYXlpc2ggaXRlbTsgcGFkIG9uIHRoZSByaWdodCB0byAqbmVhcmVzdCogV29yZFNpemVcbiAgICB3cml0ZUJ5dGVzKHZhbHVlKSB7XG4gICAgICAgIGxldCBieXRlcyA9IGdldEJ5dGVzQ29weSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdPZmZzZXQgPSBieXRlcy5sZW5ndGggJSBXb3JkU2l6ZTtcbiAgICAgICAgaWYgKHBhZGRpbmdPZmZzZXQpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gZ2V0Qnl0ZXNDb3B5KGNvbmNhdChbYnl0ZXMsIFBhZGRpbmcuc2xpY2UocGFkZGluZ09mZnNldCldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YShieXRlcyk7XG4gICAgfVxuICAgIC8vIE51bWVyaWMgaXRlbTsgcGFkIG9uIHRoZSBsZWZ0ICp0byogV29yZFNpemVcbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN3cml0ZURhdGEoZ2V0VmFsdWUodmFsdWUpKTtcbiAgICB9XG4gICAgLy8gSW5zZXJ0cyBhIG51bWVyaWMgcGxhY2UtaG9sZGVyLCByZXR1cm5pbmcgYSBjYWxsYmFjayB0aGF0IGNhblxuICAgIC8vIGJlIHVzZWQgdG8gYXNqdXN0IHRoZSB2YWx1ZSBsYXRlclxuICAgIHdyaXRlVXBkYXRhYmxlVmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuI2RhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLiNkYXRhLnB1c2goUGFkZGluZyk7XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggKz0gV29yZFNpemU7XG4gICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2RhdGFbb2Zmc2V0XSA9IGdldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgUmVhZGVyIHtcbiAgICAvLyBBbGxvd3MgaW5jb21wbGV0ZSB1bnBhZGRlZCBkYXRhIHRvIGJlIHJlYWQ7IG90aGVyd2lzZSBhbiBlcnJvclxuICAgIC8vIGlzIHJhaXNlZCBpZiBhdHRlbXB0aW5nIHRvIG92ZXJydW4gdGhlIGJ1ZmZlci4gVGhpcyBpcyByZXF1aXJlZFxuICAgIC8vIHRvIGRlYWwgd2l0aCBhbiBvbGQgU29saWRpdHkgYnVnLCBpbiB3aGljaCBldmVudCBkYXRhIGZvclxuICAgIC8vIGV4dGVybmFsIChub3QgcHVibGljIHRob2d1aCkgd2FzIHRpZ2h0bHkgcGFja2VkLlxuICAgIGFsbG93TG9vc2U7XG4gICAgI2RhdGE7XG4gICAgI29mZnNldDtcbiAgICAjYnl0ZXNSZWFkO1xuICAgICNwYXJlbnQ7XG4gICAgI21heEluZmxhdGlvbjtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBhbGxvd0xvb3NlLCBtYXhJbmZsYXRpb24pIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFsbG93TG9vc2U6ICEhYWxsb3dMb29zZSB9KTtcbiAgICAgICAgdGhpcy4jZGF0YSA9IGdldEJ5dGVzQ29weShkYXRhKTtcbiAgICAgICAgdGhpcy4jYnl0ZXNSZWFkID0gMDtcbiAgICAgICAgdGhpcy4jcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbWF4SW5mbGF0aW9uID0gKG1heEluZmxhdGlvbiAhPSBudWxsKSA/IG1heEluZmxhdGlvbiA6IDEwMjQ7XG4gICAgICAgIHRoaXMuI29mZnNldCA9IDA7XG4gICAgfVxuICAgIGdldCBkYXRhKCkgeyByZXR1cm4gaGV4bGlmeSh0aGlzLiNkYXRhKTsgfVxuICAgIGdldCBkYXRhTGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jZGF0YS5sZW5ndGg7IH1cbiAgICBnZXQgY29uc3VtZWQoKSB7IHJldHVybiB0aGlzLiNvZmZzZXQ7IH1cbiAgICBnZXQgYnl0ZXMoKSB7IHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLiNkYXRhKTsgfVxuICAgICNpbmNyZW1lbnRCeXRlc1JlYWQoY291bnQpIHtcbiAgICAgICAgaWYgKHRoaXMuI3BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3BhcmVudC4jaW5jcmVtZW50Qnl0ZXNSZWFkKGNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNieXRlc1JlYWQgKz0gY291bnQ7XG4gICAgICAgIC8vIENoZWNrIGZvciBleGNlc3NpdmUgaW5mbGF0aW9uIChzZWU6ICM0NTM3KVxuICAgICAgICBhc3NlcnQodGhpcy4jbWF4SW5mbGF0aW9uIDwgMSB8fCB0aGlzLiNieXRlc1JlYWQgPD0gdGhpcy4jbWF4SW5mbGF0aW9uICogdGhpcy5kYXRhTGVuZ3RoLCBgY29tcHJlc3NlZCBBQkkgZGF0YSBleGNlZWRzIGluZmxhdGlvbiByYXRpbyBvZiAke3RoaXMuI21heEluZmxhdGlvbn0gKCBzZWU6IGh0dHBzOi9cXC9naXRodWIuY29tL2V0aGVycy1pby9ldGhlcnMuanMvaXNzdWVzLzQ1MzcgKWAsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBnZXRCeXRlc0NvcHkodGhpcy4jZGF0YSksIG9mZnNldDogdGhpcy4jb2Zmc2V0LFxuICAgICAgICAgICAgbGVuZ3RoOiBjb3VudCwgaW5mbzoge1xuICAgICAgICAgICAgICAgIGJ5dGVzUmVhZDogdGhpcy4jYnl0ZXNSZWFkLFxuICAgICAgICAgICAgICAgIGRhdGFMZW5ndGg6IHRoaXMuZGF0YUxlbmd0aFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgI3BlZWtCeXRlcyhvZmZzZXQsIGxlbmd0aCwgbG9vc2UpIHtcbiAgICAgICAgbGV0IGFsaWduZWRMZW5ndGggPSBNYXRoLmNlaWwobGVuZ3RoIC8gV29yZFNpemUpICogV29yZFNpemU7XG4gICAgICAgIGlmICh0aGlzLiNvZmZzZXQgKyBhbGlnbmVkTGVuZ3RoID4gdGhpcy4jZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93TG9vc2UgJiYgbG9vc2UgJiYgdGhpcy4jb2Zmc2V0ICsgbGVuZ3RoIDw9IHRoaXMuI2RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYWxpZ25lZExlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJkYXRhIG91dC1vZi1ib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogZ2V0Qnl0ZXNDb3B5KHRoaXMuI2RhdGEpLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHRoaXMuI2RhdGEubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jZGF0YS5zbGljZSh0aGlzLiNvZmZzZXQsIHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBzdWItcmVhZGVyIHdpdGggdGhlIHNhbWUgdW5kZXJseWluZyBkYXRhLCBidXQgb2Zmc2V0XG4gICAgc3ViUmVhZGVyKG9mZnNldCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgUmVhZGVyKHRoaXMuI2RhdGEuc2xpY2UodGhpcy4jb2Zmc2V0ICsgb2Zmc2V0KSwgdGhpcy5hbGxvd0xvb3NlLCB0aGlzLiNtYXhJbmZsYXRpb24pO1xuICAgICAgICByZWFkZXIuI3BhcmVudCA9IHRoaXM7XG4gICAgICAgIHJldHVybiByZWFkZXI7XG4gICAgfVxuICAgIC8vIFJlYWQgYnl0ZXNcbiAgICByZWFkQnl0ZXMobGVuZ3RoLCBsb29zZSkge1xuICAgICAgICBsZXQgYnl0ZXMgPSB0aGlzLiNwZWVrQnl0ZXMoMCwgbGVuZ3RoLCAhIWxvb3NlKTtcbiAgICAgICAgdGhpcy4jaW5jcmVtZW50Qnl0ZXNSZWFkKGxlbmd0aCk7XG4gICAgICAgIHRoaXMuI29mZnNldCArPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIC8vIEBUT0RPOiBNYWtlIHN1cmUgdGhlIGxlbmd0aC4uZW5kIGJ5dGVzIGFyZSBhbGwgMD9cbiAgICAgICAgcmV0dXJuIGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFJlYWQgYSBudW1lcmljIHZhbHVlc1xuICAgIHJlYWRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnSW50KHRoaXMucmVhZEJ5dGVzKFdvcmRTaXplKSk7XG4gICAgfVxuICAgIHJlYWRJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRvTnVtYmVyKHRoaXMucmVhZEJ5dGVzKFdvcmRTaXplKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3QtY29kZXIuanMubWFwIl0sIm5hbWVzIjpbImRlZmluZVByb3BlcnRpZXMiLCJjb25jYXQiLCJnZXRCeXRlc0NvcHkiLCJnZXROdW1iZXIiLCJoZXhsaWZ5IiwidG9CZUFycmF5IiwidG9CaWdJbnQiLCJ0b051bWJlciIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiV29yZFNpemUiLCJQYWRkaW5nIiwiVWludDhBcnJheSIsInBhc3NQcm9wZXJ0aWVzIiwiX2d1YXJkIiwicmVzdWx0TmFtZXMiLCJXZWFrTWFwIiwiZ2V0TmFtZXMiLCJyZXN1bHQiLCJnZXQiLCJzZXROYW1lcyIsIm5hbWVzIiwic2V0IiwidGhyb3dFcnJvciIsIm5hbWUiLCJlcnJvciIsIndyYXBwZWQiLCJFcnJvciIsInRvT2JqZWN0IiwiaXRlbXMiLCJkZWVwIiwiaW5kZXhPZiIsIm1hcCIsIml0ZW0iLCJpbmRleCIsIlJlc3VsdCIsInJlZHVjZSIsImFjY3VtIiwiZ2V0VmFsdWUiLCJBcnJheSIsImNvbnN0cnVjdG9yIiwiYXJncyIsImd1YXJkIiwic2xpY2UiLCJ3cmFwIiwibGVuZ3RoIiwiZm9yRWFjaCIsIm5hbWVDb3VudHMiLCJNYXAiLCJPYmplY3QiLCJmcmVlemUiLCJwcm94eSIsIlByb3h5IiwidGFyZ2V0IiwicHJvcCIsInJlY2VpdmVyIiwibWF0Y2giLCJSYW5nZUVycm9yIiwiUmVmbGVjdCIsInZhbHVlIiwiRnVuY3Rpb24iLCJhcHBseSIsInRvQXJyYXkiLCJwdXNoIiwib3BlcmF0aW9uIiwic3RhcnQiLCJlbmQiLCJfbmFtZXMiLCJpIiwiZmlsdGVyIiwiY2FsbGJhY2siLCJ0aGlzQXJnIiwiY2FsbCIsInVuZGVmaW5lZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJmcm9tSXRlbXMiLCJrZXlzIiwiY2hlY2tSZXN1bHRFcnJvcnMiLCJlcnJvcnMiLCJjaGVja0Vycm9ycyIsInBhdGgiLCJvYmplY3QiLCJpc0FycmF5Iiwia2V5IiwiY2hpbGRQYXRoIiwiYnl0ZXMiLCJidWZmZXIiLCJvZmZzZXQiLCJDb2RlciIsInR5cGUiLCJsb2NhbE5hbWUiLCJkeW5hbWljIiwiX3Rocm93RXJyb3IiLCJtZXNzYWdlIiwiV3JpdGVyIiwiZGF0YSIsImRhdGFMZW5ndGgiLCJ3cml0ZURhdGEiLCJhcHBlbmRXcml0ZXIiLCJ3cml0ZXIiLCJ3cml0ZUJ5dGVzIiwicGFkZGluZ09mZnNldCIsIndyaXRlVmFsdWUiLCJ3cml0ZVVwZGF0YWJsZVZhbHVlIiwiUmVhZGVyIiwiYnl0ZXNSZWFkIiwicGFyZW50IiwibWF4SW5mbGF0aW9uIiwiYWxsb3dMb29zZSIsImNvbnN1bWVkIiwiaW5jcmVtZW50Qnl0ZXNSZWFkIiwiY291bnQiLCJpbmZvIiwicGVla0J5dGVzIiwibG9vc2UiLCJhbGlnbmVkTGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJzdWJSZWFkZXIiLCJyZWFkZXIiLCJyZWFkQnl0ZXMiLCJyZWFkVmFsdWUiLCJyZWFkSW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/address.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/address.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressCoder: () => (/* binding */ AddressCoder)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/maths.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\n\n/**\n *  @_ignore\n */ class AddressCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName){\n        super(\"address\", \"address\", localName, false);\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n    encode(writer, _value) {\n        let value = _typed_js__WEBPACK_IMPORTED_MODULE_1__.Typed.dereference(_value, \"string\");\n        try {\n            value = (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)(value);\n        } catch (error) {\n            return this._throwError(error.message, _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_2__.getAddress)((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_3__.toBeHex)(reader.readValue(), 20));\n    }\n} //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW9EO0FBQ0w7QUFDWDtBQUNRO0FBQzVDOztDQUVDLEdBQ00sTUFBTUkscUJBQXFCRCxxREFBS0E7SUFDbkNFLFlBQVlDLFNBQVMsQ0FBRTtRQUNuQixLQUFLLENBQUMsV0FBVyxXQUFXQSxXQUFXO0lBQzNDO0lBQ0FDLGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQUMsT0FBT0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDbkIsSUFBSUMsUUFBUVQsNENBQUtBLENBQUNVLFdBQVcsQ0FBQ0YsUUFBUTtRQUN0QyxJQUFJO1lBQ0FDLFFBQVFYLDZEQUFVQSxDQUFDVztRQUN2QixFQUNBLE9BQU9FLE9BQU87WUFDVixPQUFPLElBQUksQ0FBQ0MsV0FBVyxDQUFDRCxNQUFNRSxPQUFPLEVBQUVMO1FBQzNDO1FBQ0EsT0FBT0QsT0FBT08sVUFBVSxDQUFDTDtJQUM3QjtJQUNBTSxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPbEIsNkRBQVVBLENBQUNDLHdEQUFPQSxDQUFDaUIsT0FBT0MsU0FBUyxJQUFJO0lBQ2xEO0FBQ0osRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95aWQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hZGRyZXNzLmpzP2NhODYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi8uLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB0b0JlSGV4IH0gZnJvbSBcIi4uLy4uL3V0aWxzL21hdGhzLmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIEFkZHJlc3NDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJzdHJpbmdcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGdldEFkZHJlc3ModmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rocm93RXJyb3IoZXJyb3IubWVzc2FnZSwgX3ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRBZGRyZXNzKHRvQmVIZXgocmVhZGVyLnJlYWRWYWx1ZSgpLCAyMCkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbImdldEFkZHJlc3MiLCJ0b0JlSGV4IiwiVHlwZWQiLCJDb2RlciIsIkFkZHJlc3NDb2RlciIsImNvbnN0cnVjdG9yIiwibG9jYWxOYW1lIiwiZGVmYXVsdFZhbHVlIiwiZW5jb2RlIiwid3JpdGVyIiwiX3ZhbHVlIiwidmFsdWUiLCJkZXJlZmVyZW5jZSIsImVycm9yIiwiX3Rocm93RXJyb3IiLCJtZXNzYWdlIiwid3JpdGVWYWx1ZSIsImRlY29kZSIsInJlYWRlciIsInJlYWRWYWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/anonymous.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/anonymous.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnonymousCoder: () => (/* binding */ AnonymousCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n/**\n *  Clones the functionality of an existing Coder, but without a localName\n *\n *  @_ignore\n */ class AnonymousCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(coder){\n        super(coder.name, coder.type, \"_\", coder.dynamic);\n        this.coder = coder;\n    }\n    defaultValue() {\n        return this.coder.defaultValue();\n    }\n    encode(writer, value) {\n        return this.coder.encode(writer, value);\n    }\n    decode(reader) {\n        return this.coder.decode(reader);\n    }\n} //# sourceMappingURL=anonymous.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hbm9ueW1vdXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEM7QUFDNUM7Ozs7Q0FJQyxHQUNNLE1BQU1DLHVCQUF1QkQscURBQUtBO0lBRXJDRSxZQUFZQyxLQUFLLENBQUU7UUFDZixLQUFLLENBQUNBLE1BQU1DLElBQUksRUFBRUQsTUFBTUUsSUFBSSxFQUFFLEtBQUtGLE1BQU1HLE9BQU87UUFDaEQsSUFBSSxDQUFDSCxLQUFLLEdBQUdBO0lBQ2pCO0lBQ0FJLGVBQWU7UUFDWCxPQUFPLElBQUksQ0FBQ0osS0FBSyxDQUFDSSxZQUFZO0lBQ2xDO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1FBQ2xCLE9BQU8sSUFBSSxDQUFDUCxLQUFLLENBQUNLLE1BQU0sQ0FBQ0MsUUFBUUM7SUFDckM7SUFDQUMsT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBTyxJQUFJLENBQUNULEtBQUssQ0FBQ1EsTUFBTSxDQUFDQztJQUM3QjtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veWlkLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYW5vbnltb3VzLmpzP2Q0YjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQ2xvbmVzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGFuIGV4aXN0aW5nIENvZGVyLCBidXQgd2l0aG91dCBhIGxvY2FsTmFtZVxuICpcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQW5vbnltb3VzQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29kZXI7XG4gICAgY29uc3RydWN0b3IoY29kZXIpIHtcbiAgICAgICAgc3VwZXIoY29kZXIubmFtZSwgY29kZXIudHlwZSwgXCJfXCIsIGNvZGVyLmR5bmFtaWMpO1xuICAgICAgICB0aGlzLmNvZGVyID0gY29kZXI7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmVuY29kZSh3cml0ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWNvZGUocmVhZGVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbm9ueW1vdXMuanMubWFwIl0sIm5hbWVzIjpbIkNvZGVyIiwiQW5vbnltb3VzQ29kZXIiLCJjb25zdHJ1Y3RvciIsImNvZGVyIiwibmFtZSIsInR5cGUiLCJkeW5hbWljIiwiZGVmYXVsdFZhbHVlIiwiZW5jb2RlIiwid3JpdGVyIiwidmFsdWUiLCJkZWNvZGUiLCJyZWFkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/anonymous.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/array.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/array.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayCoder: () => (/* binding */ ArrayCoder),\n/* harmony export */   pack: () => (/* binding */ pack),\n/* harmony export */   unpack: () => (/* binding */ unpack)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _anonymous_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./anonymous.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/anonymous.js\");\n\n\n\n\n/**\n *  @_ignore\n */ function pack(writer, coders, values) {\n    let arrayValues = [];\n    if (Array.isArray(values)) {\n        arrayValues = values;\n    } else if (values && typeof values === \"object\") {\n        let unique = {};\n        arrayValues = coders.map((coder)=>{\n            const name = coder.localName;\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(name, \"cannot encode object for signature with missing names\", \"INVALID_ARGUMENT\", {\n                argument: \"values\",\n                info: {\n                    coder\n                },\n                value: values\n            });\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!unique[name], \"cannot encode object for signature with duplicate names\", \"INVALID_ARGUMENT\", {\n                argument: \"values\",\n                info: {\n                    coder\n                },\n                value: values\n            });\n            unique[name] = true;\n            return values[name];\n        });\n    } else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid tuple value\", \"tuple\", values);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(coders.length === arrayValues.length, \"types/value length mismatch\", \"tuple\", values);\n    let staticWriter = new _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n    let dynamicWriter = new _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n    let updateFuncs = [];\n    coders.forEach((coder, index)=>{\n        let value = arrayValues[index];\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset)=>{\n                updateFunc(baseOffset + dynamicOffset);\n            });\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func)=>{\n        func(staticWriter.length);\n    });\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n/**\n *  @_ignore\n */ function unpack(reader, coders) {\n    let values = [];\n    let keys = [];\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n    coders.forEach((coder)=>{\n        let value = null;\n        if (coder.dynamic) {\n            let offset = reader.readIndex();\n            let offsetReader = baseReader.subReader(offset);\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error) {\n                // Cannot recover from this\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error) {\n                // Cannot recover from this\n                if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        if (value == undefined) {\n            throw new Error(\"investigate\");\n        }\n        values.push(value);\n        keys.push(coder.localName || null);\n    });\n    return _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Result.fromItems(values, keys);\n}\n/**\n *  @_ignore\n */ class ArrayCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.Coder {\n    constructor(coder, length, localName){\n        const type = coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\";\n        const dynamic = length === -1 || coder.dynamic;\n        super(\"array\", type, localName, dynamic);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            coder,\n            length\n        });\n    }\n    defaultValue() {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n        const result = [];\n        for(let i = 0; i < this.length; i++){\n            result.push(defaultChild);\n        }\n        return result;\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_3__.Typed.dereference(_value, \"array\");\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n        let count = this.length;\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertArgumentCount)(value.length, count, \"coder array\" + (this.localName ? \" \" + this.localName : \"\"));\n        let coders = [];\n        for(let i = 0; i < value.length; i++){\n            coders.push(this.coder);\n        }\n        return pack(writer, coders, value);\n    }\n    decode(reader) {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readIndex();\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(count * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.WordSize <= reader.dataLength, \"insufficient data length\", \"BUFFER_OVERRUN\", {\n                buffer: reader.bytes,\n                offset: count * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_1__.WordSize,\n                length: reader.dataLength\n            });\n        }\n        let coders = [];\n        for(let i = 0; i < count; i++){\n            coders.push(new _anonymous_js__WEBPACK_IMPORTED_MODULE_4__.AnonymousCoder(this.coder));\n        }\n        return unpack(reader, coders);\n    }\n} //# sourceMappingURL=array.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9hcnJheS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE4RztBQUMxRTtBQUNrQztBQUN0QjtBQUNoRDs7Q0FFQyxHQUNNLFNBQVNXLEtBQUtDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxNQUFNO0lBQ3ZDLElBQUlDLGNBQWMsRUFBRTtJQUNwQixJQUFJQyxNQUFNQyxPQUFPLENBQUNILFNBQVM7UUFDdkJDLGNBQWNEO0lBQ2xCLE9BQ0ssSUFBSUEsVUFBVSxPQUFRQSxXQUFZLFVBQVU7UUFDN0MsSUFBSUksU0FBUyxDQUFDO1FBQ2RILGNBQWNGLE9BQU9NLEdBQUcsQ0FBQyxDQUFDQztZQUN0QixNQUFNQyxPQUFPRCxNQUFNRSxTQUFTO1lBQzVCcEIsdURBQU1BLENBQUNtQixNQUFNLHlEQUF5RCxvQkFBb0I7Z0JBQUVFLFVBQVU7Z0JBQVVDLE1BQU07b0JBQUVKO2dCQUFNO2dCQUFHSyxPQUFPWDtZQUFPO1lBQy9JWix1REFBTUEsQ0FBQyxDQUFDZ0IsTUFBTSxDQUFDRyxLQUFLLEVBQUUsMkRBQTJELG9CQUFvQjtnQkFBRUUsVUFBVTtnQkFBVUMsTUFBTTtvQkFBRUo7Z0JBQU07Z0JBQUdLLE9BQU9YO1lBQU87WUFDMUpJLE1BQU0sQ0FBQ0csS0FBSyxHQUFHO1lBQ2YsT0FBT1AsTUFBTSxDQUFDTyxLQUFLO1FBQ3ZCO0lBQ0osT0FDSztRQUNEbEIsK0RBQWNBLENBQUMsT0FBTyx1QkFBdUIsU0FBU1c7SUFDMUQ7SUFDQVgsK0RBQWNBLENBQUNVLE9BQU9hLE1BQU0sS0FBS1gsWUFBWVcsTUFBTSxFQUFFLCtCQUErQixTQUFTWjtJQUM3RixJQUFJYSxlQUFlLElBQUlsQixzREFBTUE7SUFDN0IsSUFBSW1CLGdCQUFnQixJQUFJbkIsc0RBQU1BO0lBQzlCLElBQUlvQixjQUFjLEVBQUU7SUFDcEJoQixPQUFPaUIsT0FBTyxDQUFDLENBQUNWLE9BQU9XO1FBQ25CLElBQUlO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RCxRQUFRekQsd0RBQVFBLElBQUlrQyxPQUFPeUIsVUFBVSxFQUFFLDRCQUE0QixrQkFBa0I7Z0JBQUVDLFFBQVExQixPQUFPMkIsS0FBSztnQkFBRXZCLFFBQVFtQixRQUFRekQsd0RBQVFBO2dCQUFFa0IsUUFBUWdCLE9BQU95QixVQUFVO1lBQUM7UUFDNUs7UUFDQSxJQUFJdEQsU0FBUyxFQUFFO1FBQ2YsSUFBSyxJQUFJZ0QsSUFBSSxHQUFHQSxJQUFJSSxPQUFPSixJQUFLO1lBQzVCaEQsT0FBT3dCLElBQUksQ0FBQyxJQUFJM0IseURBQWNBLENBQUMsSUFBSSxDQUFDVSxLQUFLO1FBQzdDO1FBQ0EsT0FBT3FCLE9BQU9DLFFBQVE3QjtJQUMxQjtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veWlkLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYXJyYXkuanM/YThiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBpc0Vycm9yLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRBcmd1bWVudENvdW50IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIsIFJlc3VsdCwgV29yZFNpemUsIFdyaXRlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG5pbXBvcnQgeyBBbm9ueW1vdXNDb2RlciB9IGZyb20gXCIuL2Fub255bW91cy5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhY2sod3JpdGVyLCBjb2RlcnMsIHZhbHVlcykge1xuICAgIGxldCBhcnJheVZhbHVlcyA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgYXJyYXlWYWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlcyAmJiB0eXBlb2YgKHZhbHVlcykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbGV0IHVuaXF1ZSA9IHt9O1xuICAgICAgICBhcnJheVZhbHVlcyA9IGNvZGVycy5tYXAoKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgYXNzZXJ0KG5hbWUsIFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIG1pc3NpbmcgbmFtZXNcIiwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IFwidmFsdWVzXCIsIGluZm86IHsgY29kZXIgfSwgdmFsdWU6IHZhbHVlcyB9KTtcbiAgICAgICAgICAgIGFzc2VydCghdW5pcXVlW25hbWVdLCBcImNhbm5vdCBlbmNvZGUgb2JqZWN0IGZvciBzaWduYXR1cmUgd2l0aCBkdXBsaWNhdGUgbmFtZXNcIiwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IFwidmFsdWVzXCIsIGluZm86IHsgY29kZXIgfSwgdmFsdWU6IHZhbHVlcyB9KTtcbiAgICAgICAgICAgIHVuaXF1ZVtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzW25hbWVdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgdHVwbGUgdmFsdWVcIiwgXCJ0dXBsZVwiLCB2YWx1ZXMpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChjb2RlcnMubGVuZ3RoID09PSBhcnJheVZhbHVlcy5sZW5ndGgsIFwidHlwZXMvdmFsdWUgbGVuZ3RoIG1pc21hdGNoXCIsIFwidHVwbGVcIiwgdmFsdWVzKTtcbiAgICBsZXQgc3RhdGljV3JpdGVyID0gbmV3IFdyaXRlcigpO1xuICAgIGxldCBkeW5hbWljV3JpdGVyID0gbmV3IFdyaXRlcigpO1xuICAgIGxldCB1cGRhdGVGdW5jcyA9IFtdO1xuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlciwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gYXJyYXlWYWx1ZXNbaW5kZXhdO1xuICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgZHluYW1pYyBvZmZzZXQgKGZvciB0aGUgZnV0dXJlIHBvaW50ZXIpXG4gICAgICAgICAgICBsZXQgZHluYW1pY09mZnNldCA9IGR5bmFtaWNXcml0ZXIubGVuZ3RoO1xuICAgICAgICAgICAgLy8gRW5jb2RlIHRoZSBkeW5hbWljIHZhbHVlIGludG8gdGhlIGR5bmFtaWNXcml0ZXJcbiAgICAgICAgICAgIGNvZGVyLmVuY29kZShkeW5hbWljV3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRvIHBvcHVsYXRlIHRoZSBjb3JyZWN0IG9mZnNldCBvbmNlIHdlIGFyZSBkb25lXG4gICAgICAgICAgICBsZXQgdXBkYXRlRnVuYyA9IHN0YXRpY1dyaXRlci53cml0ZVVwZGF0YWJsZVZhbHVlKCk7XG4gICAgICAgICAgICB1cGRhdGVGdW5jcy5wdXNoKChiYXNlT2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRnVuYyhiYXNlT2Zmc2V0ICsgZHluYW1pY09mZnNldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvZGVyLmVuY29kZShzdGF0aWNXcml0ZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEJhY2tmaWxsIGFsbCB0aGUgZHluYW1pYyBvZmZzZXRzLCBub3cgdGhhdCB3ZSBrbm93IHRoZSBzdGF0aWMgbGVuZ3RoXG4gICAgdXBkYXRlRnVuY3MuZm9yRWFjaCgoZnVuYykgPT4geyBmdW5jKHN0YXRpY1dyaXRlci5sZW5ndGgpOyB9KTtcbiAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLmFwcGVuZFdyaXRlcihzdGF0aWNXcml0ZXIpO1xuICAgIGxlbmd0aCArPSB3cml0ZXIuYXBwZW5kV3JpdGVyKGR5bmFtaWNXcml0ZXIpO1xuICAgIHJldHVybiBsZW5ndGg7XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrKHJlYWRlciwgY29kZXJzKSB7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBrZXlzID0gW107XG4gICAgLy8gQSByZWFkZXIgYW5jaG9yZWQgdG8gdGhpcyBiYXNlXG4gICAgbGV0IGJhc2VSZWFkZXIgPSByZWFkZXIuc3ViUmVhZGVyKDApO1xuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHJlYWRlci5yZWFkSW5kZXgoKTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRSZWFkZXIgPSBiYXNlUmVhZGVyLnN1YlJlYWRlcihvZmZzZXQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZGVyLmRlY29kZShvZmZzZXRSZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2Fubm90IHJlY292ZXIgZnJvbSB0aGlzXG4gICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXJyb3IsIFwiQlVGRkVSX09WRVJSVU5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgdmFsdWUuYmFzZVR5cGUgPSBjb2Rlci5uYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLm5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9IGNvZGVyLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKHJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJCVUZGRVJfT1ZFUlJVTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZlc3RpZ2F0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIGtleXMucHVzaChjb2Rlci5sb2NhbE5hbWUgfHwgbnVsbCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFJlc3VsdC5mcm9tSXRlbXModmFsdWVzLCBrZXlzKTtcbn1cbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBBcnJheUNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvZGVyO1xuICAgIGxlbmd0aDtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlciwgbGVuZ3RoLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IChjb2Rlci50eXBlICsgXCJbXCIgKyAobGVuZ3RoID49IDAgPyBsZW5ndGggOiBcIlwiKSArIFwiXVwiKTtcbiAgICAgICAgY29uc3QgZHluYW1pYyA9IChsZW5ndGggPT09IC0xIHx8IGNvZGVyLmR5bmFtaWMpO1xuICAgICAgICBzdXBlcihcImFycmF5XCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBjb2RlciwgbGVuZ3RoIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIC8vIFZlcmlmaWVzIHRoZSBjaGlsZCBjb2RlciBpcyB2YWxpZCAoZXZlbiBpZiB0aGUgYXJyYXkgaXMgZHluYW1pYyBvciAwLWxlbmd0aClcbiAgICAgICAgY29uc3QgZGVmYXVsdENoaWxkID0gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVmYXVsdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwiYXJyYXlcIik7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJleHBlY3RlZCBhcnJheSB2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvdW50ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudENvdW50KHZhbHVlLmxlbmd0aCwgY291bnQsIFwiY29kZXIgYXJyYXlcIiArICh0aGlzLmxvY2FsTmFtZSA/IChcIiBcIiArIHRoaXMubG9jYWxOYW1lKSA6IFwiXCIpKTtcbiAgICAgICAgbGV0IGNvZGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaCh0aGlzLmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAoY291bnQgPT09IC0xKSB7XG4gICAgICAgICAgICBjb3VudCA9IHJlYWRlci5yZWFkSW5kZXgoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlcmUgaXMgKnJvdWdobHkqIGVub3VnaCBkYXRhIHRvIGVuc3VyZVxuICAgICAgICAgICAgLy8gc3RyYXkgcmFuZG9tIGRhdGEgaXMgbm90IGJlaW5nIHJlYWQgYXMgYSBsZW5ndGguIEVhY2hcbiAgICAgICAgICAgIC8vIHNsb3QgcmVxdWlyZXMgYXQgbGVhc3QgMzIgYnl0ZXMgZm9yIHRoZWlyIHZhbHVlIChvciAzMlxuICAgICAgICAgICAgLy8gYnl0ZXMgYXMgYSBsaW5rIHRvIHRoZSBkYXRhKS4gVGhpcyBjb3VsZCB1c2UgYSBtdWNoXG4gICAgICAgICAgICAvLyB0aWdodGVyIGJvdW5kLCBidXQgd2UgYXJlIGVycm9yaW5nIG9uIHRoZSBzaWRlIG9mIHNhZmV0eS5cbiAgICAgICAgICAgIGFzc2VydChjb3VudCAqIFdvcmRTaXplIDw9IHJlYWRlci5kYXRhTGVuZ3RoLCBcImluc3VmZmljaWVudCBkYXRhIGxlbmd0aFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHsgYnVmZmVyOiByZWFkZXIuYnl0ZXMsIG9mZnNldDogY291bnQgKiBXb3JkU2l6ZSwgbGVuZ3RoOiByZWFkZXIuZGF0YUxlbmd0aCB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29kZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29kZXJzLnB1c2gobmV3IEFub255bW91c0NvZGVyKHRoaXMuY29kZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5wYWNrKHJlYWRlciwgY29kZXJzKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydGllcyIsImlzRXJyb3IiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsImFzc2VydEFyZ3VtZW50Q291bnQiLCJUeXBlZCIsIkNvZGVyIiwiUmVzdWx0IiwiV29yZFNpemUiLCJXcml0ZXIiLCJBbm9ueW1vdXNDb2RlciIsInBhY2siLCJ3cml0ZXIiLCJjb2RlcnMiLCJ2YWx1ZXMiLCJhcnJheVZhbHVlcyIsIkFycmF5IiwiaXNBcnJheSIsInVuaXF1ZSIsIm1hcCIsImNvZGVyIiwibmFtZSIsImxvY2FsTmFtZSIsImFyZ3VtZW50IiwiaW5mbyIsInZhbHVlIiwibGVuZ3RoIiwic3RhdGljV3JpdGVyIiwiZHluYW1pY1dyaXRlciIsInVwZGF0ZUZ1bmNzIiwiZm9yRWFjaCIsImluZGV4IiwiZHluYW1pYyIsImR5bmFtaWNPZmZzZXQiLCJlbmNvZGUiLCJ1cGRhdGVGdW5jIiwid3JpdGVVcGRhdGFibGVWYWx1ZSIsInB1c2giLCJiYXNlT2Zmc2V0IiwiZnVuYyIsImFwcGVuZFdyaXRlciIsInVucGFjayIsInJlYWRlciIsImtleXMiLCJiYXNlUmVhZGVyIiwic3ViUmVhZGVyIiwib2Zmc2V0IiwicmVhZEluZGV4Iiwib2Zmc2V0UmVhZGVyIiwiZGVjb2RlIiwiZXJyb3IiLCJiYXNlVHlwZSIsInR5cGUiLCJ1bmRlZmluZWQiLCJFcnJvciIsImZyb21JdGVtcyIsIkFycmF5Q29kZXIiLCJjb25zdHJ1Y3RvciIsImRlZmF1bHRWYWx1ZSIsImRlZmF1bHRDaGlsZCIsInJlc3VsdCIsImkiLCJfdmFsdWUiLCJkZXJlZmVyZW5jZSIsIl90aHJvd0Vycm9yIiwiY291bnQiLCJ3cml0ZVZhbHVlIiwiZGF0YUxlbmd0aCIsImJ1ZmZlciIsImJ5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/boolean.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/boolean.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BooleanCoder: () => (/* binding */ BooleanCoder)\n/* harmony export */ });\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n/**\n *  @_ignore\n */ class BooleanCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName){\n        super(\"bool\", \"bool\", localName, false);\n    }\n    defaultValue() {\n        return false;\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_1__.Typed.dereference(_value, \"bool\");\n        return writer.writeValue(value ? 1 : 0);\n    }\n    decode(reader) {\n        return !!reader.readValue();\n    }\n} //# sourceMappingURL=boolean.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ib29sZWFuLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvQztBQUNRO0FBQzVDOztDQUVDLEdBQ00sTUFBTUUscUJBQXFCRCxxREFBS0E7SUFDbkNFLFlBQVlDLFNBQVMsQ0FBRTtRQUNuQixLQUFLLENBQUMsUUFBUSxRQUFRQSxXQUFXO0lBQ3JDO0lBQ0FDLGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQUMsT0FBT0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDbkIsTUFBTUMsUUFBUVQsNENBQUtBLENBQUNVLFdBQVcsQ0FBQ0YsUUFBUTtRQUN4QyxPQUFPRCxPQUFPSSxVQUFVLENBQUNGLFFBQVEsSUFBSTtJQUN6QztJQUNBRyxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPLENBQUMsQ0FBQ0EsT0FBT0MsU0FBUztJQUM3QjtBQUNKLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veWlkLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvYm9vbGVhbi5qcz84NmMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4uL3R5cGVkLmpzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQm9vbGVhbkNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImJvb2xcIiwgXCJib29sXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcImJvb2xcIik7XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSA/IDEgOiAwKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gISFyZWFkZXIucmVhZFZhbHVlKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vbGVhbi5qcy5tYXAiXSwibmFtZXMiOlsiVHlwZWQiLCJDb2RlciIsIkJvb2xlYW5Db2RlciIsImNvbnN0cnVjdG9yIiwibG9jYWxOYW1lIiwiZGVmYXVsdFZhbHVlIiwiZW5jb2RlIiwid3JpdGVyIiwiX3ZhbHVlIiwidmFsdWUiLCJkZXJlZmVyZW5jZSIsIndyaXRlVmFsdWUiLCJkZWNvZGUiLCJyZWFkZXIiLCJyZWFkVmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/boolean.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/bytes.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/bytes.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BytesCoder: () => (/* binding */ BytesCoder),\n/* harmony export */   DynamicBytesCoder: () => (/* binding */ DynamicBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n/**\n *  @_ignore\n */ class DynamicBytesCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(type, localName){\n        super(type, type, localName, true);\n    }\n    defaultValue() {\n        return \"0x\";\n    }\n    encode(writer, value) {\n        value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytesCopy)(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n    decode(reader) {\n        return reader.readBytes(reader.readIndex(), true);\n    }\n}\n/**\n *  @_ignore\n */ class BytesCoder extends DynamicBytesCoder {\n    constructor(localName){\n        super(\"bytes\", localName);\n    }\n    decode(reader) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(super.decode(reader));\n    }\n} //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ieXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTZEO0FBQ2pCO0FBQzVDOztDQUVDLEdBQ00sTUFBTUcsMEJBQTBCRCxxREFBS0E7SUFDeENFLFlBQVlDLElBQUksRUFBRUMsU0FBUyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0QsTUFBTUEsTUFBTUMsV0FBVztJQUNqQztJQUNBQyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1FBQ2xCQSxRQUFRViw2REFBWUEsQ0FBQ1U7UUFDckIsSUFBSUMsU0FBU0YsT0FBT0csVUFBVSxDQUFDRixNQUFNQyxNQUFNO1FBQzNDQSxVQUFVRixPQUFPSSxVQUFVLENBQUNIO1FBQzVCLE9BQU9DO0lBQ1g7SUFDQUcsT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBT0EsT0FBT0MsU0FBUyxDQUFDRCxPQUFPRSxTQUFTLElBQUk7SUFDaEQ7QUFDSjtBQUNBOztDQUVDLEdBQ00sTUFBTUMsbUJBQW1CZjtJQUM1QkMsWUFBWUUsU0FBUyxDQUFFO1FBQ25CLEtBQUssQ0FBQyxTQUFTQTtJQUNuQjtJQUNBUSxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPZCx3REFBT0EsQ0FBQyxLQUFLLENBQUNhLE9BQU9DO0lBQ2hDO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95aWQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9ieXRlcy5qcz9mMzQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEJ5dGVzQ29weSwgaGV4bGlmeSB9IGZyb20gXCIuLi8uLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIER5bmFtaWNCeXRlc0NvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcih0eXBlLCB0eXBlLCBsb2NhbE5hbWUsIHRydWUpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBcIjB4XCI7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0Qnl0ZXNDb3B5KHZhbHVlKTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHdyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIGxlbmd0aCArPSB3cml0ZXIud3JpdGVCeXRlcyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQnl0ZXMocmVhZGVyLnJlYWRJbmRleCgpLCB0cnVlKTtcbiAgICB9XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgQnl0ZXNDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJieXRlc1wiLCBsb2NhbE5hbWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KHN1cGVyLmRlY29kZShyZWFkZXIpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0Qnl0ZXNDb3B5IiwiaGV4bGlmeSIsIkNvZGVyIiwiRHluYW1pY0J5dGVzQ29kZXIiLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJsb2NhbE5hbWUiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJ2YWx1ZSIsImxlbmd0aCIsIndyaXRlVmFsdWUiLCJ3cml0ZUJ5dGVzIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZEJ5dGVzIiwicmVhZEluZGV4IiwiQnl0ZXNDb2RlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedBytesCoder: () => (/* binding */ FixedBytesCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\n/**\n *  @_ignore\n */ class FixedBytesCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(size, localName){\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            size\n        }, {\n            size: \"number\"\n        });\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000000000000000000000000000\".substring(0, 2 + this.size * 2);\n    }\n    encode(writer, _value) {\n        let data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBytesCopy)(_typed_js__WEBPACK_IMPORTED_MODULE_3__.Typed.dereference(_value, this.type));\n        if (data.length !== this.size) {\n            this._throwError(\"incorrect data length\", _value);\n        }\n        return writer.writeBytes(data);\n    }\n    decode(reader) {\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.hexlify)(reader.readBytes(this.size));\n    }\n} //# sourceMappingURL=fixed-bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9maXhlZC1ieXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUErRTtBQUMzQztBQUNRO0FBQzVDOztDQUVDLEdBQ00sTUFBTUssd0JBQXdCRCxxREFBS0E7SUFFdENFLFlBQVlDLElBQUksRUFBRUMsU0FBUyxDQUFFO1FBQ3pCLElBQUlDLE9BQU8sVUFBVUMsT0FBT0g7UUFDNUIsS0FBSyxDQUFDRSxNQUFNQSxNQUFNRCxXQUFXO1FBQzdCUixpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVPO1FBQUssR0FBRztZQUFFQSxNQUFNO1FBQVM7SUFDdEQ7SUFDQUksZUFBZTtRQUNYLE9BQU8scUVBQXVFQyxTQUFTLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQ0wsSUFBSSxHQUFHO0lBQy9HO0lBQ0FNLE9BQU9DLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ25CLElBQUlDLE9BQU9mLDZEQUFZQSxDQUFDRSw0Q0FBS0EsQ0FBQ2MsV0FBVyxDQUFDRixRQUFRLElBQUksQ0FBQ0csSUFBSTtRQUMzRCxJQUFJRixLQUFLRyxNQUFNLEtBQUssSUFBSSxDQUFDWixJQUFJLEVBQUU7WUFDM0IsSUFBSSxDQUFDYSxXQUFXLENBQUMseUJBQXlCTDtRQUM5QztRQUNBLE9BQU9ELE9BQU9PLFVBQVUsQ0FBQ0w7SUFDN0I7SUFDQU0sT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBT3JCLHdEQUFPQSxDQUFDcUIsT0FBT0MsU0FBUyxDQUFDLElBQUksQ0FBQ2pCLElBQUk7SUFDN0M7QUFDSixFQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3lpZC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL2ZpeGVkLWJ5dGVzLmpzPzZlZWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZ2V0Qnl0ZXNDb3B5LCBoZXhsaWZ5IH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIEZpeGVkQnl0ZXNDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBzaXplO1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIGxvY2FsTmFtZSkge1xuICAgICAgICBsZXQgbmFtZSA9IFwiYnl0ZXNcIiArIFN0cmluZyhzaXplKTtcbiAgICAgICAgc3VwZXIobmFtZSwgbmFtZSwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBzaXplIH0sIHsgc2l6ZTogXCJudW1iZXJcIiB9KTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gKFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpLnN1YnN0cmluZygwLCAyICsgdGhpcy5zaXplICogMik7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBsZXQgZGF0YSA9IGdldEJ5dGVzQ29weShUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIHRoaXMudHlwZSkpO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcImluY29ycmVjdCBkYXRhIGxlbmd0aFwiLCBfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhkYXRhKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gaGV4bGlmeShyZWFkZXIucmVhZEJ5dGVzKHRoaXMuc2l6ZSkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpeGVkLWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0Qnl0ZXNDb3B5IiwiaGV4bGlmeSIsIlR5cGVkIiwiQ29kZXIiLCJGaXhlZEJ5dGVzQ29kZXIiLCJjb25zdHJ1Y3RvciIsInNpemUiLCJsb2NhbE5hbWUiLCJuYW1lIiwiU3RyaW5nIiwiZGVmYXVsdFZhbHVlIiwic3Vic3RyaW5nIiwiZW5jb2RlIiwid3JpdGVyIiwiX3ZhbHVlIiwiZGF0YSIsImRlcmVmZXJlbmNlIiwidHlwZSIsImxlbmd0aCIsIl90aHJvd0Vycm9yIiwid3JpdGVCeXRlcyIsImRlY29kZSIsInJlYWRlciIsInJlYWRCeXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/null.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/null.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NullCoder: () => (/* binding */ NullCoder)\n/* harmony export */ });\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\nconst Empty = new Uint8Array([]);\n/**\n *  @_ignore\n */ class NullCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(localName){\n        super(\"null\", \"\", localName, false);\n    }\n    defaultValue() {\n        return null;\n    }\n    encode(writer, value) {\n        if (value != null) {\n            this._throwError(\"not null\", value);\n        }\n        return writer.writeBytes(Empty);\n    }\n    decode(reader) {\n        reader.readBytes(0);\n        return null;\n    }\n} //# sourceMappingURL=null.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDO0FBQzVDLE1BQU1DLFFBQVEsSUFBSUMsV0FBVyxFQUFFO0FBQy9COztDQUVDLEdBQ00sTUFBTUMsa0JBQWtCSCxxREFBS0E7SUFDaENJLFlBQVlDLFNBQVMsQ0FBRTtRQUNuQixLQUFLLENBQUMsUUFBUSxJQUFJQSxXQUFXO0lBQ2pDO0lBQ0FDLGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQUMsT0FBT0MsTUFBTSxFQUFFQyxLQUFLLEVBQUU7UUFDbEIsSUFBSUEsU0FBUyxNQUFNO1lBQ2YsSUFBSSxDQUFDQyxXQUFXLENBQUMsWUFBWUQ7UUFDakM7UUFDQSxPQUFPRCxPQUFPRyxVQUFVLENBQUNWO0lBQzdCO0lBQ0FXLE9BQU9DLE1BQU0sRUFBRTtRQUNYQSxPQUFPQyxTQUFTLENBQUM7UUFDakIsT0FBTztJQUNYO0FBQ0osRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95aWQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udWxsLmpzP2IyMTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiO1xuY29uc3QgRW1wdHkgPSBuZXcgVWludDhBcnJheShbXSk7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgTnVsbENvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcIm51bGxcIiwgXCJcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwibm90IG51bGxcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhFbXB0eSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmVhZGVyLnJlYWRCeXRlcygwKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVsbC5qcy5tYXAiXSwibmFtZXMiOlsiQ29kZXIiLCJFbXB0eSIsIlVpbnQ4QXJyYXkiLCJOdWxsQ29kZXIiLCJjb25zdHJ1Y3RvciIsImxvY2FsTmFtZSIsImRlZmF1bHRWYWx1ZSIsImVuY29kZSIsIndyaXRlciIsInZhbHVlIiwiX3Rocm93RXJyb3IiLCJ3cml0ZUJ5dGVzIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZEJ5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/null.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/number.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/number.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberCoder: () => (/* binding */ NumberCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n\n\n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n/**\n *  @_ignore\n */ class NumberCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(size, signed, localName){\n        const name = (signed ? \"int\" : \"uint\") + size * 8;\n        super(name, name, localName, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            size,\n            signed\n        }, {\n            size: \"number\",\n            signed: \"boolean\"\n        });\n    }\n    defaultValue() {\n        return 0;\n    }\n    encode(writer, _value) {\n        let value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(_typed_js__WEBPACK_IMPORTED_MODULE_3__.Typed.dereference(_value, this.type));\n        // Check bounds are safe for encoding\n        let maxUintValue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(BN_MAX_UINT256, _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.WordSize * 8);\n        if (this.signed) {\n            let bounds = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(maxUintValue, this.size * 8 - 1);\n            if (value > bounds || value < -(bounds + BN_1)) {\n                this._throwError(\"value out-of-bounds\", _value);\n            }\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toTwos)(value, 8 * _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.WordSize);\n        } else if (value < BN_0 || value > (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(maxUintValue, this.size * 8)) {\n            this._throwError(\"value out-of-bounds\", _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        let value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.mask)(reader.readValue(), this.size * 8);\n        if (this.signed) {\n            value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.fromTwos)(value, this.size * 8);\n        }\n        return value;\n    }\n} //# sourceMappingURL=number.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9udW1iZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMkY7QUFDdkQ7QUFDa0I7QUFDdEQsTUFBTVEsT0FBT0MsT0FBTztBQUNwQixNQUFNQyxPQUFPRCxPQUFPO0FBQ3BCLE1BQU1FLGlCQUFpQkYsT0FBTztBQUM5Qjs7Q0FFQyxHQUNNLE1BQU1HLG9CQUFvQk4scURBQUtBO0lBR2xDTyxZQUFZQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsU0FBUyxDQUFFO1FBQ2pDLE1BQU1DLE9BQVEsQ0FBQ0YsU0FBUyxRQUFRLE1BQUssSUFBTUQsT0FBTztRQUNsRCxLQUFLLENBQUNHLE1BQU1BLE1BQU1ELFdBQVc7UUFDN0JoQixpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVjO1lBQU1DO1FBQU8sR0FBRztZQUFFRCxNQUFNO1lBQVVDLFFBQVE7UUFBVTtJQUNqRjtJQUNBRyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ25CLElBQUlDLFFBQVFwQiwwREFBU0EsQ0FBQ0csNENBQUtBLENBQUNrQixXQUFXLENBQUNGLFFBQVEsSUFBSSxDQUFDRyxJQUFJO1FBQ3pELHFDQUFxQztRQUNyQyxJQUFJQyxlQUFldEIscURBQUlBLENBQUNRLGdCQUFnQkosd0RBQVFBLEdBQUc7UUFDbkQsSUFBSSxJQUFJLENBQUNRLE1BQU0sRUFBRTtZQUNiLElBQUlXLFNBQVN2QixxREFBSUEsQ0FBQ3NCLGNBQWMsSUFBSyxDQUFDWCxJQUFJLEdBQUcsSUFBSztZQUNsRCxJQUFJUSxRQUFRSSxVQUFVSixRQUFRLENBQUVJLENBQUFBLFNBQVNoQixJQUFHLEdBQUk7Z0JBQzVDLElBQUksQ0FBQ2lCLFdBQVcsQ0FBQyx1QkFBdUJOO1lBQzVDO1lBQ0FDLFFBQVFsQix1REFBTUEsQ0FBQ2tCLE9BQU8sSUFBSWYsd0RBQVFBO1FBQ3RDLE9BQ0ssSUFBSWUsUUFBUWQsUUFBUWMsUUFBUW5CLHFEQUFJQSxDQUFDc0IsY0FBYyxJQUFJLENBQUNYLElBQUksR0FBRyxJQUFJO1lBQ2hFLElBQUksQ0FBQ2EsV0FBVyxDQUFDLHVCQUF1Qk47UUFDNUM7UUFDQSxPQUFPRCxPQUFPUSxVQUFVLENBQUNOO0lBQzdCO0lBQ0FPLE9BQU9DLE1BQU0sRUFBRTtRQUNYLElBQUlSLFFBQVFuQixxREFBSUEsQ0FBQzJCLE9BQU9DLFNBQVMsSUFBSSxJQUFJLENBQUNqQixJQUFJLEdBQUc7UUFDakQsSUFBSSxJQUFJLENBQUNDLE1BQU0sRUFBRTtZQUNiTyxRQUFRckIseURBQVFBLENBQUNxQixPQUFPLElBQUksQ0FBQ1IsSUFBSSxHQUFHO1FBQ3hDO1FBQ0EsT0FBT1E7SUFDWDtBQUNKLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veWlkLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FiaS9jb2RlcnMvbnVtYmVyLmpzPzcxNTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcywgZnJvbVR3b3MsIGdldEJpZ0ludCwgbWFzaywgdG9Ud29zIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBUeXBlZCB9IGZyb20gXCIuLi90eXBlZC5qc1wiO1xuaW1wb3J0IHsgQ29kZXIsIFdvcmRTaXplIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuY29uc3QgQk5fTUFYX1VJTlQyNTYgPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgTnVtYmVyQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgc2l6ZTtcbiAgICBzaWduZWQ7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgc2lnbmVkLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9ICgoc2lnbmVkID8gXCJpbnRcIiA6IFwidWludFwiKSArIChzaXplICogOCkpO1xuICAgICAgICBzdXBlcihuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHNpemUsIHNpZ25lZCB9LCB7IHNpemU6IFwibnVtYmVyXCIsIHNpZ25lZDogXCJib29sZWFuXCIgfSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBnZXRCaWdJbnQoVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCB0aGlzLnR5cGUpKTtcbiAgICAgICAgLy8gQ2hlY2sgYm91bmRzIGFyZSBzYWZlIGZvciBlbmNvZGluZ1xuICAgICAgICBsZXQgbWF4VWludFZhbHVlID0gbWFzayhCTl9NQVhfVUlOVDI1NiwgV29yZFNpemUgKiA4KTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICBsZXQgYm91bmRzID0gbWFzayhtYXhVaW50VmFsdWUsICh0aGlzLnNpemUgKiA4KSAtIDEpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gYm91bmRzIHx8IHZhbHVlIDwgLShib3VuZHMgKyBCTl8xKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIF92YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHRvVHdvcyh2YWx1ZSwgOCAqIFdvcmRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IEJOXzAgfHwgdmFsdWUgPiBtYXNrKG1heFVpbnRWYWx1ZSwgdGhpcy5zaXplICogOCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIF92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICBsZXQgdmFsdWUgPSBtYXNrKHJlYWRlci5yZWFkVmFsdWUoKSwgdGhpcy5zaXplICogOCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmcm9tVHdvcyh2YWx1ZSwgdGhpcy5zaXplICogOCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlci5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydGllcyIsImZyb21Ud29zIiwiZ2V0QmlnSW50IiwibWFzayIsInRvVHdvcyIsIlR5cGVkIiwiQ29kZXIiLCJXb3JkU2l6ZSIsIkJOXzAiLCJCaWdJbnQiLCJCTl8xIiwiQk5fTUFYX1VJTlQyNTYiLCJOdW1iZXJDb2RlciIsImNvbnN0cnVjdG9yIiwic2l6ZSIsInNpZ25lZCIsImxvY2FsTmFtZSIsIm5hbWUiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJfdmFsdWUiLCJ2YWx1ZSIsImRlcmVmZXJlbmNlIiwidHlwZSIsIm1heFVpbnRWYWx1ZSIsImJvdW5kcyIsIl90aHJvd0Vycm9yIiwid3JpdGVWYWx1ZSIsImRlY29kZSIsInJlYWRlciIsInJlYWRWYWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/number.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/string.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/string.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StringCoder: () => (/* binding */ StringCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utf8.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/bytes.js\");\n\n\n\n/**\n *  @_ignore\n */ class StringCoder extends _bytes_js__WEBPACK_IMPORTED_MODULE_0__.DynamicBytesCoder {\n    constructor(localName){\n        super(\"string\", localName);\n    }\n    defaultValue() {\n        return \"\";\n    }\n    encode(writer, _value) {\n        return super.encode(writer, (0,_utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(_typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"string\")));\n    }\n    decode(reader) {\n        return (0,_utils_utf8_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(super.decode(reader));\n    }\n} //# sourceMappingURL=string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy9zdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRTtBQUM1QjtBQUNXO0FBQy9DOztDQUVDLEdBQ00sTUFBTUksb0JBQW9CRCx3REFBaUJBO0lBQzlDRSxZQUFZQyxTQUFTLENBQUU7UUFDbkIsS0FBSyxDQUFDLFVBQVVBO0lBQ3BCO0lBQ0FDLGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQUMsT0FBT0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDbkIsT0FBTyxLQUFLLENBQUNGLE9BQU9DLFFBQVFULDJEQUFXQSxDQUFDRSw0Q0FBS0EsQ0FBQ1MsV0FBVyxDQUFDRCxRQUFRO0lBQ3RFO0lBQ0FFLE9BQU9DLE1BQU0sRUFBRTtRQUNYLE9BQU9aLDREQUFZQSxDQUFDLEtBQUssQ0FBQ1csT0FBT0M7SUFDckM7QUFDSixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3lpZC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hYmkvY29kZXJzL3N0cmluZy5qcz9mYjZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi4vLi4vdXRpbHMvdXRmOC5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IER5bmFtaWNCeXRlc0NvZGVyIH0gZnJvbSBcIi4vYnl0ZXMuanNcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJpbmdDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJzdHJpbmdcIiwgbG9jYWxOYW1lKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lbmNvZGUod3JpdGVyLCB0b1V0ZjhCeXRlcyhUeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwic3RyaW5nXCIpKSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyhzdXBlci5kZWNvZGUocmVhZGVyKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJ0b1V0ZjhCeXRlcyIsInRvVXRmOFN0cmluZyIsIlR5cGVkIiwiRHluYW1pY0J5dGVzQ29kZXIiLCJTdHJpbmdDb2RlciIsImNvbnN0cnVjdG9yIiwibG9jYWxOYW1lIiwiZGVmYXVsdFZhbHVlIiwiZW5jb2RlIiwid3JpdGVyIiwiX3ZhbHVlIiwiZGVyZWZlcmVuY2UiLCJkZWNvZGUiLCJyZWFkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/coders/tuple.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/coders/tuple.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TupleCoder: () => (/* binding */ TupleCoder)\n/* harmony export */ });\n/* harmony import */ var _utils_properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./array.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/array.js\");\n\n\n\n\n/**\n *  @_ignore\n */ class TupleCoder extends _abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Coder {\n    constructor(coders, localName){\n        let dynamic = false;\n        const types = [];\n        coders.forEach((coder)=>{\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        const type = \"tuple(\" + types.join(\",\") + \")\";\n        super(\"tuple\", type, localName, dynamic);\n        (0,_utils_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            coders: Object.freeze(coders.slice())\n        });\n    }\n    defaultValue() {\n        const values = [];\n        this.coders.forEach((coder)=>{\n            values.push(coder.defaultValue());\n        });\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder)=>{\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) {\n                    accum[name] = 0;\n                }\n                accum[name]++;\n            }\n            return accum;\n        }, {});\n        // Add named values\n        this.coders.forEach((coder, index)=>{\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) {\n                return;\n            }\n            if (name === \"length\") {\n                name = \"_length\";\n            }\n            if (values[name] != null) {\n                return;\n            }\n            values[name] = values[index];\n        });\n        return Object.freeze(values);\n    }\n    encode(writer, _value) {\n        const value = _typed_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(_value, \"tuple\");\n        return (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.pack)(writer, this.coders, value);\n    }\n    decode(reader) {\n        return (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.unpack)(reader, this.coders);\n    }\n} //# sourceMappingURL=tuple.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy90dXBsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE2RDtBQUN6QjtBQUNRO0FBQ0Y7QUFDMUM7O0NBRUMsR0FDTSxNQUFNSyxtQkFBbUJILHFEQUFLQTtJQUVqQ0ksWUFBWUMsTUFBTSxFQUFFQyxTQUFTLENBQUU7UUFDM0IsSUFBSUMsVUFBVTtRQUNkLE1BQU1DLFFBQVEsRUFBRTtRQUNoQkgsT0FBT0ksT0FBTyxDQUFDLENBQUNDO1lBQ1osSUFBSUEsTUFBTUgsT0FBTyxFQUFFO2dCQUNmQSxVQUFVO1lBQ2Q7WUFDQUMsTUFBTUcsSUFBSSxDQUFDRCxNQUFNRSxJQUFJO1FBQ3pCO1FBQ0EsTUFBTUEsT0FBUSxXQUFXSixNQUFNSyxJQUFJLENBQUMsT0FBTztRQUMzQyxLQUFLLENBQUMsU0FBU0QsTUFBTU4sV0FBV0M7UUFDaENULHNFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRU8sUUFBUVMsT0FBT0MsTUFBTSxDQUFDVixPQUFPVyxLQUFLO1FBQUk7SUFDbkU7SUFDQUMsZUFBZTtRQUNYLE1BQU1DLFNBQVMsRUFBRTtRQUNqQixJQUFJLENBQUNiLE1BQU0sQ0FBQ0ksT0FBTyxDQUFDLENBQUNDO1lBQ2pCUSxPQUFPUCxJQUFJLENBQUNELE1BQU1PLFlBQVk7UUFDbEM7UUFDQSw0REFBNEQ7UUFDNUQsTUFBTUUsY0FBYyxJQUFJLENBQUNkLE1BQU0sQ0FBQ2UsTUFBTSxDQUFDLENBQUNDLE9BQU9YO1lBQzNDLE1BQU1ZLE9BQU9aLE1BQU1KLFNBQVM7WUFDNUIsSUFBSWdCLE1BQU07Z0JBQ04sSUFBSSxDQUFDRCxLQUFLLENBQUNDLEtBQUssRUFBRTtvQkFDZEQsS0FBSyxDQUFDQyxLQUFLLEdBQUc7Z0JBQ2xCO2dCQUNBRCxLQUFLLENBQUNDLEtBQUs7WUFDZjtZQUNBLE9BQU9EO1FBQ1gsR0FBRyxDQUFDO1FBQ0osbUJBQW1CO1FBQ25CLElBQUksQ0FBQ2hCLE1BQU0sQ0FBQ0ksT0FBTyxDQUFDLENBQUNDLE9BQU9hO1lBQ3hCLElBQUlELE9BQU9aLE1BQU1KLFNBQVM7WUFDMUIsSUFBSSxDQUFDZ0IsUUFBUUgsV0FBVyxDQUFDRyxLQUFLLEtBQUssR0FBRztnQkFDbEM7WUFDSjtZQUNBLElBQUlBLFNBQVMsVUFBVTtnQkFDbkJBLE9BQU87WUFDWDtZQUNBLElBQUlKLE1BQU0sQ0FBQ0ksS0FBSyxJQUFJLE1BQU07Z0JBQ3RCO1lBQ0o7WUFDQUosTUFBTSxDQUFDSSxLQUFLLEdBQUdKLE1BQU0sQ0FBQ0ssTUFBTTtRQUNoQztRQUNBLE9BQU9ULE9BQU9DLE1BQU0sQ0FBQ0c7SUFDekI7SUFDQU0sT0FBT0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDbkIsTUFBTUMsUUFBUTVCLDRDQUFLQSxDQUFDNkIsV0FBVyxDQUFDRixRQUFRO1FBQ3hDLE9BQU96QiwrQ0FBSUEsQ0FBQ3dCLFFBQVEsSUFBSSxDQUFDcEIsTUFBTSxFQUFFc0I7SUFDckM7SUFDQUUsT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBTzVCLGlEQUFNQSxDQUFDNEIsUUFBUSxJQUFJLENBQUN6QixNQUFNO0lBQ3JDO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95aWQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2NvZGVycy90dXBsZS5qcz8zYTRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vLi4vdXRpbHMvcHJvcGVydGllcy5qc1wiO1xuaW1wb3J0IHsgVHlwZWQgfSBmcm9tIFwiLi4vdHlwZWQuanNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXIuanNcIjtcbmltcG9ydCB7IHBhY2ssIHVucGFjayB9IGZyb20gXCIuL2FycmF5LmpzXCI7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgVHVwbGVDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb2RlcnM7XG4gICAgY29uc3RydWN0b3IoY29kZXJzLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgbGV0IGR5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBbXTtcbiAgICAgICAgY29kZXJzLmZvckVhY2goKGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgICAgIGR5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZXMucHVzaChjb2Rlci50eXBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAoXCJ0dXBsZShcIiArIHR5cGVzLmpvaW4oXCIsXCIpICsgXCIpXCIpO1xuICAgICAgICBzdXBlcihcInR1cGxlXCIsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBjb2RlcnM6IE9iamVjdC5mcmVlemUoY29kZXJzLnNsaWNlKCkpIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLmNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goY29kZXIuZGVmYXVsdFZhbHVlKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2Ugb25seSBvdXRwdXQgbmFtZWQgcHJvcGVydGllcyBmb3IgdW5pcXVlbHkgbmFtZWQgY29kZXJzXG4gICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0gdGhpcy5jb2RlcnMucmVkdWNlKChhY2N1bSwgY29kZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghYWNjdW1bbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIC8vIEFkZCBuYW1lZCB2YWx1ZXNcbiAgICAgICAgdGhpcy5jb2RlcnMuZm9yRWFjaCgoY29kZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgIGlmICghbmFtZSB8fCB1bmlxdWVOYW1lc1tuYW1lXSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwiX2xlbmd0aFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzW25hbWVdID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHZhbHVlcyk7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJ0dXBsZVwiKTtcbiAgICAgICAgcmV0dXJuIHBhY2sod3JpdGVyLCB0aGlzLmNvZGVycywgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiB1bnBhY2socmVhZGVyLCB0aGlzLmNvZGVycyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHVwbGUuanMubWFwIl0sIm5hbWVzIjpbImRlZmluZVByb3BlcnRpZXMiLCJUeXBlZCIsIkNvZGVyIiwicGFjayIsInVucGFjayIsIlR1cGxlQ29kZXIiLCJjb25zdHJ1Y3RvciIsImNvZGVycyIsImxvY2FsTmFtZSIsImR5bmFtaWMiLCJ0eXBlcyIsImZvckVhY2giLCJjb2RlciIsInB1c2giLCJ0eXBlIiwiam9pbiIsIk9iamVjdCIsImZyZWV6ZSIsInNsaWNlIiwiZGVmYXVsdFZhbHVlIiwidmFsdWVzIiwidW5pcXVlTmFtZXMiLCJyZWR1Y2UiLCJhY2N1bSIsIm5hbWUiLCJpbmRleCIsImVuY29kZSIsIndyaXRlciIsIl92YWx1ZSIsInZhbHVlIiwiZGVyZWZlcmVuY2UiLCJkZWNvZGUiLCJyZWFkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/coders/tuple.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/fragments.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/fragments.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConstructorFragment: () => (/* binding */ ConstructorFragment),\n/* harmony export */   ErrorFragment: () => (/* binding */ ErrorFragment),\n/* harmony export */   EventFragment: () => (/* binding */ EventFragment),\n/* harmony export */   FallbackFragment: () => (/* binding */ FallbackFragment),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   FunctionFragment: () => (/* binding */ FunctionFragment),\n/* harmony export */   NamedFragment: () => (/* binding */ NamedFragment),\n/* harmony export */   ParamType: () => (/* binding */ ParamType),\n/* harmony export */   StructFragment: () => (/* binding */ StructFragment)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/id.js\");\n/**\n *  A fragment is a single item from an ABI, which may represent any of:\n *\n *  - [Functions](FunctionFragment)\n *  - [Events](EventFragment)\n *  - [Constructors](ConstructorFragment)\n *  - Custom [Errors](ErrorFragment)\n *  - [Fallback or Receive](FallbackFragment) functions\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */ \n\n;\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items) {\n    const result = new Set();\n    items.forEach((k)=>result.add(k));\n    return Object.freeze(result);\n}\nconst _kwVisibDeploy = \"external public payable override\";\nconst KwVisibDeploy = setify(_kwVisibDeploy.split(\" \"));\n// Visibility Keywords\nconst _kwVisib = \"constant external internal payable private public pure view override\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\nconst _kwOther = \"tuple returns\";\n// All Keywords\nconst _keywords = [\n    _kwTypes,\n    _kwModifiers,\n    _kwOther,\n    _kwVisib\n].join(\" \");\nconst Keywords = setify(_keywords.split(\" \"));\n// Single character tokens\nconst SimpleTokens = {\n    \"(\": \"OPEN_PAREN\",\n    \")\": \"CLOSE_PAREN\",\n    \"[\": \"OPEN_BRACKET\",\n    \"]\": \"CLOSE_BRACKET\",\n    \",\": \"COMMA\",\n    \"@\": \"AT\"\n};\n// Parser regexes to consume the next token\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n// Parser regexs to check validity\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\nclass TokenString {\n    #offset;\n    #tokens;\n    get offset() {\n        return this.#offset;\n    }\n    get length() {\n        return this.#tokens.length - this.#offset;\n    }\n    constructor(tokens){\n        this.#offset = 0;\n        this.#tokens = tokens.slice();\n    }\n    clone() {\n        return new TokenString(this.#tokens);\n    }\n    reset() {\n        this.#offset = 0;\n    }\n    #subTokenString(from = 0, to = 0) {\n        return new TokenString(this.#tokens.slice(from, to).map((t)=>{\n            return Object.freeze(Object.assign({}, t, {\n                match: t.match - from,\n                linkBack: t.linkBack - from,\n                linkNext: t.linkNext - from\n            }));\n        }));\n    }\n    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n    popKeyword(allowed) {\n        const top = this.peek();\n        if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) {\n            throw new Error(`expected keyword ${top.text}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n    popType(type) {\n        if (this.peek().type !== type) {\n            const top = this.peek();\n            throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns a \"(\" TOKENS \")\"\n    popParen() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = this.#subTokenString(this.#offset + 1, top.match + 1);\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n    popParams() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = [];\n        while(this.#offset < top.match - 1){\n            const link = this.peek().linkNext;\n            result.push(this.#subTokenString(this.#offset + 1, link));\n            this.#offset = link;\n        }\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Returns the top Token, throwing if out of tokens\n    peek() {\n        if (this.#offset >= this.#tokens.length) {\n            throw new Error(\"out-of-bounds\");\n        }\n        return this.#tokens[this.#offset];\n    }\n    // Returns the next value, if it is a keyword in `allowed`\n    peekKeyword(allowed) {\n        const top = this.peekType(\"KEYWORD\");\n        return top != null && allowed.has(top) ? top : null;\n    }\n    // Returns the value of the next token if it is `type`\n    peekType(type) {\n        if (this.length === 0) {\n            return null;\n        }\n        const top = this.peek();\n        return top.type === type ? top.text : null;\n    }\n    // Returns the next token; throws if out of tokens\n    pop() {\n        const result = this.peek();\n        this.#offset++;\n        return result;\n    }\n    toString() {\n        const tokens = [];\n        for(let i = this.#offset; i < this.#tokens.length; i++){\n            const token = this.#tokens[i];\n            tokens.push(`${token.type}:${token.text}`);\n        }\n        return `<TokenString ${tokens.join(\" \")}>`;\n    }\n}\nfunction lex(text) {\n    const tokens = [];\n    const throwError = (message)=>{\n        const token = offset < text.length ? JSON.stringify(text[offset]) : \"$EOI\";\n        throw new Error(`invalid token ${token} at ${offset}: ${message}`);\n    };\n    let brackets = [];\n    let commas = [];\n    let offset = 0;\n    while(offset < text.length){\n        // Strip off any leading whitespace\n        let cur = text.substring(offset);\n        let match = cur.match(regexWhitespacePrefix);\n        if (match) {\n            offset += match[1].length;\n            cur = text.substring(offset);\n        }\n        const token = {\n            depth: brackets.length,\n            linkBack: -1,\n            linkNext: -1,\n            match: -1,\n            type: \"\",\n            text: \"\",\n            offset,\n            value: -1\n        };\n        tokens.push(token);\n        let type = SimpleTokens[cur[0]] || \"\";\n        if (type) {\n            token.type = type;\n            token.text = cur[0];\n            offset++;\n            if (type === \"OPEN_PAREN\") {\n                brackets.push(tokens.length - 1);\n                commas.push(tokens.length - 1);\n            } else if (type == \"CLOSE_PAREN\") {\n                if (brackets.length === 0) {\n                    throwError(\"no matching open bracket\");\n                }\n                token.match = brackets.pop();\n                tokens[token.match].match = tokens.length - 1;\n                token.depth--;\n                token.linkBack = commas.pop();\n                tokens[token.linkBack].linkNext = tokens.length - 1;\n            } else if (type === \"COMMA\") {\n                token.linkBack = commas.pop();\n                tokens[token.linkBack].linkNext = tokens.length - 1;\n                commas.push(tokens.length - 1);\n            } else if (type === \"OPEN_BRACKET\") {\n                token.type = \"BRACKET\";\n            } else if (type === \"CLOSE_BRACKET\") {\n                // Remove the CLOSE_BRACKET\n                let suffix = tokens.pop().text;\n                if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n                    const value = tokens.pop().text;\n                    suffix = value + suffix;\n                    tokens[tokens.length - 1].value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getNumber)(value);\n                }\n                if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n                    throw new Error(\"missing opening bracket\");\n                }\n                tokens[tokens.length - 1].text += suffix;\n            }\n            continue;\n        }\n        match = cur.match(regexIdPrefix);\n        if (match) {\n            token.text = match[1];\n            offset += token.text.length;\n            if (Keywords.has(token.text)) {\n                token.type = \"KEYWORD\";\n                continue;\n            }\n            if (token.text.match(regexType)) {\n                token.type = \"TYPE\";\n                continue;\n            }\n            token.type = \"ID\";\n            continue;\n        }\n        match = cur.match(regexNumberPrefix);\n        if (match) {\n            token.text = match[1];\n            token.type = \"NUMBER\";\n            offset += token.text.length;\n            continue;\n        }\n        throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);\n    }\n    return new TokenString(tokens.map((t)=>Object.freeze(t)));\n}\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set, allowed) {\n    let included = [];\n    for(const key in allowed.keys()){\n        if (set.has(key)) {\n            included.push(key);\n        }\n    }\n    if (included.length > 1) {\n        throw new Error(`conflicting types: ${included.join(\", \")}`);\n    }\n}\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n// ...the name with an optional type, returning the name\nfunction consumeName(type, tokens) {\n    if (tokens.peekKeyword(KwTypes)) {\n        const keyword = tokens.pop().text;\n        if (keyword !== type) {\n            throw new Error(`expected ${type}, got ${keyword}`);\n        }\n    }\n    return tokens.popType(\"ID\");\n}\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens, allowed) {\n    const keywords = new Set();\n    while(true){\n        const keyword = tokens.peekType(\"KEYWORD\");\n        if (keyword == null || allowed && !allowed.has(keyword)) {\n            break;\n        }\n        tokens.pop();\n        if (keywords.has(keyword)) {\n            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);\n        }\n        keywords.add(keyword);\n    }\n    return Object.freeze(keywords);\n}\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens) {\n    let modifiers = consumeKeywords(tokens, KwVisib);\n    // Detect conflicting modifiers\n    allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n    allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n    // Process mutability states\n    if (modifiers.has(\"view\")) {\n        return \"view\";\n    }\n    if (modifiers.has(\"pure\")) {\n        return \"pure\";\n    }\n    if (modifiers.has(\"payable\")) {\n        return \"payable\";\n    }\n    if (modifiers.has(\"nonpayable\")) {\n        return \"nonpayable\";\n    }\n    // Process legacy `constant` last\n    if (modifiers.has(\"constant\")) {\n        return \"view\";\n    }\n    return \"nonpayable\";\n}\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens, allowIndexed) {\n    return tokens.popParams().map((t)=>ParamType.from(t, allowIndexed));\n}\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens) {\n    if (tokens.peekType(\"AT\")) {\n        tokens.pop();\n        if (tokens.peekType(\"NUMBER\")) {\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBigInt)(tokens.pop().text);\n        }\n        throw new Error(\"invalid gas\");\n    }\n    return null;\n}\nfunction consumeEoi(tokens) {\n    if (tokens.length) {\n        throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);\n    }\n}\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nfunction verifyBasicType(type) {\n    const match = type.match(regexType);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(match, \"invalid type\", \"type\", type);\n    if (type === \"uint\") {\n        return \"uint256\";\n    }\n    if (type === \"int\") {\n        return \"int256\";\n    }\n    if (match[2]) {\n        // bytesXX\n        const length = parseInt(match[2]);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n    } else if (match[3]) {\n        // intXX or uintXX\n        const size = parseInt(match[3]);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, \"invalid numeric width\", \"type\", type);\n    }\n    return type;\n}\n// Make the Fragment constructors effectively private\nconst _guard = {};\nconst internal = Symbol.for(\"_ethers_internal\");\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\n/**\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\n */ class ParamType {\n    /**\n     *  @private\n     */ constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertPrivate)(guard, _guard, \"ParamType\");\n        Object.defineProperty(this, internal, {\n            value: ParamTypeInternal\n        });\n        if (components) {\n            components = Object.freeze(components.slice());\n        }\n        if (baseType === \"array\") {\n            if (arrayLength == null || arrayChildren == null) {\n                throw new Error(\"\");\n            }\n        } else if (arrayLength != null || arrayChildren != null) {\n            throw new Error(\"\");\n        }\n        if (baseType === \"tuple\") {\n            if (components == null) {\n                throw new Error(\"\");\n            }\n        } else if (components != null) {\n            throw new Error(\"\");\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            name,\n            type,\n            baseType,\n            indexed,\n            components,\n            arrayLength,\n            arrayChildren\n        });\n    }\n    /**\n     *  Return a string representation of this type.\n     *\n     *  For example,\n     *\n     *  ``sighash\" => \"(uint256,address)\"``\n     *\n     *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n     *\n     *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            const name = this.name || \"\";\n            if (this.isArray()) {\n                const result = JSON.parse(this.arrayChildren.format(\"json\"));\n                result.name = name;\n                result.type += `[${this.arrayLength < 0 ? \"\" : String(this.arrayLength)}]`;\n                return JSON.stringify(result);\n            }\n            const result = {\n                type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n                name\n            };\n            if (typeof this.indexed === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.isTuple()) {\n                result.components = this.components.map((c)=>JSON.parse(c.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.isArray()) {\n            result += this.arrayChildren.format(format);\n            result += `[${this.arrayLength < 0 ? \"\" : String(this.arrayLength)}]`;\n        } else {\n            if (this.isTuple()) {\n                result += \"(\" + this.components.map((comp)=>comp.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n        if (format !== \"sighash\") {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === \"full\" && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    /**\n     *  Returns true if %%this%% is an Array type.\n     *\n     *  This provides a type gaurd ensuring that [[arrayChildren]]\n     *  and [[arrayLength]] are non-null.\n     */ isArray() {\n        return this.baseType === \"array\";\n    }\n    /**\n     *  Returns true if %%this%% is a Tuple type.\n     *\n     *  This provides a type gaurd ensuring that [[components]]\n     *  is non-null.\n     */ isTuple() {\n        return this.baseType === \"tuple\";\n    }\n    /**\n     *  Returns true if %%this%% is an Indexable type.\n     *\n     *  This provides a type gaurd ensuring that [[indexed]]\n     *  is non-null.\n     */ isIndexable() {\n        return this.indexed != null;\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, calling %%process%%\n     *  on each type, destructing the %%value%% recursively.\n     */ walk(value, process) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v)=>_this.arrayChildren.walk(v, process));\n        }\n        if (this.isTuple()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid tuple value\");\n            }\n            if (value.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v, i)=>_this.components[i].walk(v, process));\n        }\n        return process(this.type, value);\n    }\n    #walkAsync(promises, value, process, setValue) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const childType = this.arrayChildren;\n            const result = value.slice();\n            result.forEach((value, index)=>{\n                childType.#walkAsync(promises, value, process, (value)=>{\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        if (this.isTuple()) {\n            const components = this.components;\n            // Convert the object into an array\n            let result;\n            if (Array.isArray(value)) {\n                result = value.slice();\n            } else {\n                if (value == null || typeof value !== \"object\") {\n                    throw new Error(\"invalid tuple value\");\n                }\n                result = components.map((param)=>{\n                    if (!param.name) {\n                        throw new Error(\"cannot use object value with unnamed components\");\n                    }\n                    if (!(param.name in value)) {\n                        throw new Error(`missing value for component ${param.name}`);\n                    }\n                    return value[param.name];\n                });\n            }\n            if (result.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            result.forEach((value, index)=>{\n                components[index].#walkAsync(promises, value, process, (value)=>{\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        const result = process(this.type, value);\n        if (result.then) {\n            promises.push(async function() {\n                setValue(await result);\n            }());\n        } else {\n            setValue(result);\n        }\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, asynchronously calling\n     *  %%process%% on each type, destructing the %%value%% recursively.\n     *\n     *  This can be used to resolve ENS names by walking and resolving each\n     *  ``\"address\"`` type.\n     */ async walkAsync(value, process) {\n        const promises = [];\n        const result = [\n            value\n        ];\n        this.#walkAsync(promises, value, process, (value)=>{\n            result[0] = value;\n        });\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        return result[0];\n    }\n    /**\n     *  Creates a new **ParamType** for %%obj%%.\n     *\n     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n     *  otherwise the ``indexed`` keyword will throw an error.\n     */ static from(obj, allowIndexed) {\n        if (ParamType.isParamType(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return ParamType.from(lex(obj), allowIndexed);\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid param type\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            let type = \"\", baseType = \"\";\n            let comps = null;\n            if (consumeKeywords(obj, setify([\n                \"tuple\"\n            ])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n                // Tuple\n                baseType = \"tuple\";\n                comps = obj.popParams().map((t)=>ParamType.from(t));\n                type = `tuple(${comps.map((c)=>c.format()).join(\",\")})`;\n            } else {\n                // Normal\n                type = verifyBasicType(obj.popType(\"TYPE\"));\n                baseType = type;\n            }\n            // Check for Array\n            let arrayChildren = null;\n            let arrayLength = null;\n            while(obj.length && obj.peekType(\"BRACKET\")){\n                const bracket = obj.pop(); //arrays[i];\n                arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n                arrayLength = bracket.value;\n                type += bracket.text;\n                baseType = \"array\";\n                comps = null;\n            }\n            let indexed = null;\n            const keywords = consumeKeywords(obj, KwModifiers);\n            if (keywords.has(\"indexed\")) {\n                if (!allowIndexed) {\n                    throw new Error(\"\");\n                }\n                indexed = true;\n            }\n            const name = obj.peekType(\"ID\") ? obj.pop().text : \"\";\n            if (obj.length) {\n                throw new Error(\"leftover tokens\");\n            }\n            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n        }\n        const name = obj.name;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(!name || typeof name === \"string\" && name.match(regexId), \"invalid name\", \"obj.name\", name);\n        let indexed = obj.indexed;\n        if (indexed != null) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n            indexed = !!indexed;\n        }\n        let type = obj.type;\n        let arrayMatch = type.match(regexArrayType);\n        if (arrayMatch) {\n            const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n            const arrayChildren = ParamType.from({\n                type: arrayMatch[1],\n                components: obj.components\n            });\n            return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n        }\n        if (type === \"tuple\" || type.startsWith(\"tuple(\" /* fix: ) */ ) || type.startsWith(\"(\" /* fix: ) */ )) {\n            const comps = obj.components != null ? obj.components.map((c)=>ParamType.from(c)) : null;\n            const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\n            // @TODO: use lexer to validate and normalize type\n            return tuple;\n        }\n        type = verifyBasicType(obj.type);\n        return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n    }\n    /**\n     *  Returns true if %%value%% is a **ParamType**.\n     */ static isParamType(value) {\n        return value && value[internal] === ParamTypeInternal;\n    }\n}\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */ class Fragment {\n    /**\n     *  @private\n     */ constructor(guard, type, inputs){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertPrivate)(guard, _guard, \"Fragment\");\n        inputs = Object.freeze(inputs.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            type,\n            inputs\n        });\n    }\n    /**\n     *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n     *  ABI frgament type.\n     */ static from(obj) {\n        if (typeof obj === \"string\") {\n            // Try parsing JSON...\n            try {\n                Fragment.from(JSON.parse(obj));\n            } catch (e) {}\n            // ...otherwise, use the human-readable lexer\n            return Fragment.from(lex(obj));\n        }\n        if (obj instanceof TokenString) {\n            // Human-readable ABI (already lexed)\n            const type = obj.peekKeyword(KwTypes);\n            switch(type){\n                case \"constructor\":\n                    return ConstructorFragment.from(obj);\n                case \"error\":\n                    return ErrorFragment.from(obj);\n                case \"event\":\n                    return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\":\n                    return FunctionFragment.from(obj);\n                case \"struct\":\n                    return StructFragment.from(obj);\n            }\n        } else if (typeof obj === \"object\") {\n            // JSON ABI\n            switch(obj.type){\n                case \"constructor\":\n                    return ConstructorFragment.from(obj);\n                case \"error\":\n                    return ErrorFragment.from(obj);\n                case \"event\":\n                    return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\":\n                    return FunctionFragment.from(obj);\n                case \"struct\":\n                    return StructFragment.from(obj);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(false, `unsupported type: ${obj.type}`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"Fragment.from\"\n            });\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported frgament object\", \"obj\", obj);\n    }\n    /**\n     *  Returns true if %%value%% is a [[ConstructorFragment]].\n     */ static isConstructor(value) {\n        return ConstructorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[ErrorFragment]].\n     */ static isError(value) {\n        return ErrorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[EventFragment]].\n     */ static isEvent(value) {\n        return EventFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[FunctionFragment]].\n     */ static isFunction(value) {\n        return FunctionFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[StructFragment]].\n     */ static isStruct(value) {\n        return StructFragment.isFragment(value);\n    }\n}\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */ class NamedFragment extends Fragment {\n    /**\n     *  @private\n     */ constructor(guard, type, name, inputs){\n        super(guard, type, inputs);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(typeof name === \"string\" && name.match(regexId), \"invalid identifier\", \"name\", name);\n        inputs = Object.freeze(inputs.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            name\n        });\n    }\n}\nfunction joinParams(format, params) {\n    return \"(\" + params.map((p)=>p.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n}\n/**\n *  A Fragment which represents a //Custom Error//.\n */ class ErrorFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, inputs){\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: ErrorFragmentInternal\n        });\n    }\n    /**\n     *  The Custom Error selector.\n     */ get selector() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this fragment as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input)=>JSON.parse(input.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"error\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ErrorFragment** for %%obj%%.\n     */ static from(obj) {\n        if (ErrorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            return ErrorFragment.from(lex(obj));\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"error\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new ErrorFragment(_guard, name, inputs);\n        }\n        return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **ErrorFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === ErrorFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents an Event.\n */ class EventFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, inputs, anonymous){\n        super(guard, \"event\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: EventFragmentInternal\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            anonymous\n        });\n    }\n    /**\n     *  The Event topic hash.\n     */ get topicHash() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.format(\"sighash\"));\n    }\n    /**\n     *  Returns a string representation of this event as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"event\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\" && this.anonymous) {\n            result.push(\"anonymous\");\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the topic hash for an event with %%name%% and %%params%%.\n     */ static getTopicHash(name, params) {\n        params = (params || []).map((p)=>ParamType.from(p));\n        const fragment = new EventFragment(_guard, name, params, false);\n        return fragment.topicHash;\n    }\n    /**\n     *  Returns a new **EventFragment** for %%obj%%.\n     */ static from(obj) {\n        if (EventFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return EventFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid event fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"event\", obj);\n            const inputs = consumeParams(obj, true);\n            const anonymous = !!consumeKeywords(obj, setify([\n                \"anonymous\"\n            ])).has(\"anonymous\");\n            consumeEoi(obj);\n            return new EventFragment(_guard, name, inputs, anonymous);\n        }\n        return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p)=>ParamType.from(p, true)) : [], !!obj.anonymous);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **EventFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === EventFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a constructor.\n */ class ConstructorFragment extends Fragment {\n    /**\n     *  @private\n     */ constructor(guard, type, inputs, payable, gas){\n        super(guard, type, inputs);\n        Object.defineProperty(this, internal, {\n            value: ConstructorFragmentInternal\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            payable,\n            gas\n        });\n    }\n    /**\n     *  Returns a string representation of this constructor as %%format%%.\n     */ format(format) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"format(sighash)\"\n        });\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: this.payable ? \"payable\" : \"undefined\",\n                payable: this.payable,\n                gas: this.gas != null ? this.gas : undefined,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format)))\n            });\n        }\n        const result = [\n            `constructor${joinParams(format, this.inputs)}`\n        ];\n        if (this.payable) {\n            result.push(\"payable\");\n        }\n        if (this.gas != null) {\n            result.push(`@${this.gas.toString()}`);\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ConstructorFragment** for %%obj%%.\n     */ static from(obj) {\n        if (ConstructorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return ConstructorFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid constuctor fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            consumeKeywords(obj, setify([\n                \"constructor\"\n            ]));\n            const inputs = consumeParams(obj);\n            const payable = !!consumeKeywords(obj, KwVisibDeploy).has(\"payable\");\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n        }\n        return new ConstructorFragment(_guard, \"constructor\", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **ConstructorFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === ConstructorFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a method.\n */ class FallbackFragment extends Fragment {\n    constructor(guard, inputs, payable){\n        super(guard, \"fallback\", inputs);\n        Object.defineProperty(this, internal, {\n            value: FallbackFragmentInternal\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            payable\n        });\n    }\n    /**\n     *  Returns a string representation of this fallback as %%format%%.\n     */ format(format) {\n        const type = this.inputs.length === 0 ? \"receive\" : \"fallback\";\n        if (format === \"json\") {\n            const stateMutability = this.payable ? \"payable\" : \"nonpayable\";\n            return JSON.stringify({\n                type,\n                stateMutability\n            });\n        }\n        return `${type}()${this.payable ? \" payable\" : \"\"}`;\n    }\n    /**\n     *  Returns a new **FallbackFragment** for %%obj%%.\n     */ static from(obj) {\n        if (FallbackFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return FallbackFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid fallback fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const errorObj = obj.toString();\n            const topIsValid = obj.peekKeyword(setify([\n                \"fallback\",\n                \"receive\"\n            ]));\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n            const type = obj.popKeyword(setify([\n                \"fallback\",\n                \"receive\"\n            ]));\n            // receive()\n            if (type === \"receive\") {\n                const inputs = consumeParams(obj);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(inputs.length === 0, `receive cannot have arguments`, \"obj.inputs\", inputs);\n                consumeKeywords(obj, setify([\n                    \"payable\"\n                ]));\n                consumeEoi(obj);\n                return new FallbackFragment(_guard, [], true);\n            }\n            // fallback() [payable]\n            // fallback(bytes) [payable] returns (bytes)\n            let inputs = consumeParams(obj);\n            if (inputs.length) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(inputs.length === 1 && inputs[0].type === \"bytes\", \"invalid fallback inputs\", \"obj.inputs\", inputs.map((i)=>i.format(\"minimal\")).join(\", \"));\n            } else {\n                inputs = [\n                    ParamType.from(\"bytes\")\n                ];\n            }\n            const mutability = consumeMutability(obj);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n            if (consumeKeywords(obj, setify([\n                \"returns\"\n            ])).has(\"returns\")) {\n                const outputs = consumeParams(obj);\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(outputs.length === 1 && outputs[0].type === \"bytes\", \"invalid fallback outputs\", \"obj.outputs\", outputs.map((i)=>i.format(\"minimal\")).join(\", \"));\n            }\n            consumeEoi(obj);\n            return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n        }\n        if (obj.type === \"receive\") {\n            return new FallbackFragment(_guard, [], true);\n        }\n        if (obj.type === \"fallback\") {\n            const inputs = [\n                ParamType.from(\"bytes\")\n            ];\n            const payable = obj.stateMutability === \"payable\";\n            return new FallbackFragment(_guard, inputs, payable);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid fallback description\", \"obj\", obj);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FallbackFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === FallbackFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a method.\n */ class FunctionFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, stateMutability, inputs, outputs, gas){\n        super(guard, \"function\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: FunctionFragmentInternal\n        });\n        outputs = Object.freeze(outputs.slice());\n        const constant = stateMutability === \"view\" || stateMutability === \"pure\";\n        const payable = stateMutability === \"payable\";\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, {\n            constant,\n            gas,\n            outputs,\n            payable,\n            stateMutability\n        });\n    }\n    /**\n     *  The Function selector.\n     */ get selector() {\n        return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_3__.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this function as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n                payable: this.payable,\n                gas: this.gas != null ? this.gas : undefined,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format))),\n                outputs: this.outputs.map((o)=>JSON.parse(o.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"function\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\") {\n            if (this.stateMutability !== \"nonpayable\") {\n                result.push(this.stateMutability);\n            }\n            if (this.outputs && this.outputs.length) {\n                result.push(\"returns\");\n                result.push(joinParams(format, this.outputs));\n            }\n            if (this.gas != null) {\n                result.push(`@${this.gas.toString()}`);\n            }\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the selector for a function with %%name%% and %%params%%.\n     */ static getSelector(name, params) {\n        params = (params || []).map((p)=>ParamType.from(p));\n        const fragment = new FunctionFragment(_guard, name, \"view\", params, [], null);\n        return fragment.selector;\n    }\n    /**\n     *  Returns a new **FunctionFragment** for %%obj%%.\n     */ static from(obj) {\n        if (FunctionFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return FunctionFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid function fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"function\", obj);\n            const inputs = consumeParams(obj);\n            const mutability = consumeMutability(obj);\n            let outputs = [];\n            if (consumeKeywords(obj, setify([\n                \"returns\"\n            ])).has(\"returns\")) {\n                outputs = consumeParams(obj);\n            }\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n        }\n        let stateMutability = obj.stateMutability;\n        // Use legacy Solidity ABI logic if stateMutability is missing\n        if (stateMutability == null) {\n            stateMutability = \"payable\";\n            if (typeof obj.constant === \"boolean\") {\n                stateMutability = \"view\";\n                if (!obj.constant) {\n                    stateMutability = \"payable\";\n                    if (typeof obj.payable === \"boolean\" && !obj.payable) {\n                        stateMutability = \"nonpayable\";\n                    }\n                }\n            } else if (typeof obj.payable === \"boolean\" && !obj.payable) {\n                stateMutability = \"nonpayable\";\n            }\n        }\n        // @TODO: verifyState for stateMutability (e.g. throw if\n        //        payable: false but stateMutability is \"nonpayable\")\n        return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FunctionFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === FunctionFragmentInternal;\n    }\n}\n/**\n *  A Fragment which represents a structure.\n */ class StructFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, inputs){\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: StructFragmentInternal\n        });\n    }\n    /**\n     *  Returns a string representation of this struct as %%format%%.\n     */ format() {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Returns a new **StructFragment** for %%obj%%.\n     */ static from(obj) {\n        if (typeof obj === \"string\") {\n            try {\n                return StructFragment.from(lex(obj));\n            } catch (error) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid struct fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"struct\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new StructFragment(_guard, name, inputs);\n        }\n        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    // @TODO: fix this return type\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **StructFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === StructFragmentInternal;\n    }\n} //# sourceMappingURL=fragments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ZyYWdtZW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNpSDtBQUM1RTs7QUFFdEMscUNBQXFDO0FBQ3JDLFNBQVNPLE9BQU9DLEtBQUs7SUFDakIsTUFBTUMsU0FBUyxJQUFJQztJQUNuQkYsTUFBTUcsT0FBTyxDQUFDLENBQUNDLElBQU1ILE9BQU9JLEdBQUcsQ0FBQ0Q7SUFDaEMsT0FBT0UsT0FBT0MsTUFBTSxDQUFDTjtBQUN6QjtBQUNBLE1BQU1PLGlCQUFpQjtBQUN2QixNQUFNQyxnQkFBZ0JWLE9BQU9TLGVBQWVFLEtBQUssQ0FBQztBQUNsRCxzQkFBc0I7QUFDdEIsTUFBTUMsV0FBVztBQUNqQixNQUFNQyxVQUFVYixPQUFPWSxTQUFTRCxLQUFLLENBQUM7QUFDdEMsTUFBTUcsV0FBVztBQUNqQixNQUFNQyxVQUFVZixPQUFPYyxTQUFTSCxLQUFLLENBQUM7QUFDdEMsTUFBTUssZUFBZTtBQUNyQixNQUFNQyxjQUFjakIsT0FBT2dCLGFBQWFMLEtBQUssQ0FBQztBQUM5QyxNQUFNTyxXQUFXO0FBQ2pCLGVBQWU7QUFDZixNQUFNQyxZQUFZO0lBQUNMO0lBQVVFO0lBQWNFO0lBQVVOO0NBQVMsQ0FBQ1EsSUFBSSxDQUFDO0FBQ3BFLE1BQU1DLFdBQVdyQixPQUFPbUIsVUFBVVIsS0FBSyxDQUFDO0FBQ3hDLDBCQUEwQjtBQUMxQixNQUFNVyxlQUFlO0lBQ2pCLEtBQUs7SUFBYyxLQUFLO0lBQ3hCLEtBQUs7SUFBZ0IsS0FBSztJQUMxQixLQUFLO0lBQVMsS0FBSztBQUN2QjtBQUNBLDJDQUEyQztBQUMzQyxNQUFNQyx3QkFBd0IsSUFBSUMsT0FBTztBQUN6QyxNQUFNQyxvQkFBb0IsSUFBSUQsT0FBTztBQUNyQyxNQUFNRSxnQkFBZ0IsSUFBSUYsT0FBTztBQUNqQyxrQ0FBa0M7QUFDbEMsTUFBTUcsVUFBVSxJQUFJSCxPQUFP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LEtBQUtTO0lBQ3pDO0FBQ0osRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95aWQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ZyYWdtZW50cy5qcz83MWIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEEgZnJhZ21lbnQgaXMgYSBzaW5nbGUgaXRlbSBmcm9tIGFuIEFCSSwgd2hpY2ggbWF5IHJlcHJlc2VudCBhbnkgb2Y6XG4gKlxuICogIC0gW0Z1bmN0aW9uc10oRnVuY3Rpb25GcmFnbWVudClcbiAqICAtIFtFdmVudHNdKEV2ZW50RnJhZ21lbnQpXG4gKiAgLSBbQ29uc3RydWN0b3JzXShDb25zdHJ1Y3RvckZyYWdtZW50KVxuICogIC0gQ3VzdG9tIFtFcnJvcnNdKEVycm9yRnJhZ21lbnQpXG4gKiAgLSBbRmFsbGJhY2sgb3IgUmVjZWl2ZV0oRmFsbGJhY2tGcmFnbWVudCkgZnVuY3Rpb25zXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvYWJpL2FiaS1jb2RlcjpGcmFnbWVudHMgIFthYm91dC1mcmFnbWVudHNdXG4gKi9cbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMsIGdldEJpZ0ludCwgZ2V0TnVtYmVyLCBhc3NlcnQsIGFzc2VydFByaXZhdGUsIGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuLi9oYXNoL2luZGV4LmpzXCI7XG47XG4vLyBbIFwiYVwiLCBcImJcIiBdID0+IHsgXCJhXCI6IDEsIFwiYlwiOiAxIH1cbmZ1bmN0aW9uIHNldGlmeShpdGVtcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcbiAgICBpdGVtcy5mb3JFYWNoKChrKSA9PiByZXN1bHQuYWRkKGspKTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xufVxuY29uc3QgX2t3VmlzaWJEZXBsb3kgPSBcImV4dGVybmFsIHB1YmxpYyBwYXlhYmxlIG92ZXJyaWRlXCI7XG5jb25zdCBLd1Zpc2liRGVwbG95ID0gc2V0aWZ5KF9rd1Zpc2liRGVwbG95LnNwbGl0KFwiIFwiKSk7XG4vLyBWaXNpYmlsaXR5IEtleXdvcmRzXG5jb25zdCBfa3dWaXNpYiA9IFwiY29uc3RhbnQgZXh0ZXJuYWwgaW50ZXJuYWwgcGF5YWJsZSBwcml2YXRlIHB1YmxpYyBwdXJlIHZpZXcgb3ZlcnJpZGVcIjtcbmNvbnN0IEt3VmlzaWIgPSBzZXRpZnkoX2t3VmlzaWIuc3BsaXQoXCIgXCIpKTtcbmNvbnN0IF9rd1R5cGVzID0gXCJjb25zdHJ1Y3RvciBlcnJvciBldmVudCBmYWxsYmFjayBmdW5jdGlvbiByZWNlaXZlIHN0cnVjdFwiO1xuY29uc3QgS3dUeXBlcyA9IHNldGlmeShfa3dUeXBlcy5zcGxpdChcIiBcIikpO1xuY29uc3QgX2t3TW9kaWZpZXJzID0gXCJjYWxsZGF0YSBtZW1vcnkgc3RvcmFnZSBwYXlhYmxlIGluZGV4ZWRcIjtcbmNvbnN0IEt3TW9kaWZpZXJzID0gc2V0aWZ5KF9rd01vZGlmaWVycy5zcGxpdChcIiBcIikpO1xuY29uc3QgX2t3T3RoZXIgPSBcInR1cGxlIHJldHVybnNcIjtcbi8vIEFsbCBLZXl3b3Jkc1xuY29uc3QgX2tleXdvcmRzID0gW19rd1R5cGVzLCBfa3dNb2RpZmllcnMsIF9rd090aGVyLCBfa3dWaXNpYl0uam9pbihcIiBcIik7XG5jb25zdCBLZXl3b3JkcyA9IHNldGlmeShfa2V5d29yZHMuc3BsaXQoXCIgXCIpKTtcbi8vIFNpbmdsZSBjaGFyYWN0ZXIgdG9rZW5zXG5jb25zdCBTaW1wbGVUb2tlbnMgPSB7XG4gICAgXCIoXCI6IFwiT1BFTl9QQVJFTlwiLCBcIilcIjogXCJDTE9TRV9QQVJFTlwiLFxuICAgIFwiW1wiOiBcIk9QRU5fQlJBQ0tFVFwiLCBcIl1cIjogXCJDTE9TRV9CUkFDS0VUXCIsXG4gICAgXCIsXCI6IFwiQ09NTUFcIiwgXCJAXCI6IFwiQVRcIlxufTtcbi8vIFBhcnNlciByZWdleGVzIHRvIGNvbnN1bWUgdGhlIG5leHQgdG9rZW5cbmNvbnN0IHJlZ2V4V2hpdGVzcGFjZVByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFxcXFxzKilcIik7XG5jb25zdCByZWdleE51bWJlclByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFswLTldKylcIik7XG5jb25zdCByZWdleElkUHJlZml4ID0gbmV3IFJlZ0V4cChcIl4oW2EtekEtWiRfXVthLXpBLVowLTkkX10qKVwiKTtcbi8vIFBhcnNlciByZWdleHMgdG8gY2hlY2sgdmFsaWRpdHlcbmNvbnN0IHJlZ2V4SWQgPSBuZXcgUmVnRXhwKFwiXihbYS16QS1aJF9dW2EtekEtWjAtOSRfXSopJFwiKTtcbmNvbnN0IHJlZ2V4VHlwZSA9IG5ldyBSZWdFeHAoXCJeKGFkZHJlc3N8Ym9vbHxieXRlcyhbMC05XSopfHN0cmluZ3x1P2ludChbMC05XSopKSRcIik7XG5jbGFzcyBUb2tlblN0cmluZyB7XG4gICAgI29mZnNldDtcbiAgICAjdG9rZW5zO1xuICAgIGdldCBvZmZzZXQoKSB7IHJldHVybiB0aGlzLiNvZmZzZXQ7IH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jdG9rZW5zLmxlbmd0aCAtIHRoaXMuI29mZnNldDsgfVxuICAgIGNvbnN0cnVjdG9yKHRva2Vucykge1xuICAgICAgICB0aGlzLiNvZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLiN0b2tlbnMgPSB0b2tlbnMuc2xpY2UoKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7IHJldHVybiBuZXcgVG9rZW5TdHJpbmcodGhpcy4jdG9rZW5zKTsgfVxuICAgIHJlc2V0KCkgeyB0aGlzLiNvZmZzZXQgPSAwOyB9XG4gICAgI3N1YlRva2VuU3RyaW5nKGZyb20gPSAwLCB0byA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUb2tlblN0cmluZyh0aGlzLiN0b2tlbnMuc2xpY2UoZnJvbSwgdG8pLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbih7fSwgdCwge1xuICAgICAgICAgICAgICAgIG1hdGNoOiAodC5tYXRjaCAtIGZyb20pLFxuICAgICAgICAgICAgICAgIGxpbmtCYWNrOiAodC5saW5rQmFjayAtIGZyb20pLFxuICAgICAgICAgICAgICAgIGxpbmtOZXh0OiAodC5saW5rTmV4dCAtIGZyb20pLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBuZXh0IHRva2VuLCBpZiBpdCBpcyBhIGtleXdvcmQgaW4gYWxsb3dlZDsgdGhyb3dzIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwb3BLZXl3b3JkKGFsbG93ZWQpIHtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmICh0b3AudHlwZSAhPT0gXCJLRVlXT1JEXCIgfHwgIWFsbG93ZWQuaGFzKHRvcC50ZXh0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBrZXl3b3JkICR7dG9wLnRleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9wKCkudGV4dDtcbiAgICB9XG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4gaWYgaXQgaXMgYHR5cGVgOyB0aHJvd3MgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBvcFR5cGUodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5wZWVrKCkudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7dHlwZX07IGdvdCAke3RvcC50eXBlfSAke0pTT04uc3RyaW5naWZ5KHRvcC50ZXh0KX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3AoKS50ZXh0O1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIGEgXCIoXCIgVE9LRU5TIFwiKVwiXG4gICAgcG9wUGFyZW4oKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiT1BFTl9QQVJFTlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgc3RhcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jc3ViVG9rZW5TdHJpbmcodGhpcy4jb2Zmc2V0ICsgMSwgdG9wLm1hdGNoICsgMSk7XG4gICAgICAgIHRoaXMuI29mZnNldCA9IHRvcC5tYXRjaCArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgdGhlIGl0ZW1zIHdpdGhpbiBcIihcIiBJVEVNMSBcIixcIiBJVEVNMiBcIixcIiAuLi4gXCIpXCJcbiAgICBwb3BQYXJhbXMoKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiT1BFTl9QQVJFTlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgc3RhcnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLiNvZmZzZXQgPCB0b3AubWF0Y2ggLSAxKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5wZWVrKCkubGlua05leHQ7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLiNzdWJUb2tlblN0cmluZyh0aGlzLiNvZmZzZXQgKyAxLCBsaW5rKSk7XG4gICAgICAgICAgICB0aGlzLiNvZmZzZXQgPSBsaW5rO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI29mZnNldCA9IHRvcC5tYXRjaCArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHRvcCBUb2tlbiwgdGhyb3dpbmcgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBlZWsoKSB7XG4gICAgICAgIGlmICh0aGlzLiNvZmZzZXQgPj0gdGhpcy4jdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3V0LW9mLWJvdW5kc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jdG9rZW5zW3RoaXMuI29mZnNldF07XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG5leHQgdmFsdWUsIGlmIGl0IGlzIGEga2V5d29yZCBpbiBgYWxsb3dlZGBcbiAgICBwZWVrS2V5d29yZChhbGxvd2VkKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVla1R5cGUoXCJLRVlXT1JEXCIpO1xuICAgICAgICByZXR1cm4gKHRvcCAhPSBudWxsICYmIGFsbG93ZWQuaGFzKHRvcCkpID8gdG9wIDogbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgdG9rZW4gaWYgaXQgaXMgYHR5cGVgXG4gICAgcGVla1R5cGUodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICByZXR1cm4gKHRvcC50eXBlID09PSB0eXBlKSA/IHRvcC50ZXh0IDogbnVsbDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbmV4dCB0b2tlbjsgdGhyb3dzIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwb3AoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucGVlaygpO1xuICAgICAgICB0aGlzLiNvZmZzZXQrKztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy4jb2Zmc2V0OyBpIDwgdGhpcy4jdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuI3Rva2Vuc1tpXTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKGAke3Rva2VuLnR5cGV9OiR7dG9rZW4udGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYDxUb2tlblN0cmluZyAke3Rva2Vucy5qb2luKFwiIFwiKX0+YDtcbiAgICB9XG59XG5mdW5jdGlvbiBsZXgodGV4dCkge1xuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgIGNvbnN0IHRocm93RXJyb3IgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICBjb25zdCB0b2tlbiA9IChvZmZzZXQgPCB0ZXh0Lmxlbmd0aCkgPyBKU09OLnN0cmluZ2lmeSh0ZXh0W29mZnNldF0pIDogXCIkRU9JXCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0b2tlbiAke3Rva2VufSBhdCAke29mZnNldH06ICR7bWVzc2FnZX1gKTtcbiAgICB9O1xuICAgIGxldCBicmFja2V0cyA9IFtdO1xuICAgIGxldCBjb21tYXMgPSBbXTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICB3aGlsZSAob2Zmc2V0IDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIGFueSBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgbGV0IGN1ciA9IHRleHQuc3Vic3RyaW5nKG9mZnNldCk7XG4gICAgICAgIGxldCBtYXRjaCA9IGN1ci5tYXRjaChyZWdleFdoaXRlc3BhY2VQcmVmaXgpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgICAgICBjdXIgPSB0ZXh0LnN1YnN0cmluZyhvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VuID0geyBkZXB0aDogYnJhY2tldHMubGVuZ3RoLCBsaW5rQmFjazogLTEsIGxpbmtOZXh0OiAtMSwgbWF0Y2g6IC0xLCB0eXBlOiBcIlwiLCB0ZXh0OiBcIlwiLCBvZmZzZXQsIHZhbHVlOiAtMSB9O1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIGxldCB0eXBlID0gKFNpbXBsZVRva2Vuc1tjdXJbMF1dIHx8IFwiXCIpO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgdG9rZW4udHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gY3VyWzBdO1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJPUEVOX1BBUkVOXCIpIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBjb21tYXMucHVzaCh0b2tlbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IFwiQ0xPU0VfUEFSRU5cIikge1xuICAgICAgICAgICAgICAgIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihcIm5vIG1hdGNoaW5nIG9wZW4gYnJhY2tldFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW4ubWF0Y2ggPSBicmFja2V0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2VuLm1hdGNoXSkubWF0Y2ggPSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB0b2tlbi5kZXB0aC0tO1xuICAgICAgICAgICAgICAgIHRva2VuLmxpbmtCYWNrID0gY29tbWFzLnBvcCgpO1xuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW4ubGlua0JhY2tdKS5saW5rTmV4dCA9IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJDT01NQVwiKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4ubGlua0JhY2sgPSBjb21tYXMucG9wKCk7XG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbi5saW5rQmFja10pLmxpbmtOZXh0ID0gdG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgY29tbWFzLnB1c2godG9rZW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJPUEVOX0JSQUNLRVRcIikge1xuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgPSBcIkJSQUNLRVRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQ0xPU0VfQlJBQ0tFVFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBDTE9TRV9CUkFDS0VUXG4gICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IHRva2Vucy5wb3AoKS50ZXh0O1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMCAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgPT09IFwiTlVNQkVSXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0b2tlbnMucG9wKCkudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gdmFsdWUgKyBzdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKS52YWx1ZSA9IGdldE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udHlwZSAhPT0gXCJCUkFDS0VUXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBvcGVuaW5nIGJyYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKS50ZXh0ICs9IHN1ZmZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4SWRQcmVmaXgpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIG9mZnNldCArPSB0b2tlbi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChLZXl3b3Jkcy5oYXModG9rZW4udGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJLRVlXT1JEXCI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4udGV4dC5tYXRjaChyZWdleFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiVFlQRVwiO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiSURcIjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4TnVtYmVyUHJlZml4KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gXCJOVU1CRVJcIjtcbiAgICAgICAgICAgIG9mZnNldCArPSB0b2tlbi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCB0b2tlbiAke0pTT04uc3RyaW5naWZ5KGN1clswXSl9IGF0IHBvc2l0aW9uICR7b2Zmc2V0fWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHRva2Vucy5tYXAoKHQpID0+IE9iamVjdC5mcmVlemUodCkpKTtcbn1cbi8vIENoZWNrIG9ubHkgb25lIG9mIGBhbGxvd2VkYCBpcyBpbiBgc2V0YFxuZnVuY3Rpb24gYWxsb3dTaW5nbGUoc2V0LCBhbGxvd2VkKSB7XG4gICAgbGV0IGluY2x1ZGVkID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYWxsb3dlZC5rZXlzKCkpIHtcbiAgICAgICAgaWYgKHNldC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgaW5jbHVkZWQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbmNsdWRlZC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29uZmxpY3RpbmcgdHlwZXM6ICR7aW5jbHVkZWQuam9pbihcIiwgXCIpfWApO1xuICAgIH1cbn1cbi8vIEZ1bmN0aW9ucyB0byBwcm9jZXNzIGEgU29saWRpdHkgU2lnbmF0dXJlIFRva2VuU3RyaW5nIGZyb20gbGVmdC10by1yaWdodCBmb3IuLi5cbi8vIC4uLnRoZSBuYW1lIHdpdGggYW4gb3B0aW9uYWwgdHlwZSwgcmV0dXJuaW5nIHRoZSBuYW1lXG5mdW5jdGlvbiBjb25zdW1lTmFtZSh0eXBlLCB0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zLnBlZWtLZXl3b3JkKEt3VHlwZXMpKSB7XG4gICAgICAgIGNvbnN0IGtleXdvcmQgPSB0b2tlbnMucG9wKCkudGV4dDtcbiAgICAgICAgaWYgKGtleXdvcmQgIT09IHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHt0eXBlfSwgZ290ICR7a2V5d29yZH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zLnBvcFR5cGUoXCJJRFwiKTtcbn1cbi8vIC4uLmFsbCBrZXl3b3JkcyBtYXRjaGluZyBhbGxvd2VkLCByZXR1cm5pbmcgdGhlIGtleXdvcmRzXG5mdW5jdGlvbiBjb25zdW1lS2V5d29yZHModG9rZW5zLCBhbGxvd2VkKSB7XG4gICAgY29uc3Qga2V5d29yZHMgPSBuZXcgU2V0KCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3Qga2V5d29yZCA9IHRva2Vucy5wZWVrVHlwZShcIktFWVdPUkRcIik7XG4gICAgICAgIGlmIChrZXl3b3JkID09IG51bGwgfHwgKGFsbG93ZWQgJiYgIWFsbG93ZWQuaGFzKGtleXdvcmQpKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICBpZiAoa2V5d29yZHMuaGFzKGtleXdvcmQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZSBrZXl3b3JkczogJHtKU09OLnN0cmluZ2lmeShrZXl3b3JkKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBrZXl3b3Jkcy5hZGQoa2V5d29yZCk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGtleXdvcmRzKTtcbn1cbi8vIC4uLmFsbCB2aXNpYmlsaXR5IGtleXdvcmRzLCByZXR1cm5pbmcgdGhlIGNvYWxlc2NlZCBtdXRhYmlsaXR5XG5mdW5jdGlvbiBjb25zdW1lTXV0YWJpbGl0eSh0b2tlbnMpIHtcbiAgICBsZXQgbW9kaWZpZXJzID0gY29uc3VtZUtleXdvcmRzKHRva2VucywgS3dWaXNpYik7XG4gICAgLy8gRGV0ZWN0IGNvbmZsaWN0aW5nIG1vZGlmaWVyc1xuICAgIGFsbG93U2luZ2xlKG1vZGlmaWVycywgc2V0aWZ5KFwiY29uc3RhbnQgcGF5YWJsZSBub25wYXlhYmxlXCIuc3BsaXQoXCIgXCIpKSk7XG4gICAgYWxsb3dTaW5nbGUobW9kaWZpZXJzLCBzZXRpZnkoXCJwdXJlIHZpZXcgcGF5YWJsZSBub25wYXlhYmxlXCIuc3BsaXQoXCIgXCIpKSk7XG4gICAgLy8gUHJvY2VzcyBtdXRhYmlsaXR5IHN0YXRlc1xuICAgIGlmIChtb2RpZmllcnMuaGFzKFwidmlld1wiKSkge1xuICAgICAgICByZXR1cm4gXCJ2aWV3XCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwicHVyZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJwdXJlXCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwicGF5YWJsZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJwYXlhYmxlXCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwibm9ucGF5YWJsZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJub25wYXlhYmxlXCI7XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgbGVnYWN5IGBjb25zdGFudGAgbGFzdFxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwiY29uc3RhbnRcIikpIHtcbiAgICAgICAgcmV0dXJuIFwidmlld1wiO1xuICAgIH1cbiAgICByZXR1cm4gXCJub25wYXlhYmxlXCI7XG59XG4vLyAuLi5hIHBhcmFtZXRlciBsaXN0LCByZXR1cm5pbmcgdGhlIFBhcmFtVHlwZSBsaXN0XG5mdW5jdGlvbiBjb25zdW1lUGFyYW1zKHRva2VucywgYWxsb3dJbmRleGVkKSB7XG4gICAgcmV0dXJuIHRva2Vucy5wb3BQYXJhbXMoKS5tYXAoKHQpID0+IFBhcmFtVHlwZS5mcm9tKHQsIGFsbG93SW5kZXhlZCkpO1xufVxuLy8gLi4uYSBnYXMgbGltaXQsIHJldHVybmluZyBhIEJpZ051bWJlciBvciBudWxsIGlmIG5vbmVcbmZ1bmN0aW9uIGNvbnN1bWVHYXModG9rZW5zKSB7XG4gICAgaWYgKHRva2Vucy5wZWVrVHlwZShcIkFUXCIpKSB7XG4gICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgaWYgKHRva2Vucy5wZWVrVHlwZShcIk5VTUJFUlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJpZ0ludCh0b2tlbnMucG9wKCkudGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBnYXNcIik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29uc3VtZUVvaSh0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgdG9rZW5zIGF0IG9mZnNldCAke3Rva2Vucy5vZmZzZXR9OiAke3Rva2Vucy50b1N0cmluZygpfWApO1xuICAgIH1cbn1cbmNvbnN0IHJlZ2V4QXJyYXlUeXBlID0gbmV3IFJlZ0V4cCgvXiguKilcXFsoWzAtOV0qKVxcXSQvKTtcbmZ1bmN0aW9uIHZlcmlmeUJhc2ljVHlwZSh0eXBlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4VHlwZSk7XG4gICAgYXNzZXJ0QXJndW1lbnQobWF0Y2gsIFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICBpZiAodHlwZSA9PT0gXCJ1aW50XCIpIHtcbiAgICAgICAgcmV0dXJuIFwidWludDI1NlwiO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJpbnRcIikge1xuICAgICAgICByZXR1cm4gXCJpbnQyNTZcIjtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgIC8vIGJ5dGVzWFhcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChsZW5ndGggIT09IDAgJiYgbGVuZ3RoIDw9IDMyLCBcImludmFsaWQgYnl0ZXMgbGVuZ3RoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgLy8gaW50WFggb3IgdWludFhYXG4gICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHNpemUgIT09IDAgJiYgc2l6ZSA8PSAyNTYgJiYgKHNpemUgJSA4KSA9PT0gMCwgXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbn1cbi8vIE1ha2UgdGhlIEZyYWdtZW50IGNvbnN0cnVjdG9ycyBlZmZlY3RpdmVseSBwcml2YXRlXG5jb25zdCBfZ3VhcmQgPSB7fTtcbmNvbnN0IGludGVybmFsID0gU3ltYm9sLmZvcihcIl9ldGhlcnNfaW50ZXJuYWxcIik7XG5jb25zdCBQYXJhbVR5cGVJbnRlcm5hbCA9IFwiX1BhcmFtVHlwZUludGVybmFsXCI7XG5jb25zdCBFcnJvckZyYWdtZW50SW50ZXJuYWwgPSBcIl9FcnJvckludGVybmFsXCI7XG5jb25zdCBFdmVudEZyYWdtZW50SW50ZXJuYWwgPSBcIl9FdmVudEludGVybmFsXCI7XG5jb25zdCBDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwgPSBcIl9Db25zdHJ1Y3RvckludGVybmFsXCI7XG5jb25zdCBGYWxsYmFja0ZyYWdtZW50SW50ZXJuYWwgPSBcIl9GYWxsYmFja0ludGVybmFsXCI7XG5jb25zdCBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwgPSBcIl9GdW5jdGlvbkludGVybmFsXCI7XG5jb25zdCBTdHJ1Y3RGcmFnbWVudEludGVybmFsID0gXCJfU3RydWN0SW50ZXJuYWxcIjtcbi8qKlxuICogIEVhY2ggaW5wdXQgYW5kIG91dHB1dCBvZiBhIFtbRnJhZ21lbnRdXSBpcyBhbiBBcnJheSBvZiAqKlBhcmFtVHlwZSoqLlxuICovXG5leHBvcnQgY2xhc3MgUGFyYW1UeXBlIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGxvY2FsIG5hbWUgb2YgdGhlIHBhcmFtZXRlciAob3IgYGBcIlwiYGAgaWYgdW5ib3VuZClcbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbHkgcXVhbGlmaWVkIHR5cGUgKGUuZy4gYGBcImFkZHJlc3NcImBgLCBgYFwidHVwbGUoYWRkcmVzcylcImBgLFxuICAgICAqICBgYFwidWludDI1NlszXVtdXCJgYClcbiAgICAgKi9cbiAgICB0eXBlO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmFzZSB0eXBlIChlLmcuIGBgXCJhZGRyZXNzXCJgYCwgYGBcInR1cGxlXCJgYCwgYGBcImFycmF5XCJgYClcbiAgICAgKi9cbiAgICBiYXNlVHlwZTtcbiAgICAvKipcbiAgICAgKiAgVHJ1ZSBpZiB0aGUgcGFyYW1ldGVycyBpcyBpbmRleGVkLlxuICAgICAqXG4gICAgICogIEZvciBub24taW5kZXhhYmxlIHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgaW5kZXhlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbXBvbmVudHMgZm9yIHRoZSB0dXBsZS5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLXR1cGxlIHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgY29tcG9uZW50cztcbiAgICAvKipcbiAgICAgKiAgVGhlIGFycmF5IGxlbmd0aCwgb3IgYGAtMWBgIGZvciBkeW5hbWljLWxlbmd0aGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLWFycmF5IHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgYXJyYXlMZW5ndGg7XG4gICAgLyoqXG4gICAgICogIFRoZSB0eXBlIG9mIGVhY2ggY2hpbGQgaW4gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogIEZvciBub24tYXJyYXkgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBhcnJheUNoaWxkcmVuO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCB0eXBlLCBiYXNlVHlwZSwgaW5kZXhlZCwgY29tcG9uZW50cywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pIHtcbiAgICAgICAgYXNzZXJ0UHJpdmF0ZShndWFyZCwgX2d1YXJkLCBcIlBhcmFtVHlwZVwiKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBQYXJhbVR5cGVJbnRlcm5hbCB9KTtcbiAgICAgICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSBPYmplY3QuZnJlZXplKGNvbXBvbmVudHMuc2xpY2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIGlmIChhcnJheUxlbmd0aCA9PSBudWxsIHx8IGFycmF5Q2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcnJheUxlbmd0aCAhPSBudWxsIHx8IGFycmF5Q2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgbmFtZSwgdHlwZSwgYmFzZVR5cGUsIGluZGV4ZWQsIGNvbXBvbmVudHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSxcbiAgICAgKlxuICAgICAqICBgYHNpZ2hhc2hcIiA9PiBcIih1aW50MjU2LGFkZHJlc3MpXCJgYFxuICAgICAqXG4gICAgICogIGBgXCJtaW5pbWFsXCIgPT4gXCJ0dXBsZSh1aW50MjU2LGFkZHJlc3MpIGluZGV4ZWRcImBgXG4gICAgICpcbiAgICAgKiAgYGBcImZ1bGxcIiA9PiBcInR1cGxlKHVpbnQyNTYgZm9vLCBhZGRyZXNzIGJhcikgaW5kZXhlZCBiYXpcImBgXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lIHx8IFwiXCI7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoXCJqc29uXCIpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnR5cGUgKz0gYFskeyh0aGlzLmFycmF5TGVuZ3RoIDwgMCA/IFwiXCIgOiBTdHJpbmcodGhpcy5hcnJheUxlbmd0aCkpfV1gO1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICgodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSA/IFwidHVwbGVcIiA6IHRoaXMudHlwZSksXG4gICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHRoaXMuaW5kZXhlZCkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmluZGV4ZWQgPSB0aGlzLmluZGV4ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cy5tYXAoKGMpID0+IEpTT04ucGFyc2UoYy5mb3JtYXQoZm9ybWF0KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBgWyR7KHRoaXMuYXJyYXlMZW5ndGggPCAwID8gXCJcIiA6IFN0cmluZyh0aGlzLmFycmF5TGVuZ3RoKSl9XWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIoXCIgKyB0aGlzLmNvbXBvbmVudHMubWFwKChjb21wKSA9PiBjb21wLmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IFwiZnVsbFwiKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBpbmRleGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBcImZ1bGxcIiAmJiB0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhbiBBcnJheSB0eXBlLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGdhdXJkIGVuc3VyaW5nIHRoYXQgW1thcnJheUNoaWxkcmVuXV1cbiAgICAgKiAgYW5kIFtbYXJyYXlMZW5ndGhdXSBhcmUgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhc2VUeXBlID09PSBcImFycmF5XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGEgVHVwbGUgdHlwZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgdHlwZSBnYXVyZCBlbnN1cmluZyB0aGF0IFtbY29tcG9uZW50c11dXG4gICAgICogIGlzIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzVHVwbGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBhbiBJbmRleGFibGUgdHlwZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgdHlwZSBnYXVyZCBlbnN1cmluZyB0aGF0IFtbaW5kZXhlZF1dXG4gICAgICogIGlzIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzSW5kZXhhYmxlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW5kZXhlZCAhPSBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdhbGtzIHRoZSAqKlBhcmFtVHlwZSoqIHdpdGggJSV2YWx1ZSUlLCBjYWxsaW5nICUlcHJvY2VzcyUlXG4gICAgICogIG9uIGVhY2ggdHlwZSwgZGVzdHJ1Y3RpbmcgdGhlICUldmFsdWUlJSByZWN1cnNpdmVseS5cbiAgICAgKi9cbiAgICB3YWxrKHZhbHVlLCBwcm9jZXNzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXJyYXkgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hcnJheUxlbmd0aCAhPT0gLTEgJiYgdmFsdWUubGVuZ3RoICE9PSB0aGlzLmFycmF5TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gKF90aGlzLmFycmF5Q2hpbGRyZW4ud2Fsayh2LCBwcm9jZXNzKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdHVwbGUgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodiwgaSkgPT4gKF90aGlzLmNvbXBvbmVudHNbaV0ud2Fsayh2LCBwcm9jZXNzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9jZXNzKHRoaXMudHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAjd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2Vzcywgc2V0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhcnJheSB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFycmF5TGVuZ3RoICE9PSAtMSAmJiB2YWx1ZS5sZW5ndGggIT09IHRoaXMuYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSB0aGlzLmFycmF5Q2hpbGRyZW47XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5zbGljZSgpO1xuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNoaWxkVHlwZS4jd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2VzcywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0VmFsdWUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHM7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBvYmplY3QgaW50byBhbiBhcnJheVxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgKHZhbHVlKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb21wb25lbnRzLm1hcCgocGFyYW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdXNlIG9iamVjdCB2YWx1ZSB3aXRoIHVubmFtZWQgY29tcG9uZW50c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXJhbS5uYW1lIGluIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIHZhbHVlIGZvciBjb21wb25lbnQgJHtwYXJhbS5uYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtwYXJhbS5uYW1lXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICE9PSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgaXMgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHNbaW5kZXhdLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRWYWx1ZShyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHByb2Nlc3ModGhpcy50eXBlLCB2YWx1ZSk7XG4gICAgICAgIGlmIChyZXN1bHQudGhlbikge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgZnVuY3Rpb24gKCkgeyBzZXRWYWx1ZShhd2FpdCByZXN1bHQpOyB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFZhbHVlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdhbGtzIHRoZSAqKlBhcmFtVHlwZSoqIHdpdGggJSV2YWx1ZSUlLCBhc3luY2hyb25vdXNseSBjYWxsaW5nXG4gICAgICogICUlcHJvY2VzcyUlIG9uIGVhY2ggdHlwZSwgZGVzdHJ1Y3RpbmcgdGhlICUldmFsdWUlJSByZWN1cnNpdmVseS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiBiZSB1c2VkIHRvIHJlc29sdmUgRU5TIG5hbWVzIGJ5IHdhbGtpbmcgYW5kIHJlc29sdmluZyBlYWNoXG4gICAgICogIGBgXCJhZGRyZXNzXCJgYCB0eXBlLlxuICAgICAqL1xuICAgIGFzeW5jIHdhbGtBc3luYyh2YWx1ZSwgcHJvY2Vzcykge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbdmFsdWVdO1xuICAgICAgICB0aGlzLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqUGFyYW1UeXBlKiogZm9yICUlb2JqJSUuXG4gICAgICpcbiAgICAgKiAgSWYgJSVhbGxvd0luZGV4ZWQlJSB0aGVuIHRoZSBgYGluZGV4ZWRgYCBrZXl3b3JkIGlzIHBlcm1pdHRlZCxcbiAgICAgKiAgb3RoZXJ3aXNlIHRoZSBgYGluZGV4ZWRgYCBrZXl3b3JkIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqLCBhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgaWYgKFBhcmFtVHlwZS5pc1BhcmFtVHlwZShvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcmFtVHlwZS5mcm9tKGxleChvYmopLCBhbGxvd0luZGV4ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBwYXJhbSB0eXBlXCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gXCJcIiwgYmFzZVR5cGUgPSBcIlwiO1xuICAgICAgICAgICAgbGV0IGNvbXBzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1widHVwbGVcIl0pKS5oYXMoXCJ0dXBsZVwiKSB8fCBvYmoucGVla1R5cGUoXCJPUEVOX1BBUkVOXCIpKSB7XG4gICAgICAgICAgICAgICAgLy8gVHVwbGVcbiAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IFwidHVwbGVcIjtcbiAgICAgICAgICAgICAgICBjb21wcyA9IG9iai5wb3BQYXJhbXMoKS5tYXAoKHQpID0+IFBhcmFtVHlwZS5mcm9tKHQpKTtcbiAgICAgICAgICAgICAgICB0eXBlID0gYHR1cGxlKCR7Y29tcHMubWFwKChjKSA9PiBjLmZvcm1hdCgpKS5qb2luKFwiLFwiKX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vcm1hbFxuICAgICAgICAgICAgICAgIHR5cGUgPSB2ZXJpZnlCYXNpY1R5cGUob2JqLnBvcFR5cGUoXCJUWVBFXCIpKTtcbiAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgQXJyYXlcbiAgICAgICAgICAgIGxldCBhcnJheUNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBhcnJheUxlbmd0aCA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAob2JqLmxlbmd0aCAmJiBvYmoucGVla1R5cGUoXCJCUkFDS0VUXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnJhY2tldCA9IG9iai5wb3AoKTsgLy9hcnJheXNbaV07XG4gICAgICAgICAgICAgICAgYXJyYXlDaGlsZHJlbiA9IG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBcIlwiLCB0eXBlLCBiYXNlVHlwZSwgbnVsbCwgY29tcHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBhcnJheUxlbmd0aCA9IGJyYWNrZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgdHlwZSArPSBicmFja2V0LnRleHQ7XG4gICAgICAgICAgICAgICAgYmFzZVR5cGUgPSBcImFycmF5XCI7XG4gICAgICAgICAgICAgICAgY29tcHMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGluZGV4ZWQgPSBudWxsO1xuICAgICAgICAgICAgY29uc3Qga2V5d29yZHMgPSBjb25zdW1lS2V5d29yZHMob2JqLCBLd01vZGlmaWVycyk7XG4gICAgICAgICAgICBpZiAoa2V5d29yZHMuaGFzKFwiaW5kZXhlZFwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghYWxsb3dJbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXhlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gKG9iai5wZWVrVHlwZShcIklEXCIpID8gb2JqLnBvcCgpLnRleHQgOiBcIlwiKTtcbiAgICAgICAgICAgIGlmIChvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGVmdG92ZXIgdG9rZW5zXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lLCB0eXBlLCBiYXNlVHlwZSwgaW5kZXhlZCwgY29tcHMsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gb2JqLm5hbWU7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KCFuYW1lIHx8ICh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiICYmIG5hbWUubWF0Y2gocmVnZXhJZCkpLCBcImludmFsaWQgbmFtZVwiLCBcIm9iai5uYW1lXCIsIG5hbWUpO1xuICAgICAgICBsZXQgaW5kZXhlZCA9IG9iai5pbmRleGVkO1xuICAgICAgICBpZiAoaW5kZXhlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChhbGxvd0luZGV4ZWQsIFwicGFyYW1ldGVyIGNhbm5vdCBiZSBpbmRleGVkXCIsIFwib2JqLmluZGV4ZWRcIiwgb2JqLmluZGV4ZWQpO1xuICAgICAgICAgICAgaW5kZXhlZCA9ICEhaW5kZXhlZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IG9iai50eXBlO1xuICAgICAgICBsZXQgYXJyYXlNYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhBcnJheVR5cGUpO1xuICAgICAgICBpZiAoYXJyYXlNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgYXJyYXlMZW5ndGggPSBwYXJzZUludChhcnJheU1hdGNoWzJdIHx8IFwiLTFcIik7XG4gICAgICAgICAgICBjb25zdCBhcnJheUNoaWxkcmVuID0gUGFyYW1UeXBlLmZyb20oe1xuICAgICAgICAgICAgICAgIHR5cGU6IGFycmF5TWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogb2JqLmNvbXBvbmVudHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIFwiYXJyYXlcIiwgaW5kZXhlZCwgbnVsbCwgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcInR1cGxlXCIgfHwgdHlwZS5zdGFydHNXaXRoKFwidHVwbGUoXCIgLyogZml4OiApICovKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCIoXCIgLyogZml4OiApICovKSkge1xuICAgICAgICAgICAgY29uc3QgY29tcHMgPSAob2JqLmNvbXBvbmVudHMgIT0gbnVsbCkgPyBvYmouY29tcG9uZW50cy5tYXAoKGMpID0+IFBhcmFtVHlwZS5mcm9tKGMpKSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCB0dXBsZSA9IG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIFwidHVwbGVcIiwgaW5kZXhlZCwgY29tcHMsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgLy8gQFRPRE86IHVzZSBsZXhlciB0byB2YWxpZGF0ZSBhbmQgbm9ybWFsaXplIHR5cGVcbiAgICAgICAgICAgIHJldHVybiB0dXBsZTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlID0gdmVyaWZ5QmFzaWNUeXBlKG9iai50eXBlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2d1YXJkLCBuYW1lIHx8IFwiXCIsIHR5cGUsIHR5cGUsIGluZGV4ZWQsIG51bGwsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhICoqUGFyYW1UeXBlKiouXG4gICAgICovXG4gICAgc3RhdGljIGlzUGFyYW1UeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBQYXJhbVR5cGVJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQW4gYWJzdHJhY3QgY2xhc3MgdG8gcmVwcmVzZW50IEFuIGluZGl2aWR1YWwgZnJhZ21lbnQgZnJvbSBhIHBhcnNlIEFCSS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGUgb2YgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbnB1dHMgZm9yIHRoZSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBpbnB1dHM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHR5cGUsIGlucHV0cykge1xuICAgICAgICBhc3NlcnRQcml2YXRlKGd1YXJkLCBfZ3VhcmQsIFwiRnJhZ21lbnRcIik7XG4gICAgICAgIGlucHV0cyA9IE9iamVjdC5mcmVlemUoaW5wdXRzLnNsaWNlKCkpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgdHlwZSwgaW5wdXRzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZyYWdtZW50KiogZm9yICUlb2JqJSUsIHdpY2ggY2FuIGJlIGFueSBzdXBwb3J0ZWRcbiAgICAgKiAgQUJJIGZyZ2FtZW50IHR5cGUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIFRyeSBwYXJzaW5nIEpTT04uLi5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgRnJhZ21lbnQuZnJvbShKU09OLnBhcnNlKG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgLy8gLi4ub3RoZXJ3aXNlLCB1c2UgdGhlIGh1bWFuLXJlYWRhYmxlIGxleGVyXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICAvLyBIdW1hbi1yZWFkYWJsZSBBQkkgKGFscmVhZHkgbGV4ZWQpXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gb2JqLnBlZWtLZXl3b3JkKEt3VHlwZXMpO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6IHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjogcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOiByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlY2VpdmVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOiByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cnVjdFwiOiByZXR1cm4gU3RydWN0RnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gSlNPTiBBQklcbiAgICAgICAgICAgIHN3aXRjaCAob2JqLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjogcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6IHJldHVybiBFdmVudEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVjZWl2ZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFsbGJhY2tGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6IHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RydWN0XCI6IHJldHVybiBTdHJ1Y3RGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGB1bnN1cHBvcnRlZCB0eXBlOiAke29iai50eXBlfWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiRnJhZ21lbnQuZnJvbVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bnN1cHBvcnRlZCBmcmdhbWVudCBvYmplY3RcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSBbW0NvbnN0cnVjdG9yRnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNDb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYW4gW1tFcnJvckZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzRXJyb3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIFtbRXZlbnRGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0V2ZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbRnVuY3Rpb25GcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbU3RydWN0RnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNTdHJ1Y3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFN0cnVjdEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbn1cbi8qKlxuICogIEFuIGFic3RyYWN0IGNsYXNzIHRvIHJlcHJlc2VudCBBbiBpbmRpdmlkdWFsIGZyYWdtZW50XG4gKiAgd2hpY2ggaGFzIGEgbmFtZSBmcm9tIGEgcGFyc2UgQUJJLlxuICovXG5leHBvcnQgY2xhc3MgTmFtZWRGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIHR5cGUsIG5hbWUsIGlucHV0cykge1xuICAgICAgICBzdXBlcihndWFyZCwgdHlwZSwgaW5wdXRzKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiAmJiBuYW1lLm1hdGNoKHJlZ2V4SWQpLCBcImludmFsaWQgaWRlbnRpZmllclwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGlucHV0cyA9IE9iamVjdC5mcmVlemUoaW5wdXRzLnNsaWNlKCkpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbmFtZSB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBqb2luUGFyYW1zKGZvcm1hdCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIFwiKFwiICsgcGFyYW1zLm1hcCgocCkgPT4gcC5mb3JtYXQoZm9ybWF0KSkuam9pbigoZm9ybWF0ID09PSBcImZ1bGxcIikgPyBcIiwgXCIgOiBcIixcIikgKyBcIilcIjtcbn1cbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIC8vQ3VzdG9tIEVycm9yLy8uXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvckZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIGlucHV0cykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJlcnJvclwiLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEVycm9yRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBDdXN0b20gRXJyb3Igc2VsZWN0b3IuXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gaWQodGhpcy5mb3JtYXQoXCJzaWdoYXNoXCIpKS5zdWJzdHJpbmcoMCwgMTApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZyYWdtZW50IGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiZXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5uYW1lICsgam9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRXJyb3JGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRXJyb3JGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcImVycm9yXCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yRnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JGcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhblxuICAgICAqICAqKkVycm9yRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRXJyb3JGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYW4gRXZlbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudEZyYWdtZW50IGV4dGVuZHMgTmFtZWRGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFdoZXRoZXIgdGhpcyBldmVudCBpcyBhbm9ueW1vdXMuXG4gICAgICovXG4gICAgYW5vbnltb3VzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMsIGFub255bW91cykge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJldmVudFwiLCBuYW1lLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEV2ZW50RnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFub255bW91cyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBFdmVudCB0b3BpYyBoYXNoLlxuICAgICAqL1xuICAgIGdldCB0b3BpY0hhc2goKSB7XG4gICAgICAgIHJldHVybiBpZCh0aGlzLmZvcm1hdChcInNpZ2hhc2hcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGV2ZW50IGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICAgICAgICAgICAgICBhbm9ueW1vdXM6IHRoaXMuYW5vbnltb3VzLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaSkgPT4gSlNPTi5wYXJzZShpLmZvcm1hdChmb3JtYXQpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJldmVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm5hbWUgKyBqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpKTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIgJiYgdGhpcy5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiYW5vbnltb3VzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHRvcGljIGhhc2ggZm9yIGFuIGV2ZW50IHdpdGggJSVuYW1lJSUgYW5kICUlcGFyYW1zJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFRvcGljSGFzaChuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gKHBhcmFtcyB8fCBbXSkubWFwKChwKSA9PiBQYXJhbVR5cGUuZnJvbShwKSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gbmV3IEV2ZW50RnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBwYXJhbXMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipFdmVudEZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChFdmVudEZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBldmVudCBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uc3VtZU5hbWUoXCJldmVudFwiLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmosIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgYW5vbnltb3VzID0gISFjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wiYW5vbnltb3VzXCJdKSkuaGFzKFwiYW5vbnltb3VzXCIpO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudEZyYWdtZW50KF9ndWFyZCwgbmFtZSwgaW5wdXRzLCBhbm9ueW1vdXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXZlbnRGcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoKHApID0+IFBhcmFtVHlwZS5mcm9tKHAsIHRydWUpKSA6IFtdLCAhIW9iai5hbm9ueW1vdXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhblxuICAgICAqICAqKkV2ZW50RnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRXZlbnRGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBjb25zdHJ1Y3Rvci5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnN0cnVjdG9yRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIFdoZXRoZXIgdGhlIGNvbnN0cnVjdG9yIGNhbiByZWNlaXZlIGFuIGVuZG93bWVudC5cbiAgICAgKi9cbiAgICBwYXlhYmxlO1xuICAgIC8qKlxuICAgICAqICBUaGUgcmVjb21tZW5kZWQgZ2FzIGxpbWl0IGZvciBkZXBsb3ltZW50IG9yIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdhcztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdHlwZSwgaW5wdXRzLCBwYXlhYmxlLCBnYXMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIHR5cGUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogQ29uc3RydWN0b3JGcmFnbWVudEludGVybmFsIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgcGF5YWJsZSwgZ2FzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbnN0cnVjdG9yIGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBhc3NlcnQoZm9ybWF0ICE9IG51bGwgJiYgZm9ybWF0ICE9PSBcInNpZ2hhc2hcIiwgXCJjYW5ub3QgZm9ybWF0IGEgY29uc3RydWN0b3IgZm9yIHNpZ2hhc2hcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZm9ybWF0KHNpZ2hhc2gpXCIgfSk7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICh0aGlzLnBheWFibGUgPyBcInBheWFibGVcIiA6IFwidW5kZWZpbmVkXCIpLFxuICAgICAgICAgICAgICAgIHBheWFibGU6IHRoaXMucGF5YWJsZSxcbiAgICAgICAgICAgICAgICBnYXM6ICgodGhpcy5nYXMgIT0gbnVsbCkgPyB0aGlzLmdhcyA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGkpID0+IEpTT04ucGFyc2UoaS5mb3JtYXQoZm9ybWF0KSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbYGNvbnN0cnVjdG9yJHtqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpfWBdO1xuICAgICAgICBpZiAodGhpcy5wYXlhYmxlKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcInBheWFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGBAJHt0aGlzLmdhcy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqQ29uc3RydWN0b3JGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoQ29uc3RydWN0b3JGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgY29uc3R1Y3RvciBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wiY29uc3RydWN0b3JcIl0pKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWFibGUgPSAhIWNvbnN1bWVLZXl3b3JkcyhvYmosIEt3VmlzaWJEZXBsb3kpLmhhcyhcInBheWFibGVcIik7XG4gICAgICAgICAgICBjb25zdCBnYXMgPSBjb25zdW1lR2FzKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2d1YXJkLCBcImNvbnN0cnVjdG9yXCIsIGlucHV0cywgcGF5YWJsZSwgZ2FzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2d1YXJkLCBcImNvbnN0cnVjdG9yXCIsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSwgISFvYmoucGF5YWJsZSwgKG9iai5nYXMgIT0gbnVsbCkgPyBvYmouZ2FzIDogbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipDb25zdHJ1Y3RvckZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IENvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgbWV0aG9kLlxuICovXG5leHBvcnQgY2xhc3MgRmFsbGJhY2tGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIGZ1bmN0aW9uIGNhbiBiZSBzZW50IHZhbHVlIGR1cmluZyBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIGlucHV0cywgcGF5YWJsZSkge1xuICAgICAgICBzdXBlcihndWFyZCwgXCJmYWxsYmFja1wiLCBpbnB1dHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW50ZXJuYWwsIHsgdmFsdWU6IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IHBheWFibGUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZmFsbGJhY2sgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAoKHRoaXMuaW5wdXRzLmxlbmd0aCA9PT0gMCkgPyBcInJlY2VpdmVcIiA6IFwiZmFsbGJhY2tcIik7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZU11dGFiaWxpdHkgPSAodGhpcy5wYXlhYmxlID8gXCJwYXlhYmxlXCIgOiBcIm5vbnBheWFibGVcIik7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeyB0eXBlLCBzdGF0ZU11dGFiaWxpdHkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3R5cGV9KCkke3RoaXMucGF5YWJsZSA/IFwiIHBheWFibGVcIiA6IFwiXCJ9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipGYWxsYmFja0ZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChGYWxsYmFja0ZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGYWxsYmFja0ZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBmYWxsYmFjayBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck9iaiA9IG9iai50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgdG9wSXNWYWxpZCA9IG9iai5wZWVrS2V5d29yZChzZXRpZnkoW1wiZmFsbGJhY2tcIiwgXCJyZWNlaXZlXCJdKSk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh0b3BJc1ZhbGlkLCBcInR5cGUgbXVzdCBiZSBmYWxsYmFjayBvciByZWNlaXZlXCIsIFwib2JqXCIsIGVycm9yT2JqKTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBvYmoucG9wS2V5d29yZChzZXRpZnkoW1wiZmFsbGJhY2tcIiwgXCJyZWNlaXZlXCJdKSk7XG4gICAgICAgICAgICAvLyByZWNlaXZlKClcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcInJlY2VpdmVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpbnB1dHMubGVuZ3RoID09PSAwLCBgcmVjZWl2ZSBjYW5ub3QgaGF2ZSBhcmd1bWVudHNgLCBcIm9iai5pbnB1dHNcIiwgaW5wdXRzKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicGF5YWJsZVwiXSkpO1xuICAgICAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBbXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmYWxsYmFjaygpIFtwYXlhYmxlXVxuICAgICAgICAgICAgLy8gZmFsbGJhY2soYnl0ZXMpIFtwYXlhYmxlXSByZXR1cm5zIChieXRlcylcbiAgICAgICAgICAgIGxldCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlucHV0cy5sZW5ndGggPT09IDEgJiYgaW5wdXRzWzBdLnR5cGUgPT09IFwiYnl0ZXNcIiwgXCJpbnZhbGlkIGZhbGxiYWNrIGlucHV0c1wiLCBcIm9iai5pbnB1dHNcIiwgaW5wdXRzLm1hcCgoaSkgPT4gaS5mb3JtYXQoXCJtaW5pbWFsXCIpKS5qb2luKFwiLCBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXRzID0gW1BhcmFtVHlwZS5mcm9tKFwiYnl0ZXNcIildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbXV0YWJpbGl0eSA9IGNvbnN1bWVNdXRhYmlsaXR5KG9iaik7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChtdXRhYmlsaXR5ID09PSBcIm5vbnBheWFibGVcIiB8fCBtdXRhYmlsaXR5ID09PSBcInBheWFibGVcIiwgXCJmYWxsYmFjayBjYW5ub3QgYmUgY29uc3RhbnRzXCIsIFwib2JqLnN0YXRlTXV0YWJpbGl0eVwiLCBtdXRhYmlsaXR5KTtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicmV0dXJuc1wiXSkpLmhhcyhcInJldHVybnNcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KG91dHB1dHMubGVuZ3RoID09PSAxICYmIG91dHB1dHNbMF0udHlwZSA9PT0gXCJieXRlc1wiLCBcImludmFsaWQgZmFsbGJhY2sgb3V0cHV0c1wiLCBcIm9iai5vdXRwdXRzXCIsIG91dHB1dHMubWFwKChpKSA9PiBpLmZvcm1hdChcIm1pbmltYWxcIikpLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBpbnB1dHMsIG11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwicmVjZWl2ZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBbXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai50eXBlID09PSBcImZhbGxiYWNrXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IFtQYXJhbVR5cGUuZnJvbShcImJ5dGVzXCIpXTtcbiAgICAgICAgICAgIGNvbnN0IHBheWFibGUgPSAob2JqLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWxsYmFja0ZyYWdtZW50KF9ndWFyZCwgaW5wdXRzLCBwYXlhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJpbnZhbGlkIGZhbGxiYWNrIGRlc2NyaXB0aW9uXCIsIFwib2JqXCIsIG9iaik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipGYWxsYmFja0ZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgbWV0aG9kLlxuICovXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25GcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgZnVuY3Rpb24gaXMgY29uc3RhbnQgKGUuZy4gYGBwdXJlYGAgb3IgYGB2aWV3YGAgZnVuY3Rpb25zKS5cbiAgICAgKi9cbiAgICBjb25zdGFudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJldHVybmVkIHR5cGVzIGZvciB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBvdXRwdXRzO1xuICAgIC8qKlxuICAgICAqICBUaGUgc3RhdGUgbXV0YWJpbGl0eSAoZS5nLiBgYHBheWFibGVgYCwgYGBub25wYXlhYmxlYGAsIGBgdmlld2BgXG4gICAgICogIG9yIGBgcHVyZWBgKVxuICAgICAqL1xuICAgIHN0YXRlTXV0YWJpbGl0eTtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIGZ1bmN0aW9uIGNhbiBiZSBzZW50IHZhbHVlIGR1cmluZyBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNvbW1lbmRlZCBnYXMgbGltaXQgdG8gc2VuZCB3aGVuIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBnYXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIHN0YXRlTXV0YWJpbGl0eSwgaW5wdXRzLCBvdXRwdXRzLCBnYXMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZnVuY3Rpb25cIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgIG91dHB1dHMgPSBPYmplY3QuZnJlZXplKG91dHB1dHMuc2xpY2UoKSk7XG4gICAgICAgIGNvbnN0IGNvbnN0YW50ID0gKHN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgc3RhdGVNdXRhYmlsaXR5ID09PSBcInB1cmVcIik7XG4gICAgICAgIGNvbnN0IHBheWFibGUgPSAoc3RhdGVNdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBjb25zdGFudCwgZ2FzLCBvdXRwdXRzLCBwYXlhYmxlLCBzdGF0ZU11dGFiaWxpdHkgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgRnVuY3Rpb24gc2VsZWN0b3IuXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gaWQodGhpcy5mb3JtYXQoXCJzaWdoYXNoXCIpKS5zdWJzdHJpbmcoMCwgMTApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwic2lnaGFzaFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgY29uc3RhbnQ6IHRoaXMuY29uc3RhbnQsXG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAoKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikgPyB0aGlzLnN0YXRlTXV0YWJpbGl0eSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgcGF5YWJsZTogdGhpcy5wYXlhYmxlLFxuICAgICAgICAgICAgICAgIGdhczogKCh0aGlzLmdhcyAhPSBudWxsKSA/IHRoaXMuZ2FzIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaSkgPT4gSlNPTi5wYXJzZShpLmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLm1hcCgobykgPT4gSlNPTi5wYXJzZShvLmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5uYW1lICsgam9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKSk7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5zdGF0ZU11dGFiaWxpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0cyAmJiB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJyZXR1cm5zXCIpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGpvaW5QYXJhbXMoZm9ybWF0LCB0aGlzLm91dHB1dHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYEAke3RoaXMuZ2FzLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgc2VsZWN0b3IgZm9yIGEgZnVuY3Rpb24gd2l0aCAlJW5hbWUlJSBhbmQgJSVwYXJhbXMlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2VsZWN0b3IobmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IChwYXJhbXMgfHwgW10pLm1hcCgocCkgPT4gUGFyYW1UeXBlLmZyb20ocCkpO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IG5ldyBGdW5jdGlvbkZyYWdtZW50KF9ndWFyZCwgbmFtZSwgXCJ2aWV3XCIsIHBhcmFtcywgW10sIG51bGwpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQuc2VsZWN0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRnVuY3Rpb25GcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRnVuY3Rpb25GcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgZnVuY3Rpb24gZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwiZnVuY3Rpb25cIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IG11dGFiaWxpdHkgPSBjb25zdW1lTXV0YWJpbGl0eShvYmopO1xuICAgICAgICAgICAgbGV0IG91dHB1dHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicmV0dXJuc1wiXSkpLmhhcyhcInJldHVybnNcIikpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ2FzID0gY29uc3VtZUdhcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkZyYWdtZW50KF9ndWFyZCwgbmFtZSwgbXV0YWJpbGl0eSwgaW5wdXRzLCBvdXRwdXRzLCBnYXMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZU11dGFiaWxpdHkgPSBvYmouc3RhdGVNdXRhYmlsaXR5O1xuICAgICAgICAvLyBVc2UgbGVnYWN5IFNvbGlkaXR5IEFCSSBsb2dpYyBpZiBzdGF0ZU11dGFiaWxpdHkgaXMgbWlzc2luZ1xuICAgICAgICBpZiAoc3RhdGVNdXRhYmlsaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwicGF5YWJsZVwiO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAob2JqLmNvbnN0YW50KSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInZpZXdcIjtcbiAgICAgICAgICAgICAgICBpZiAoIW9iai5jb25zdGFudCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInBheWFibGVcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAob2JqLnBheWFibGUpID09PSBcImJvb2xlYW5cIiAmJiAhb2JqLnBheWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIChvYmoucGF5YWJsZSkgPT09IFwiYm9vbGVhblwiICYmICFvYmoucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiB2ZXJpZnlTdGF0ZSBmb3Igc3RhdGVNdXRhYmlsaXR5IChlLmcuIHRocm93IGlmXG4gICAgICAgIC8vICAgICAgICBwYXlhYmxlOiBmYWxzZSBidXQgc3RhdGVNdXRhYmlsaXR5IGlzIFwibm9ucGF5YWJsZVwiKVxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgc3RhdGVNdXRhYmlsaXR5LCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sIG9iai5vdXRwdXRzID8gb2JqLm91dHB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdLCAob2JqLmdhcyAhPSBudWxsKSA/IG9iai5nYXMgOiBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxuICAgICAqICAqKkZ1bmN0aW9uRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRnVuY3Rpb25GcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBzdHJ1Y3R1cmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJ1Y3RGcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwic3RydWN0XCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogU3RydWN0RnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzdHJ1Y3QgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKlN0cnVjdEZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBzdHJ1Y3QgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwic3RydWN0XCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cnVjdEZyYWdtZW50KF9ndWFyZCwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFN0cnVjdEZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBmaXggdGhpcyByZXR1cm4gdHlwZVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipTdHJ1Y3RGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBTdHJ1Y3RGcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcmFnbWVudHMuanMubWFwIl0sIm5hbWVzIjpbImRlZmluZVByb3BlcnRpZXMiLCJnZXRCaWdJbnQiLCJnZXROdW1iZXIiLCJhc3NlcnQiLCJhc3NlcnRQcml2YXRlIiwiYXNzZXJ0QXJndW1lbnQiLCJpZCIsInNldGlmeSIsIml0ZW1zIiwicmVzdWx0IiwiU2V0IiwiZm9yRWFjaCIsImsiLCJhZGQiLCJPYmplY3QiLCJmcmVlemUiLCJfa3dWaXNpYkRlcGxveSIsIkt3VmlzaWJEZXBsb3kiLCJzcGxpdCIsIl9rd1Zpc2liIiwiS3dWaXNpYiIsIl9rd1R5cGVzIiwiS3dUeXBlcyIsIl9rd01vZGlmaWVycyIsIkt3TW9kaWZpZXJzIiwiX2t3T3RoZXIiLCJfa2V5d29yZHMiLCJqb2luIiwiS2V5d29yZHMiLCJTaW1wbGVUb2tlbnMiLCJyZWdleFdoaXRlc3BhY2VQcmVmaXgiLCJSZWdFeHAiLCJyZWdleE51bWJlclByZWZpeCIsInJlZ2V4SWRQcmVmaXgiLCJyZWdleElkIiwicmVnZXhUeXBlIiwiVG9rZW5TdHJpbmciLCJvZmZzZXQiLCJ0b2tlbnMiLCJsZW5ndGgiLCJjb25zdHJ1Y3RvciIsInNsaWNlIiwiY2xvbmUiLCJyZXNldCIsInN1YlRva2VuU3RyaW5nIiwiZnJvbSIsInRvIiwibWFwIiwidCIsImFzc2lnbiIsIm1hdGNoIiwibGlua0JhY2siLCJsaW5rTmV4dCIsInBvcEtleXdvcmQiLCJhbGxvd2VkIiwidG9wIiwicGVlayIsInR5cGUiLCJoYXMiLCJ0ZXh0IiwiRXJyb3IiLCJwb3AiLCJwb3BUeXBlIiwiSlNPTiIsInN0cmluZ2lmeSIsInBvcFBhcmVuIiwicG9wUGFyYW1zIiwibGluayIsInB1c2giLCJwZWVrS2V5d29yZCIsInBlZWtUeXBlIiwidG9TdHJpbmciLCJpIiwidG9rZW4iLCJsZXgiLCJ0aHJvd0Vycm9yIiwibWVzc2FnZSIsImJyYWNrZXRzIiwiY29tbWFzIiwiY3VyIiwic3Vic3RyaW5nIiwiZGVwdGgiLCJ2YWx1ZSIsInN1ZmZpeCIsImFsbG93U2luZ2xlIiwic2V0IiwiaW5jbHVkZWQiLCJrZXkiLCJrZXlzIiwiY29uc3VtZU5hbWUiLCJrZXl3b3JkIiwiY29uc3VtZUtleXdvcmRzIiwia2V5d29yZHMiLCJjb25zdW1lTXV0YWJpbGl0eSIsIm1vZGlmaWVycyIsImNvbnN1bWVQYXJhbXMiLCJhbGxvd0luZGV4ZWQiLCJQYXJhbVR5cGUiLCJjb25zdW1lR2FzIiwiY29uc3VtZUVvaSIsInJlZ2V4QXJyYXlUeXBlIiwidmVyaWZ5QmFzaWNUeXBlIiwicGFyc2VJbnQiLCJzaXplIiwiX2d1YXJkIiwiaW50ZXJuYWwiLCJTeW1ib2wiLCJmb3IiLCJQYXJhbVR5cGVJbnRlcm5hbCIsIkVycm9yRnJhZ21lbnRJbnRlcm5hbCIsIkV2ZW50RnJhZ21lbnRJbnRlcm5hbCIsIkNvbnN0cnVjdG9yRnJhZ21lbnRJbnRlcm5hbCIsIkZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCIsIkZ1bmN0aW9uRnJhZ21lbnRJbnRlcm5hbCIsIlN0cnVjdEZyYWdtZW50SW50ZXJuYWwiLCJndWFyZCIsIm5hbWUiLCJiYXNlVHlwZSIsImluZGV4ZWQiLCJjb21wb25lbnRzIiwiYXJyYXlMZW5ndGgiLCJhcnJheUNoaWxkcmVuIiwiZGVmaW5lUHJvcGVydHkiLCJmb3JtYXQiLCJpc0FycmF5IiwicGFyc2UiLCJTdHJpbmciLCJpc1R1cGxlIiwiYyIsImNvbXAiLCJpc0luZGV4YWJsZSIsIndhbGsiLCJwcm9jZXNzIiwiQXJyYXkiLCJfdGhpcyIsInYiLCJ3YWxrQXN5bmMiLCJwcm9taXNlcyIsInNldFZhbHVlIiwiY2hpbGRUeXBlIiwiaW5kZXgiLCJwYXJhbSIsInRoZW4iLCJQcm9taXNlIiwiYWxsIiwib2JqIiwiaXNQYXJhbVR5cGUiLCJlcnJvciIsImNvbXBzIiwiYnJhY2tldCIsImFycmF5TWF0Y2giLCJzdGFydHNXaXRoIiwidHVwbGUiLCJGcmFnbWVudCIsImlucHV0cyIsImUiLCJDb25zdHJ1Y3RvckZyYWdtZW50IiwiRXJyb3JGcmFnbWVudCIsIkV2ZW50RnJhZ21lbnQiLCJGYWxsYmFja0ZyYWdtZW50IiwiRnVuY3Rpb25GcmFnbWVudCIsIlN0cnVjdEZyYWdtZW50Iiwib3BlcmF0aW9uIiwiaXNDb25zdHJ1Y3RvciIsImlzRnJhZ21lbnQiLCJpc0Vycm9yIiwiaXNFdmVudCIsImlzRnVuY3Rpb24iLCJpc1N0cnVjdCIsIk5hbWVkRnJhZ21lbnQiLCJqb2luUGFyYW1zIiwicGFyYW1zIiwicCIsInNlbGVjdG9yIiwiaW5wdXQiLCJhbm9ueW1vdXMiLCJ0b3BpY0hhc2giLCJnZXRUb3BpY0hhc2giLCJmcmFnbWVudCIsInBheWFibGUiLCJnYXMiLCJzdGF0ZU11dGFiaWxpdHkiLCJ1bmRlZmluZWQiLCJlcnJvck9iaiIsInRvcElzVmFsaWQiLCJtdXRhYmlsaXR5Iiwib3V0cHV0cyIsImNvbnN0YW50IiwibyIsImdldFNlbGVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/fragments.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/interface.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/interface.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorDescription: () => (/* binding */ ErrorDescription),\n/* harmony export */   Indexed: () => (/* binding */ Indexed),\n/* harmony export */   Interface: () => (/* binding */ Interface),\n/* harmony export */   LogDescription: () => (/* binding */ LogDescription),\n/* harmony export */   Result: () => (/* reexport safe */ _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Result),\n/* harmony export */   TransactionDescription: () => (/* binding */ TransactionDescription),\n/* harmony export */   checkResultErrors: () => (/* reexport safe */ _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.checkResultErrors)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _hash_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../hash/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/hash/id.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _abi_coder_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abi-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/abi-coder.js\");\n/* harmony import */ var _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/coders/abstract-coder.js\");\n/* harmony import */ var _fragments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fragments.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/fragments.js\");\n/* harmony import */ var _typed_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./typed.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/**\n *  The Interface class is a low-level class that accepts an\n *  ABI and provides all the necessary functionality to encode\n *  and decode paramaters to and results from methods, events\n *  and errors.\n *\n *  It also provides several convenience methods to automatically\n *  search and find matching transactions and events to parse them.\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */ \n\n\n\n\n\n\n\n/**\n *  When using the [[Interface-parseLog]] to automatically match a Log to its event\n *  for parsing, a **LogDescription** is returned.\n */ class LogDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, topic, args){\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment,\n            name,\n            signature,\n            topic,\n            args\n        });\n    }\n}\n/**\n *  When using the [[Interface-parseTransaction]] to automatically match\n *  a transaction data to its function for parsing,\n *  a **TransactionDescription** is returned.\n */ class TransactionDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, selector, args, value){\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment,\n            name,\n            args,\n            signature,\n            selector,\n            value\n        });\n    }\n}\n/**\n *  When using the [[Interface-parseError]] to automatically match an\n *  error for a call result for parsing, an **ErrorDescription** is returned.\n */ class ErrorDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, selector, args){\n        const name = fragment.name, signature = fragment.format();\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragment,\n            name,\n            args,\n            signature,\n            selector\n        });\n    }\n}\n/**\n *  An **Indexed** is used as a value when a value that does not\n *  fit within a topic (i.e. not a fixed-length, 32-byte type). It\n *  is the ``keccak256`` of the value, and used for types such as\n *  arrays, tuples, bytes and strings.\n */ class Indexed {\n    /**\n     *  Returns ``true`` if %%value%% is an **Indexed**.\n     *\n     *  This provides a Type Guard for property access.\n     */ static isIndexed(value) {\n        return !!(value && value._isIndexed);\n    }\n    /**\n     *  @_ignore:\n     */ constructor(hash){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            hash,\n            _isIndexed: true\n        });\n    }\n}\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nconst PanicReasons = {\n    \"0\": \"generic panic\",\n    \"1\": \"assert(false)\",\n    \"17\": \"arithmetic overflow\",\n    \"18\": \"division or modulo by zero\",\n    \"33\": \"enum overflow\",\n    \"34\": \"invalid encoded storage byte array accessed\",\n    \"49\": \"out-of-bounds array access; popping on an empty array\",\n    \"50\": \"out-of-bounds access of an array or bytesN\",\n    \"65\": \"out of memory\",\n    \"81\": \"uninitialized function\"\n};\nconst BuiltinErrors = {\n    \"0x08c379a0\": {\n        signature: \"Error(string)\",\n        name: \"Error\",\n        inputs: [\n            \"string\"\n        ],\n        reason: (message)=>{\n            return `reverted with reason string ${JSON.stringify(message)}`;\n        }\n    },\n    \"0x4e487b71\": {\n        signature: \"Panic(uint256)\",\n        name: \"Panic\",\n        inputs: [\n            \"uint256\"\n        ],\n        reason: (code)=>{\n            let reason = \"unknown panic code\";\n            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n                reason = PanicReasons[code.toString()];\n            }\n            return `reverted with panic code 0x${code.toString(16)} (${reason})`;\n        }\n    }\n};\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */ class Interface {\n    #errors;\n    #events;\n    #functions;\n    //    #structs: Map<string, StructFragment>;\n    #abiCoder;\n    /**\n     *  Create a new Interface for the %%fragments%%.\n     */ constructor(fragments){\n        let abi = [];\n        if (typeof fragments === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n        this.#functions = new Map();\n        this.#errors = new Map();\n        this.#events = new Map();\n        //        this.#structs = new Map();\n        const frags = [];\n        for (const a of abi){\n            try {\n                frags.push(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(a));\n            } catch (error) {\n                console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, error.message);\n            }\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fragments: Object.freeze(frags)\n        });\n        let fallback = null;\n        let receive = false;\n        this.#abiCoder = this.getAbiCoder();\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment, index)=>{\n            let bucket;\n            switch(fragment.type){\n                case \"constructor\":\n                    if (this.deploy) {\n                        console.log(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n                        deploy: fragment\n                    });\n                    return;\n                case \"fallback\":\n                    if (fragment.inputs.length === 0) {\n                        receive = true;\n                    } else {\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(!fallback || fragment.payable !== fallback.payable, \"conflicting fallback fragments\", `fragments[${index}]`, fragment);\n                        fallback = fragment;\n                        receive = fallback.payable;\n                    }\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.#functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.#events;\n                    break;\n                case \"error\":\n                    bucket = this.#errors;\n                    break;\n                default:\n                    return;\n            }\n            // Two identical entries; ignore it\n            const signature = fragment.format();\n            if (bucket.has(signature)) {\n                return;\n            }\n            bucket.set(signature, fragment);\n        });\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n                deploy: _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ConstructorFragment.from(\"constructor()\")\n            });\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            fallback,\n            receive\n        });\n    }\n    /**\n     *  Returns the entire Human-Readable ABI, as an array of\n     *  signatures, optionally as %%minimal%% strings, which\n     *  removes parameter names and unneceesary spaces.\n     */ format(minimal) {\n        const format = minimal ? \"minimal\" : \"full\";\n        const abi = this.fragments.map((f)=>f.format(format));\n        return abi;\n    }\n    /**\n     *  Return the JSON-encoded ABI. This is the format Solidiy\n     *  returns.\n     */ formatJson() {\n        const abi = this.fragments.map((f)=>f.format(\"json\"));\n        // We need to re-bundle the JSON fragments a bit\n        return JSON.stringify(abi.map((j)=>JSON.parse(j)));\n    }\n    /**\n     *  The ABI coder that will be used to encode and decode binary\n     *  data.\n     */ getAbiCoder() {\n        return _abi_coder_js__WEBPACK_IMPORTED_MODULE_4__.AbiCoder.defaultAbiCoder();\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    #getFunction(key, values, forceUnique) {\n        // Selector\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(key)) {\n            const selector = key.toLowerCase();\n            for (const fragment of this.#functions.values()){\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#functions){\n                if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                const lastValue = values.length > 0 ? values[values.length - 1] : null;\n                let valueLength = values.length;\n                let allowOptions = true;\n                if (_typed_js__WEBPACK_IMPORTED_MODULE_6__.Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n                    allowOptions = false;\n                    valueLength--;\n                }\n                // Remove all matches that don't have a compatible length. The args\n                // may contain an overrides, so the match may have n or n - 1 parameters\n                for(let i = matching.length - 1; i >= 0; i--){\n                    const inputs = matching[i].inputs.length;\n                    if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for(let i = matching.length - 1; i >= 0; i--){\n                    const inputs = matching[i].inputs;\n                    for(let j = 0; j < values.length; j++){\n                        // Not a typed value\n                        if (!_typed_js__WEBPACK_IMPORTED_MODULE_6__.Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // We are past the inputs\n                        if (j >= inputs.length) {\n                            if (values[j].type === \"overrides\") {\n                                continue;\n                            }\n                            matching.splice(i, 1);\n                            break;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            // We found a single matching signature with an overrides, but the\n            // last value is something that cannot possibly be an options\n            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n                const lastArg = values[values.length - 1];\n                if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== \"object\") {\n                    matching.splice(0, 1);\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `ambiguous function description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#functions.get(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.FunctionFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the function name for %%key%%, which may be a function selector,\n     *  function name or function signature that belongs to the ABI.\n     */ getFunctionName(key) {\n        const fragment = this.#getFunction(key, null, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"no matching function\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (a function selector, function name or\n     *  function signature) is present in the ABI.\n     *\n     *  In the case of a function name, the name may be ambiguous, so\n     *  accessing the [[FunctionFragment]] may require refinement.\n     */ hasFunction(key) {\n        return !!this.#getFunction(key, null, false);\n    }\n    /**\n     *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n     *  selector, function name or function signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple functions match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single function in\n     *  the ABI, this will throw.\n     */ getFunction(key, values) {\n        return this.#getFunction(key, values || null, true);\n    }\n    /**\n     *  Iterate over all functions, calling %%callback%%, sorted by their name.\n     */ forEachFunction(callback) {\n        const names = Array.from(this.#functions.keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback(this.#functions.get(name), i);\n        }\n    }\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    #getEvent(key, values, forceUnique) {\n        // EventTopic\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(key)) {\n            const eventTopic = key.toLowerCase();\n            for (const fragment of this.#events.values()){\n                if (eventTopic === fragment.topicHash) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#events){\n                if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                // Remove all matches that don't have a compatible length.\n                for(let i = matching.length - 1; i >= 0; i--){\n                    if (matching[i].inputs.length < values.length) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for(let i = matching.length - 1; i >= 0; i--){\n                    const inputs = matching[i].inputs;\n                    for(let j = 0; j < values.length; j++){\n                        // Not a typed value\n                        if (!_typed_js__WEBPACK_IMPORTED_MODULE_6__.Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `ambiguous event description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#events.get(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.EventFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the event name for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     */ getEventName(key) {\n        const fragment = this.#getEvent(key, null, false);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"no matching event\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (an event topic hash, event name or\n     *  event signature) is present in the ABI.\n     *\n     *  In the case of an event name, the name may be ambiguous, so\n     *  accessing the [[EventFragment]] may require refinement.\n     */ hasEvent(key) {\n        return !!this.#getEvent(key, null, false);\n    }\n    /**\n     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple events match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single event in\n     *  the ABI, this will throw.\n     */ getEvent(key, values) {\n        return this.#getEvent(key, values || null, true);\n    }\n    /**\n     *  Iterate over all events, calling %%callback%%, sorted by their name.\n     */ forEachEvent(callback) {\n        const names = Array.from(this.#events.keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback(this.#events.get(name), i);\n        }\n    }\n    /**\n     *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n     *  selector, error name or error signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple errors match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single error in\n     *  the ABI, this will throw.\n     */ getError(key, values) {\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(key)) {\n            const selector = key.toLowerCase();\n            if (BuiltinErrors[selector]) {\n                return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(BuiltinErrors[selector].signature);\n            }\n            for (const fragment of this.#errors.values()){\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#errors){\n                if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (matching.length === 0) {\n                if (key === \"Error\") {\n                    return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Error(string)\");\n                }\n                if (key === \"Panic\") {\n                    return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Panic(uint256)\");\n                }\n                return null;\n            } else if (matching.length > 1) {\n                const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, `ambiguous error description (i.e. ${matchStr})`, \"name\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        key = _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(key).format();\n        if (key === \"Error(string)\") {\n            return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Error(string)\");\n        }\n        if (key === \"Panic(uint256)\") {\n            return _fragments_js__WEBPACK_IMPORTED_MODULE_2__.ErrorFragment.from(\"error Panic(uint256)\");\n        }\n        const result = this.#errors.get(key);\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Iterate over all errors, calling %%callback%%, sorted by their name.\n     */ forEachError(callback) {\n        const names = Array.from(this.#errors.keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback(this.#errors.get(name), i);\n        }\n    }\n    // Get the 4-byte selector used by Solidity to identify a function\n    /*\ngetSelector(fragment: ErrorFragment | FunctionFragment): string {\n    if (typeof(fragment) === \"string\") {\n        const matches: Array<Fragment> = [ ];\n\n        try { matches.push(this.getFunction(fragment)); } catch (error) { }\n        try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n\n        if (matches.length === 0) {\n            logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n        } else if (matches.length > 1) {\n            logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n        }\n\n        fragment = matches[0];\n    }\n\n    return dataSlice(id(fragment.format()), 0, 4);\n}\n    */ // Get the 32-byte topic hash used by Solidity to identify an event\n    /*\n    getEventTopic(fragment: EventFragment): string {\n        //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n        return id(fragment.format());\n    }\n    */ _decodeParams(params, data) {\n        return this.#abiCoder.decode(params, data);\n    }\n    _encodeParams(params, values) {\n        return this.#abiCoder.encode(params, values);\n    }\n    /**\n     *  Encodes a ``tx.data`` object for deploying the Contract with\n     *  the %%values%% as the constructor arguments.\n     */ encodeDeploy(values) {\n        return this._encodeParams(this.deploy.inputs, values || []);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified error (see [[getError]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */ decodeErrorResult(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getError(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the transaction revert data for a call result that\n     *  reverted from the the Contract with the sepcified %%error%%\n     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */ encodeErrorResult(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getError(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the %%data%% from a transaction ``tx.data`` for\n     *  the function specified (see [[getFunction]] for valid values\n     *  for %%fragment%%).\n     *\n     *  Most developers should prefer the [[parseTransaction]] method\n     *  instead, which will automatically detect the fragment.\n     */ decodeFunctionData(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the ``tx.data`` for a transaction that calls the function\n     *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n     *  the %%values%%.\n     */ encodeFunctionData(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */ decodeFunctionResult(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        let message = \"invalid length for result data\";\n        const bytes = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytesCopy)(data);\n        if (bytes.length % 32 === 0) {\n            try {\n                return this.#abiCoder.decode(fragment.outputs, bytes);\n            } catch (error) {\n                message = \"could not decode result data\";\n            }\n        }\n        // Call returned data with no error, but the data is junk\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(false, message, \"BAD_DATA\", {\n            value: (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(bytes),\n            info: {\n                method: fragment.name,\n                signature: fragment.format()\n            }\n        });\n    }\n    makeError(_data, tx) {\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytes)(_data, \"data\");\n        const error = _abi_coder_js__WEBPACK_IMPORTED_MODULE_4__.AbiCoder.getBuiltinCallException(\"call\", tx, data);\n        // Not a built-in error; try finding a custom error\n        const customPrefix = \"execution reverted (unknown custom error)\";\n        if (error.message.startsWith(customPrefix)) {\n            const selector = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data.slice(0, 4));\n            const ef = this.getError(selector);\n            if (ef) {\n                try {\n                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4));\n                    error.revert = {\n                        name: ef.name,\n                        signature: ef.format(),\n                        args\n                    };\n                    error.reason = error.revert.signature;\n                    error.message = `execution reverted: ${error.reason}`;\n                } catch (e) {\n                    error.message = `execution reverted (coult not decode custom error)`;\n                }\n            }\n        }\n        // Add the invocation, if available\n        const parsed = this.parseTransaction(tx);\n        if (parsed) {\n            error.invocation = {\n                method: parsed.name,\n                signature: parsed.signature,\n                args: parsed.args\n            };\n        }\n        return error;\n    }\n    /**\n     *  Encodes the result data (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values\n     *  for %%fragment%%) with %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */ encodeFunctionResult(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(this.#abiCoder.encode(fragment.outputs, values || []));\n    }\n    /*\n        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n            const promises: Array<Promise<>> = [ ];\n            const process = function(type: ParamType, value: any): any {\n                if (type.baseType === \"array\") {\n                    return descend(type.child\n                }\n                if (type. === \"address\") {\n                }\n            };\n    \n            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n                if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n                \n            };\n    \n            const result: Array<any> = [ ];\n            values.forEach((value, index) => {\n                if (value == null) {\n                    topics.push(null);\n                } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                    logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n                } else if (Array.isArray(value)) {\n                    topics.push(value.map((value) => encodeTopic(param, value)));\n                } else {\n                    topics.push(encodeTopic(param, value));\n                }\n            });\n        }\n    */ // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, \"UNEXPECTED_ARGUMENT\", {\n            count: values.length,\n            expectedCount: fragment.inputs.length\n        });\n        const topics = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        // @TODO: Use the coders for this; to properly support tuples, etc.\n        const encodeTopic = (param, value)=>{\n            if (param.type === \"string\") {\n                return (0,_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.id)(value);\n            } else if (param.type === \"bytes\") {\n                return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_8__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(value));\n            }\n            if (param.type === \"bool\" && typeof value === \"boolean\") {\n                value = value ? \"0x01\" : \"0x00\";\n            } else if (param.type.match(/^u?int/)) {\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.toBeHex)(value); // @TODO: Should this toTwos??\n            } else if (param.type.match(/^bytes/)) {\n                value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadBytes)(value, 32);\n            } else if (param.type === \"address\") {\n                // Check addresses are valid\n                this.#abiCoder.encode([\n                    \"address\"\n                ], [\n                    value\n                ]);\n            }\n            return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.zeroPadValue)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(value), 32);\n        };\n        values.forEach((value, index)=>{\n            const param = fragment.inputs[index];\n            if (!param.indexed) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(value == null, \"cannot filter non-indexed parameters; must be null\", \"contract.\" + param.name, value);\n                return;\n            }\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"filtering with tuples or arrays not supported\", \"contract.\" + param.name, value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value)=>encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n        // Trim off trailing nulls\n        while(topics.length && topics[topics.length - 1] === null){\n            topics.pop();\n        }\n        return topics;\n    }\n    encodeEventLog(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        const topics = [];\n        const dataTypes = [];\n        const dataValues = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(values.length === fragment.inputs.length, \"event arguments/values mismatch\", \"values\", values);\n        fragment.inputs.forEach((param, index)=>{\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push((0,_hash_index_js__WEBPACK_IMPORTED_MODULE_7__.id)(value));\n                } else if (param.type === \"bytes\") {\n                    topics.push((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_8__.keccak256)(value));\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this.#abiCoder.encode([\n                        param.type\n                    ], [\n                        value\n                    ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n        return {\n            data: this.#abiCoder.encode(dataTypes, dataValues),\n            topics: topics\n        };\n    }\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(fragment, data, topics) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        if (topics != null && !fragment.anonymous) {\n            const eventTopic = fragment.topicHash;\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.isHexString)(topics[0], 32) && topics[0].toLowerCase() === eventTopic, \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n            topics = topics.slice(1);\n        }\n        const indexed = [];\n        const nonIndexed = [];\n        const dynamic = [];\n        fragment.inputs.forEach((param, index)=>{\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(_fragments_js__WEBPACK_IMPORTED_MODULE_2__.ParamType.from({\n                        type: \"bytes32\",\n                        name: param.name\n                    }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n        const resultIndexed = topics != null ? this.#abiCoder.decode(indexed, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.concat)(topics)) : null;\n        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);\n        //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n        const values = [];\n        const keys = [];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        fragment.inputs.forEach((param, index)=>{\n            let value = null;\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    value = new Indexed(null);\n                } else if (dynamic[index]) {\n                    value = new Indexed(resultIndexed[indexedIndex++]);\n                } else {\n                    try {\n                        value = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        value = error;\n                    }\n                }\n            } else {\n                try {\n                    value = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    value = error;\n                }\n            }\n            values.push(value);\n            keys.push(param.name || null);\n        });\n        return _coders_abstract_coder_js__WEBPACK_IMPORTED_MODULE_0__.Result.fromItems(values, keys);\n    }\n    /**\n     *  Parses a transaction, finding the matching function and extracts\n     *  the parameter values along with other useful function details.\n     *\n     *  If the matching function cannot be found, return null.\n     */ parseTransaction(tx) {\n        const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBytes)(tx.data, \"tx.data\");\n        const value = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_9__.getBigInt)(tx.value != null ? tx.value : 0, \"tx.value\");\n        const fragment = this.getFunction((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data.slice(0, 4)));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));\n        return new TransactionDescription(fragment, fragment.selector, args, value);\n    }\n    parseCallResult(data) {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Parses a receipt log, finding the matching event and extracts\n     *  the parameter values along with other useful event details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */ parseLog(log) {\n        const fragment = this.getEvent(log.topics[0]);\n        if (!fragment || fragment.anonymous) {\n            return null;\n        }\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n        return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n    }\n    /**\n     *  Parses a revert data, finding the matching error and extracts\n     *  the parameter values along with other useful error details.\n     *\n     *  If the matching error cannot be found, returns null.\n     */ parseError(data) {\n        const hexData = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.hexlify)(data);\n        const fragment = this.getError((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(hexData, 0, 4));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.dataSlice)(hexData, 4));\n        return new ErrorDescription(fragment, fragment.selector, args);\n    }\n    /**\n     *  Creates a new [[Interface]] from the ABI %%value%%.\n     *\n     *  The %%value%% may be provided as an existing [[Interface]] object,\n     *  a JSON-encoded ABI or any Human-Readable ABI format.\n     */ static from(value) {\n        // Already an Interface, which is immutable\n        if (value instanceof Interface) {\n            return value;\n        }\n        // JSON\n        if (typeof value === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        // An Interface; possibly from another v6 instance\n        if (typeof value.formatJson === \"function\") {\n            return new Interface(value.formatJson());\n        }\n        // A legacy Interface; from an older version\n        if (typeof value.format === \"function\") {\n            return new Interface(value.format(\"json\"));\n        }\n        // Array of fragments\n        return new Interface(value);\n    }\n} //# sourceMappingURL=interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ludGVyZmFjZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7O0NBVUMsR0FDOEM7QUFDVDtBQUN3SjtBQUNwSjtBQUM2QjtBQUNtRDtBQUN2RjtBQUNFO0FBQ3JDOzs7Q0FHQyxHQUNNLE1BQU15QjtJQXFCVDs7S0FFQyxHQUNEQyxZQUFZQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxDQUFFO1FBQy9CLE1BQU1DLE9BQU9ILFNBQVNHLElBQUksRUFBRUMsWUFBWUosU0FBU0ssTUFBTTtRQUN2RHJCLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFDbkJnQjtZQUFVRztZQUFNQztZQUFXSDtZQUFPQztRQUN0QztJQUNKO0FBQ0o7QUFDQTs7OztDQUlDLEdBQ00sTUFBTUk7SUF5QlQ7O0tBRUMsR0FDRFAsWUFBWUMsUUFBUSxFQUFFTyxRQUFRLEVBQUVMLElBQUksRUFBRU0sS0FBSyxDQUFFO1FBQ3pDLE1BQU1MLE9BQU9ILFNBQVNHLElBQUksRUFBRUMsWUFBWUosU0FBU0ssTUFBTTtRQUN2RHJCLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFDbkJnQjtZQUFVRztZQUFNRDtZQUFNRTtZQUFXRztZQUFVQztRQUMvQztJQUNKO0FBQ0o7QUFDQTs7O0NBR0MsR0FDTSxNQUFNQztJQXFCVDs7S0FFQyxHQUNEVixZQUFZQyxRQUFRLEVBQUVPLFFBQVEsRUFBRUwsSUFBSSxDQUFFO1FBQ2xDLE1BQU1DLE9BQU9ILFNBQVNHLElBQUksRUFBRUMsWUFBWUosU0FBU0ssTUFBTTtRQUN2RHJCLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFDbkJnQjtZQUFVRztZQUFNRDtZQUFNRTtZQUFXRztRQUNyQztJQUNKO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxHQUNNLE1BQU1HO0lBU1Q7Ozs7S0FJQyxHQUNELE9BQU9DLFVBQVVILEtBQUssRUFBRTtRQUNwQixPQUFPLENB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VXNDLElBQUkrRCxJQUFJLEVBQUUvRCxJQUFJOEYsTUFBTTtJQUM5RztJQUNBOzs7OztLQUtDLEdBQ0RxQixXQUFXcEQsSUFBSSxFQUFFO1FBQ2IsTUFBTXFELFVBQVU5Syx3REFBT0EsQ0FBQ3lIO1FBQ3hCLE1BQU1yRyxXQUFXLElBQUksQ0FBQ2lHLFFBQVEsQ0FBQ3pILDBEQUFTQSxDQUFDa0wsU0FBUyxHQUFHO1FBQ3JELElBQUksQ0FBQzFKLFVBQVU7WUFDWCxPQUFPO1FBQ1g7UUFDQSxNQUFNRSxPQUFPLElBQUksQ0FBQyxDQUFDeUIsUUFBUSxDQUFDMkUsTUFBTSxDQUFDdEcsU0FBU2dCLE1BQU0sRUFBRXhDLDBEQUFTQSxDQUFDa0wsU0FBUztRQUN2RSxPQUFPLElBQUlqSixpQkFBaUJULFVBQVVBLFNBQVNPLFFBQVEsRUFBRUw7SUFDN0Q7SUFDQTs7Ozs7S0FLQyxHQUNELE9BQU9pQyxLQUFLM0IsS0FBSyxFQUFFO1FBQ2YsMkNBQTJDO1FBQzNDLElBQUlBLGlCQUFpQmUsV0FBVztZQUM1QixPQUFPZjtRQUNYO1FBQ0EsT0FBTztRQUNQLElBQUksT0FBUUEsVUFBVyxVQUFVO1lBQzdCLE9BQU8sSUFBSWUsVUFBVUosS0FBS1csS0FBSyxDQUFDdEI7UUFDcEM7UUFDQSxrREFBa0Q7UUFDbEQsSUFBSSxPQUFRQSxNQUFNZ0QsVUFBVSxLQUFNLFlBQVk7WUFDMUMsT0FBTyxJQUFJakMsVUFBVWYsTUFBTWdELFVBQVU7UUFDekM7UUFDQSw0Q0FBNEM7UUFDNUMsSUFBSSxPQUFRaEQsTUFBTUgsTUFBTSxLQUFNLFlBQVk7WUFDdEMsT0FBTyxJQUFJa0IsVUFBVWYsTUFBTUgsTUFBTSxDQUFDO1FBQ3RDO1FBQ0EscUJBQXFCO1FBQ3JCLE9BQU8sSUFBSWtCLFVBQVVmO0lBQ3pCO0FBQ0osRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95aWQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL2ludGVyZmFjZS5qcz9lNTY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFRoZSBJbnRlcmZhY2UgY2xhc3MgaXMgYSBsb3ctbGV2ZWwgY2xhc3MgdGhhdCBhY2NlcHRzIGFuXG4gKiAgQUJJIGFuZCBwcm92aWRlcyBhbGwgdGhlIG5lY2Vzc2FyeSBmdW5jdGlvbmFsaXR5IHRvIGVuY29kZVxuICogIGFuZCBkZWNvZGUgcGFyYW1hdGVycyB0byBhbmQgcmVzdWx0cyBmcm9tIG1ldGhvZHMsIGV2ZW50c1xuICogIGFuZCBlcnJvcnMuXG4gKlxuICogIEl0IGFsc28gcHJvdmlkZXMgc2V2ZXJhbCBjb252ZW5pZW5jZSBtZXRob2RzIHRvIGF1dG9tYXRpY2FsbHlcbiAqICBzZWFyY2ggYW5kIGZpbmQgbWF0Y2hpbmcgdHJhbnNhY3Rpb25zIGFuZCBldmVudHMgdG8gcGFyc2UgdGhlbS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS9hYmk6SW50ZXJmYWNlcyAgW2ludGVyZmFjZXNdXG4gKi9cbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4uL2hhc2gvaW5kZXguanNcIjtcbmltcG9ydCB7IGNvbmNhdCwgZGF0YVNsaWNlLCBnZXRCaWdJbnQsIGdldEJ5dGVzLCBnZXRCeXRlc0NvcHksIGhleGxpZnksIHplcm9QYWRCeXRlcywgemVyb1BhZFZhbHVlLCBpc0hleFN0cmluZywgZGVmaW5lUHJvcGVydGllcywgYXNzZXJ0QXJndW1lbnQsIHRvQmVIZXgsIGFzc2VydCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgQWJpQ29kZXIgfSBmcm9tIFwiLi9hYmktY29kZXIuanNcIjtcbmltcG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBSZXN1bHQgfSBmcm9tIFwiLi9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanNcIjtcbmltcG9ydCB7IENvbnN0cnVjdG9yRnJhZ21lbnQsIEVycm9yRnJhZ21lbnQsIEV2ZW50RnJhZ21lbnQsIEZyYWdtZW50LCBGdW5jdGlvbkZyYWdtZW50LCBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHMuanNcIjtcbmltcG9ydCB7IFR5cGVkIH0gZnJvbSBcIi4vdHlwZWQuanNcIjtcbmV4cG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBSZXN1bHQgfTtcbi8qKlxuICogIFdoZW4gdXNpbmcgdGhlIFtbSW50ZXJmYWNlLXBhcnNlTG9nXV0gdG8gYXV0b21hdGljYWxseSBtYXRjaCBhIExvZyB0byBpdHMgZXZlbnRcbiAqICBmb3IgcGFyc2luZywgYSAqKkxvZ0Rlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2dEZXNjcmlwdGlvbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBmcmFnbWVudCBmb3IgdGhlIGBgdG9waWMwYGAuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBFdmVudC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbCBFdmVudCBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgdG9waWMgaGFzaCBmb3IgdGhlIEV2ZW50LlxuICAgICAqL1xuICAgIHRvcGljO1xuICAgIC8qKlxuICAgICAqICBUaGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIHRoZSBFdmVudCB3aXRoIGBgZW1pdGBgLlxuICAgICAqL1xuICAgIGFyZ3M7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50LCB0b3BpYywgYXJncykge1xuICAgICAgICBjb25zdCBuYW1lID0gZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgZnJhZ21lbnQsIG5hbWUsIHNpZ25hdHVyZSwgdG9waWMsIGFyZ3NcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VUcmFuc2FjdGlvbl1dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2hcbiAqICBhIHRyYW5zYWN0aW9uIGRhdGEgdG8gaXRzIGZ1bmN0aW9uIGZvciBwYXJzaW5nLFxuICogIGEgKipUcmFuc2FjdGlvbkRlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50IGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgRnVuY3Rpb24gZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIEZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIGFyZ3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBmdWxsIEZ1bmN0aW9uIHNpZ25hdHVyZSBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBzaWduYXR1cmU7XG4gICAgLyoqXG4gICAgICogIFRoZSBzZWxlY3RvciBmb3IgdGhlIEZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIHNlbGVjdG9yO1xuICAgIC8qKlxuICAgICAqICBUaGUgYGB2YWx1ZWBgIChpbiB3ZWkpIGZyb20gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHZhbHVlO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudCwgc2VsZWN0b3IsIGFyZ3MsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgYXJncywgc2lnbmF0dXJlLCBzZWxlY3RvciwgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VFcnJvcl1dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2ggYW5cbiAqICBlcnJvciBmb3IgYSBjYWxsIHJlc3VsdCBmb3IgcGFyc2luZywgYW4gKipFcnJvckRlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvckRlc2NyaXB0aW9uIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG1hdGNoaW5nIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgRXJyb3IuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIEVycm9yIHdpdGggYGByZXZlcnRgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbCBFcnJvciBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VsZWN0b3IgZm9yIHRoZSBFcnJvci5cbiAgICAgKi9cbiAgICBzZWxlY3RvcjtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnQsIHNlbGVjdG9yLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcmFnbWVudC5uYW1lLCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgYXJncywgc2lnbmF0dXJlLCBzZWxlY3RvclxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqICBBbiAqKkluZGV4ZWQqKiBpcyB1c2VkIGFzIGEgdmFsdWUgd2hlbiBhIHZhbHVlIHRoYXQgZG9lcyBub3RcbiAqICBmaXQgd2l0aGluIGEgdG9waWMgKGkuZS4gbm90IGEgZml4ZWQtbGVuZ3RoLCAzMi1ieXRlIHR5cGUpLiBJdFxuICogIGlzIHRoZSBgYGtlY2NhazI1NmBgIG9mIHRoZSB2YWx1ZSwgYW5kIHVzZWQgZm9yIHR5cGVzIHN1Y2ggYXNcbiAqICBhcnJheXMsIHR1cGxlcywgYnl0ZXMgYW5kIHN0cmluZ3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmRleGVkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGBga2VjY2FrMjU2YGAgb2YgdGhlIHZhbHVlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBfaXNJbmRleGVkO1xuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUldmFsdWUlJSBpcyBhbiAqKkluZGV4ZWQqKi5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCBmb3IgcHJvcGVydHkgYWNjZXNzLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0luZGV4ZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0luZGV4ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaGFzaCkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgaGFzaCwgX2lzSW5kZXhlZDogdHJ1ZSB9KTtcbiAgICB9XG59XG4vLyBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi92MC44LjEzL2NvbnRyb2wtc3RydWN0dXJlcy5odG1sP2hpZ2hsaWdodD1wYW5pYyNwYW5pYy12aWEtYXNzZXJ0LWFuZC1lcnJvci12aWEtcmVxdWlyZVxuY29uc3QgUGFuaWNSZWFzb25zID0ge1xuICAgIFwiMFwiOiBcImdlbmVyaWMgcGFuaWNcIixcbiAgICBcIjFcIjogXCJhc3NlcnQoZmFsc2UpXCIsXG4gICAgXCIxN1wiOiBcImFyaXRobWV0aWMgb3ZlcmZsb3dcIixcbiAgICBcIjE4XCI6IFwiZGl2aXNpb24gb3IgbW9kdWxvIGJ5IHplcm9cIixcbiAgICBcIjMzXCI6IFwiZW51bSBvdmVyZmxvd1wiLFxuICAgIFwiMzRcIjogXCJpbnZhbGlkIGVuY29kZWQgc3RvcmFnZSBieXRlIGFycmF5IGFjY2Vzc2VkXCIsXG4gICAgXCI0OVwiOiBcIm91dC1vZi1ib3VuZHMgYXJyYXkgYWNjZXNzOyBwb3BwaW5nIG9uIGFuIGVtcHR5IGFycmF5XCIsXG4gICAgXCI1MFwiOiBcIm91dC1vZi1ib3VuZHMgYWNjZXNzIG9mIGFuIGFycmF5IG9yIGJ5dGVzTlwiLFxuICAgIFwiNjVcIjogXCJvdXQgb2YgbWVtb3J5XCIsXG4gICAgXCI4MVwiOiBcInVuaW5pdGlhbGl6ZWQgZnVuY3Rpb25cIixcbn07XG5jb25zdCBCdWlsdGluRXJyb3JzID0ge1xuICAgIFwiMHgwOGMzNzlhMFwiOiB7XG4gICAgICAgIHNpZ25hdHVyZTogXCJFcnJvcihzdHJpbmcpXCIsXG4gICAgICAgIG5hbWU6IFwiRXJyb3JcIixcbiAgICAgICAgaW5wdXRzOiBbXCJzdHJpbmdcIl0sXG4gICAgICAgIHJlYXNvbjogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBgcmV2ZXJ0ZWQgd2l0aCByZWFzb24gc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZSl9YDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCIweDRlNDg3YjcxXCI6IHtcbiAgICAgICAgc2lnbmF0dXJlOiBcIlBhbmljKHVpbnQyNTYpXCIsXG4gICAgICAgIG5hbWU6IFwiUGFuaWNcIixcbiAgICAgICAgaW5wdXRzOiBbXCJ1aW50MjU2XCJdLFxuICAgICAgICByZWFzb246IChjb2RlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVhc29uID0gXCJ1bmtub3duIHBhbmljIGNvZGVcIjtcbiAgICAgICAgICAgIGlmIChjb2RlID49IDAgJiYgY29kZSA8PSAweGZmICYmIFBhbmljUmVhc29uc1tjb2RlLnRvU3RyaW5nKCldKSB7XG4gICAgICAgICAgICAgICAgcmVhc29uID0gUGFuaWNSZWFzb25zW2NvZGUudG9TdHJpbmcoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYHJldmVydGVkIHdpdGggcGFuaWMgY29kZSAweCR7Y29kZS50b1N0cmluZygxNil9ICgke3JlYXNvbn0pYDtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqICBBbiBJbnRlcmZhY2UgYWJzdHJhY3RzIG1hbnkgb2YgdGhlIGxvdy1sZXZlbCBkZXRhaWxzIGZvclxuICogIGVuY29kaW5nIGFuZCBkZWNvZGluZyB0aGUgZGF0YSBvbiB0aGUgYmxvY2tjaGFpbi5cbiAqXG4gKiAgQW4gQUJJIHByb3ZpZGVzIGluZm9ybWF0aW9uIG9uIGhvdyB0byBlbmNvZGUgZGF0YSB0byBzZW5kIHRvXG4gKiAgYSBDb250cmFjdCwgaG93IHRvIGRlY29kZSB0aGUgcmVzdWx0cyBhbmQgZXZlbnRzIGFuZCBob3cgdG9cbiAqICBpbnRlcnByZXQgcmV2ZXJ0IGVycm9ycy5cbiAqXG4gKiAgVGhlIEFCSSBjYW4gYmUgc3BlY2lmaWVkIGJ5IFthbnkgc3VwcG9ydGVkIGZvcm1hdF0oSW50ZXJmYWNlQWJpKS5cbiAqL1xuZXhwb3J0IGNsYXNzIEludGVyZmFjZSB7XG4gICAgLyoqXG4gICAgICogIEFsbCB0aGUgQ29udHJhY3QgQUJJIG1lbWJlcnMgKGkuZS4gbWV0aG9kcywgZXZlbnRzLCBlcnJvcnMsIGV0YykuXG4gICAgICovXG4gICAgZnJhZ21lbnRzO1xuICAgIC8qKlxuICAgICAqICBUaGUgQ29udHJhY3QgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgZGVwbG95O1xuICAgIC8qKlxuICAgICAqICBUaGUgRmFsbGJhY2sgbWV0aG9kLCBpZiBhbnkuXG4gICAgICovXG4gICAgZmFsbGJhY2s7XG4gICAgLyoqXG4gICAgICogIElmIHJlY2VpdmluZyBldGhlciBpcyBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgcmVjZWl2ZTtcbiAgICAjZXJyb3JzO1xuICAgICNldmVudHM7XG4gICAgI2Z1bmN0aW9ucztcbiAgICAvLyAgICAjc3RydWN0czogTWFwPHN0cmluZywgU3RydWN0RnJhZ21lbnQ+O1xuICAgICNhYmlDb2RlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEludGVyZmFjZSBmb3IgdGhlICUlZnJhZ21lbnRzJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzKSB7XG4gICAgICAgIGxldCBhYmkgPSBbXTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnRzKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYWJpID0gSlNPTi5wYXJzZShmcmFnbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWJpID0gZnJhZ21lbnRzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Z1bmN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZXJyb3JzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNldmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vICAgICAgICB0aGlzLiNzdHJ1Y3RzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBmcmFncyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGEgb2YgYWJpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZyYWdzLnB1c2goRnJhZ21lbnQuZnJvbShhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1dhcm5pbmddIEludmFsaWQgRnJhZ21lbnQgJHtKU09OLnN0cmluZ2lmeShhKX06YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudHM6IE9iamVjdC5mcmVlemUoZnJhZ3MpXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZmFsbGJhY2sgPSBudWxsO1xuICAgICAgICBsZXQgcmVjZWl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNhYmlDb2RlciA9IHRoaXMuZ2V0QWJpQ29kZXIoKTtcbiAgICAgICAgLy8gQWRkIGFsbCBmcmFnbWVudHMgYnkgdGhlaXIgc2lnbmF0dXJlXG4gICAgICAgIHRoaXMuZnJhZ21lbnRzLmZvckVhY2goKGZyYWdtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1Y2tldDtcbiAgICAgICAgICAgIHN3aXRjaCAoZnJhZ21lbnQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXBsb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGRlcGxveTogZnJhZ21lbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWZhbGxiYWNrIHx8IGZyYWdtZW50LnBheWFibGUgIT09IGZhbGxiYWNrLnBheWFibGUsIFwiY29uZmxpY3RpbmcgZmFsbGJhY2sgZnJhZ21lbnRzXCIsIGBmcmFnbWVudHNbJHtpbmRleH1dYCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2sgPSBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmUgPSBmYWxsYmFjay5wYXlhYmxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJvdXRwdXRcIiwgKDxGdW5jdGlvbkZyYWdtZW50PmZyYWdtZW50KS5vdXRwdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy4jZnVuY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2V2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2Vycm9ycztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHdvIGlkZW50aWNhbCBlbnRyaWVzOyBpZ25vcmUgaXRcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICAgICAgaWYgKGJ1Y2tldC5oYXMoc2lnbmF0dXJlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Y2tldC5zZXQoc2lnbmF0dXJlLCBmcmFnbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB3ZSBkbyBub3QgaGF2ZSBhIGNvbnN0cnVjdG9yIGFkZCBhIGRlZmF1bHRcbiAgICAgICAgaWYgKCF0aGlzLmRlcGxveSkge1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICAgICAgZGVwbG95OiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20oXCJjb25zdHJ1Y3RvcigpXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZmFsbGJhY2ssIHJlY2VpdmUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBlbnRpcmUgSHVtYW4tUmVhZGFibGUgQUJJLCBhcyBhbiBhcnJheSBvZlxuICAgICAqICBzaWduYXR1cmVzLCBvcHRpb25hbGx5IGFzICUlbWluaW1hbCUlIHN0cmluZ3MsIHdoaWNoXG4gICAgICogIHJlbW92ZXMgcGFyYW1ldGVyIG5hbWVzIGFuZCB1bm5lY2Vlc2FyeSBzcGFjZXMuXG4gICAgICovXG4gICAgZm9ybWF0KG1pbmltYWwpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gKG1pbmltYWwgPyBcIm1pbmltYWxcIiA6IFwiZnVsbFwiKTtcbiAgICAgICAgY29uc3QgYWJpID0gdGhpcy5mcmFnbWVudHMubWFwKChmKSA9PiBmLmZvcm1hdChmb3JtYXQpKTtcbiAgICAgICAgcmV0dXJuIGFiaTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgSlNPTi1lbmNvZGVkIEFCSS4gVGhpcyBpcyB0aGUgZm9ybWF0IFNvbGlkaXlcbiAgICAgKiAgcmV0dXJucy5cbiAgICAgKi9cbiAgICBmb3JtYXRKc29uKCkge1xuICAgICAgICBjb25zdCBhYmkgPSB0aGlzLmZyYWdtZW50cy5tYXAoKGYpID0+IGYuZm9ybWF0KFwianNvblwiKSk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmUtYnVuZGxlIHRoZSBKU09OIGZyYWdtZW50cyBhIGJpdFxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYWJpLm1hcCgoaikgPT4gSlNPTi5wYXJzZShqKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEFCSSBjb2RlciB0aGF0IHdpbGwgYmUgdXNlZCB0byBlbmNvZGUgYW5kIGRlY29kZSBiaW5hcnlcbiAgICAgKiAgZGF0YS5cbiAgICAgKi9cbiAgICBnZXRBYmlDb2RlcigpIHtcbiAgICAgICAgcmV0dXJuIEFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpO1xuICAgIH1cbiAgICAvLyBGaW5kIGEgZnVuY3Rpb24gZGVmaW5pdGlvbiBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh1bmxlc3MgaXQgaXMgYW1iaWd1b3VzKVxuICAgICNnZXRGdW5jdGlvbihrZXksIHZhbHVlcywgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgLy8gU2VsZWN0b3JcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2Z1bmN0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gZnJhZ21lbnQuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2Z1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0VmFsdWUgPSAodmFsdWVzLmxlbmd0aCA+IDApID8gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgYWxsb3dPcHRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoVHlwZWQuaXNUeXBlZChsYXN0VmFsdWUpICYmIGxhc3RWYWx1ZS50eXBlID09PSBcIm92ZXJyaWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3B0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUxlbmd0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBoYXZlIGEgY29tcGF0aWJsZSBsZW5ndGguIFRoZSBhcmdzXG4gICAgICAgICAgICAgICAgLy8gbWF5IGNvbnRhaW4gYW4gb3ZlcnJpZGVzLCBzbyB0aGUgbWF0Y2ggbWF5IGhhdmUgbiBvciBuIC0gMSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IG1hdGNoaW5nW2ldLmlucHV0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMgIT09IHZhbHVlTGVuZ3RoICYmICghYWxsb3dPcHRpb25zIHx8IGlucHV0cyAhPT0gdmFsdWVMZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IG1hdGNoIHRoZSBUeXBlZCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdHlwZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVHlwZWQuaXNUeXBlZCh2YWx1ZXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgcGFzdCB0aGUgaW5wdXRzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA+PSBpbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlID09PSBcIm92ZXJyaWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZhbHVlIHR5cGUgbWF0Y2hlcyB0aGUgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlICE9PSBpbnB1dHNbal0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBmb3VuZCBhIHNpbmdsZSBtYXRjaGluZyBzaWduYXR1cmUgd2l0aCBhbiBvdmVycmlkZXMsIGJ1dCB0aGVcbiAgICAgICAgICAgIC8vIGxhc3QgdmFsdWUgaXMgc29tZXRoaW5nIHRoYXQgY2Fubm90IHBvc3NpYmx5IGJlIGFuIG9wdGlvbnNcbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDEgJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggIT09IG1hdGNoaW5nWzBdLmlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0QXJnID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEFyZyA9PSBudWxsIHx8IEFycmF5LmlzQXJyYXkobGFzdEFyZykgfHwgdHlwZW9mIChsYXN0QXJnKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoMCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEgJiYgZm9yY2VVbmlxdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFN0ciA9IG1hdGNoaW5nLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobS5mb3JtYXQoKSkpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgYGFtYmlndW91cyBmdW5jdGlvbiBkZXNjcmlwdGlvbiAoaS5lLiBtYXRjaGVzICR7bWF0Y2hTdHJ9KWAsIFwia2V5XCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZnVuY3Rpb25zLmdldChGdW5jdGlvbkZyYWdtZW50LmZyb20oa2V5KS5mb3JtYXQoKSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGZ1bmN0aW9uIG5hbWUgZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIGZ1bmN0aW9uIHNlbGVjdG9yLFxuICAgICAqICBmdW5jdGlvbiBuYW1lIG9yIGZ1bmN0aW9uIHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbk5hbWUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsIFwia2V5XCIsIGtleSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUla2V5JSUgKGEgZnVuY3Rpb24gc2VsZWN0b3IsIGZ1bmN0aW9uIG5hbWUgb3JcbiAgICAgKiAgZnVuY3Rpb24gc2lnbmF0dXJlKSBpcyBwcmVzZW50IGluIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSW4gdGhlIGNhc2Ugb2YgYSBmdW5jdGlvbiBuYW1lLCB0aGUgbmFtZSBtYXkgYmUgYW1iaWd1b3VzLCBzb1xuICAgICAqICBhY2Nlc3NpbmcgdGhlIFtbRnVuY3Rpb25GcmFnbWVudF1dIG1heSByZXF1aXJlIHJlZmluZW1lbnQuXG4gICAgICovXG4gICAgaGFzRnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuI2dldEZ1bmN0aW9uKGtleSwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBbW0Z1bmN0aW9uRnJhZ21lbnRdXSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgZnVuY3Rpb25cbiAgICAgKiAgc2VsZWN0b3IsIGZ1bmN0aW9uIG5hbWUgb3IgZnVuY3Rpb24gc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBmdW5jdGlvbnMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGZ1bmN0aW9uIGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbihrZXksIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCB2YWx1ZXMgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGZ1bmN0aW9ucywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hGdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZnVuY3Rpb25zLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNmdW5jdGlvbnMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmluZCBhbiBldmVudCBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgI2dldEV2ZW50KGtleSwgdmFsdWVzLCBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAvLyBFdmVudFRvcGljXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFRvcGljID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2V2ZW50cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudFRvcGljID09PSBmcmFnbWVudC50b3BpY0hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2V2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBoYXZlIGEgY29tcGF0aWJsZSBsZW5ndGguXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ1tpXS5pbnB1dHMubGVuZ3RoIDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IG1hdGNoIHRoZSBUeXBlZCBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdHlwZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVHlwZWQuaXNUeXBlZCh2YWx1ZXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZhbHVlIHR5cGUgbWF0Y2hlcyB0aGUgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlICE9PSBpbnB1dHNbal0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSAmJiBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoU3RyID0gbWF0Y2hpbmcubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtLmZvcm1hdCgpKSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgYW1iaWd1b3VzIGV2ZW50IGRlc2NyaXB0aW9uIChpLmUuIG1hdGNoZXMgJHttYXRjaFN0cn0pYCwgXCJrZXlcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNldmVudHMuZ2V0KEV2ZW50RnJhZ21lbnQuZnJvbShrZXkpLmZvcm1hdCgpKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgZXZlbnQgbmFtZSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgdG9waWMgaGFzaCxcbiAgICAgKiAgZXZlbnQgbmFtZSBvciBldmVudCBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICovXG4gICAgZ2V0RXZlbnROYW1lKGtleSkge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuI2dldEV2ZW50KGtleSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBldmVudFwiLCBcImtleVwiLCBrZXkpO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJWtleSUlIChhbiBldmVudCB0b3BpYyBoYXNoLCBldmVudCBuYW1lIG9yXG4gICAgICogIGV2ZW50IHNpZ25hdHVyZSkgaXMgcHJlc2VudCBpbiB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIEluIHRoZSBjYXNlIG9mIGFuIGV2ZW50IG5hbWUsIHRoZSBuYW1lIG1heSBiZSBhbWJpZ3VvdXMsIHNvXG4gICAgICogIGFjY2Vzc2luZyB0aGUgW1tFdmVudEZyYWdtZW50XV0gbWF5IHJlcXVpcmUgcmVmaW5lbWVudC5cbiAgICAgKi9cbiAgICBoYXNFdmVudChrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4jZ2V0RXZlbnQoa2V5LCBudWxsLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRXZlbnRGcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYSB0b3BpYyBoYXNoLFxuICAgICAqICBldmVudCBuYW1lIG9yIGV2ZW50IHNpZ25hdHVyZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIEFCSS5cbiAgICAgKlxuICAgICAqICBJZiAlJXZhbHVlcyUlIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHVzZSB0aGUgVHlwZWQgQVBJIHRvIGhhbmRsZVxuICAgICAqICBhbWJpZ3VvdXMgY2FzZXMgd2hlcmUgbXVsdGlwbGUgZXZlbnRzIG1hdGNoIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUla2V5JSUgYW5kICUldmFsdWVzJSUgZG8gbm90IHJlZmluZSB0byBhIHNpbmdsZSBldmVudCBpblxuICAgICAqICB0aGUgQUJJLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgZ2V0RXZlbnQoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dldEV2ZW50KGtleSwgdmFsdWVzIHx8IG51bGwsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSXRlcmF0ZSBvdmVyIGFsbCBldmVudHMsIGNhbGxpbmcgJSVjYWxsYmFjayUlLCBzb3J0ZWQgYnkgdGhlaXIgbmFtZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoRXZlbnQoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBBcnJheS5mcm9tKHRoaXMuI2V2ZW50cy5rZXlzKCkpO1xuICAgICAgICBuYW1lcy5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBjYWxsYmFjaygodGhpcy4jZXZlbnRzLmdldChuYW1lKSksIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIFtbRXJyb3JGcmFnbWVudF1dIGZvciAlJWtleSUlLCB3aGljaCBtYXkgYmUgYW4gZXJyb3JcbiAgICAgKiAgc2VsZWN0b3IsIGVycm9yIG5hbWUgb3IgZXJyb3Igc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBlcnJvcnMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGVycm9yIGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRFcnJvcihrZXksIHZhbHVlcykge1xuICAgICAgICBpZiAoaXNIZXhTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChCdWlsdGluRXJyb3JzW3NlbGVjdG9yXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oQnVpbHRpbkVycm9yc1tzZWxlY3Rvcl0uc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgdGhpcy4jZXJyb3JzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSBmcmFnbWVudC5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBmcmFnbWVudF0gb2YgdGhpcy4jZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiRXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgRXJyb3Ioc3RyaW5nKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJQYW5pY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBQYW5pYyh1aW50MjU2KVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hTdHIgPSBtYXRjaGluZy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0uZm9ybWF0KCkpKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBhbWJpZ3VvdXMgZXJyb3IgZGVzY3JpcHRpb24gKGkuZS4gJHttYXRjaFN0cn0pYCwgXCJuYW1lXCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAga2V5ID0gRXJyb3JGcmFnbWVudC5mcm9tKGtleSkuZm9ybWF0KCk7XG4gICAgICAgIGlmIChrZXkgPT09IFwiRXJyb3Ioc3RyaW5nKVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgRXJyb3Ioc3RyaW5nKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSBcIlBhbmljKHVpbnQyNTYpXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBQYW5pYyh1aW50MjU2KVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNlcnJvcnMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGVycm9ycywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hFcnJvcihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZXJyb3JzLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNlcnJvcnMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2V0IHRoZSA0LWJ5dGUgc2VsZWN0b3IgdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhIGZ1bmN0aW9uXG4gICAgLypcbmdldFNlbGVjdG9yKGZyYWdtZW50OiBFcnJvckZyYWdtZW50IHwgRnVuY3Rpb25GcmFnbWVudCk6IHN0cmluZyB7XG4gICAgaWYgKHR5cGVvZihmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlczogQXJyYXk8RnJhZ21lbnQ+ID0gWyBdO1xuXG4gICAgICAgIHRyeSB7IG1hdGNoZXMucHVzaCh0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KSk7IH0gY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgdHJ5IHsgbWF0Y2hlcy5wdXNoKHRoaXMuZ2V0RXJyb3IoPHN0cmluZz5mcmFnbWVudCkpOyB9IGNhdGNoIChfKSB7IH1cblxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmtub3duIGZyYWdtZW50XCIsIFwia2V5XCIsIGZyYWdtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhbWJpZ3VvdXMgZnJhZ21lbnQgbWF0Y2hlcyBmdW5jdGlvbiBhbmQgZXJyb3JcIiwgXCJrZXlcIiwgZnJhZ21lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhZ21lbnQgPSBtYXRjaGVzWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhU2xpY2UoaWQoZnJhZ21lbnQuZm9ybWF0KCkpLCAwLCA0KTtcbn1cbiAgICAqL1xuICAgIC8vIEdldCB0aGUgMzItYnl0ZSB0b3BpYyBoYXNoIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYW4gZXZlbnRcbiAgICAvKlxuICAgIGdldEV2ZW50VG9waWMoZnJhZ21lbnQ6IEV2ZW50RnJhZ21lbnQpOiBzdHJpbmcge1xuICAgICAgICAvL2lmICh0eXBlb2YoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7IGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KTsgfVxuICAgICAgICByZXR1cm4gaWQoZnJhZ21lbnQuZm9ybWF0KCkpO1xuICAgIH1cbiAgICAqL1xuICAgIF9kZWNvZGVQYXJhbXMocGFyYW1zLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5kZWNvZGUocGFyYW1zLCBkYXRhKTtcbiAgICB9XG4gICAgX2VuY29kZVBhcmFtcyhwYXJhbXMsIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jYWJpQ29kZXIuZW5jb2RlKHBhcmFtcywgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgYSBgYHR4LmRhdGFgYCBvYmplY3QgZm9yIGRlcGxveWluZyB0aGUgQ29udHJhY3Qgd2l0aFxuICAgICAqICB0aGUgJSV2YWx1ZXMlJSBhcyB0aGUgY29uc3RydWN0b3IgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGVuY29kZURlcGxveSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVBhcmFtcyh0aGlzLmRlcGxveS5pbnB1dHMsIHZhbHVlcyB8fCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGVzIHRoZSByZXN1bHQgJSVkYXRhJSUgKGUuZy4gZnJvbSBhbiBgYGV0aF9jYWxsYGApIGZvciB0aGVcbiAgICAgKiAgc3BlY2lmaWVkIGVycm9yIChzZWUgW1tnZXRFcnJvcl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yXG4gICAgICogICUla2V5JSUpLlxuICAgICAqXG4gICAgICogIE1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcHJlZmVyIHRoZSBbW3BhcnNlQ2FsbFJlc3VsdF1dIG1ldGhvZCBpbnN0ZWFkLFxuICAgICAqICB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IGEgYGBDQUxMX0VYQ0VQVElPTmBgIGFuZCB0aHJvdyB0aGVcbiAgICAgKiAgY29ycmVzcG9uZGluZyBlcnJvci5cbiAgICAgKi9cbiAgICBkZWNvZGVFcnJvclJlc3VsdChmcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBlcnJvclwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhU2xpY2UoZGF0YSwgMCwgNCkgPT09IGZyYWdtZW50LnNlbGVjdG9yLCBgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZXJyb3IgJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoZGF0YSwgNCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgdHJhbnNhY3Rpb24gcmV2ZXJ0IGRhdGEgZm9yIGEgY2FsbCByZXN1bHQgdGhhdFxuICAgICAqICByZXZlcnRlZCBmcm9tIHRoZSB0aGUgQ29udHJhY3Qgd2l0aCB0aGUgc2VwY2lmaWVkICUlZXJyb3IlJVxuICAgICAqICAoc2VlIFtbZ2V0RXJyb3JdXSBmb3IgdmFsaWQgdmFsdWVzIGZvciAlJWZyYWdtZW50JSUpIHdpdGggdGhlICUldmFsdWVzJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBnZW5lcmFsbHkgbm90IHVzZWQgYnkgbW9zdCBkZXZlbG9wZXJzLCB1bmxlc3MgdHJ5aW5nIHRvIG1vY2tcbiAgICAgKiAgYSByZXN1bHQgZnJvbSBhIENvbnRyYWN0LlxuICAgICAqL1xuICAgIGVuY29kZUVycm9yUmVzdWx0KGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXJyb3JcIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgICAgICBmcmFnbWVudC5zZWxlY3RvcixcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGVzIHRoZSAlJWRhdGElJSBmcm9tIGEgdHJhbnNhY3Rpb24gYGB0eC5kYXRhYGAgZm9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBzcGVjaWZpZWQgKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlc1xuICAgICAqICBmb3IgJSVmcmFnbWVudCUlKS5cbiAgICAgKlxuICAgICAqICBNb3N0IGRldmVsb3BlcnMgc2hvdWxkIHByZWZlciB0aGUgW1twYXJzZVRyYW5zYWN0aW9uXV0gbWV0aG9kXG4gICAgICogIGluc3RlYWQsIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGRlY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudChkYXRhU2xpY2UoZGF0YSwgMCwgNCkgPT09IGZyYWdtZW50LnNlbGVjdG9yLCBgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZnVuY3Rpb24gJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoZGF0YSwgNCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW5jb2RlcyB0aGUgYGB0eC5kYXRhYGAgZm9yIGEgdHJhbnNhY3Rpb24gdGhhdCBjYWxscyB0aGUgZnVuY3Rpb25cbiAgICAgKiAgc3BlY2lmaWVkIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yICUlZnJhZ21lbnQlJSkgd2l0aFxuICAgICAqICB0aGUgJSV2YWx1ZXMlJS5cbiAgICAgKi9cbiAgICBlbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgICAgIGZyYWdtZW50LnNlbGVjdG9yLFxuICAgICAgICAgICAgdGhpcy5fZW5jb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgdmFsdWVzIHx8IFtdKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZXMgdGhlIHJlc3VsdCAlJWRhdGElJSAoZS5nLiBmcm9tIGFuIGBgZXRoX2NhbGxgYCkgZm9yIHRoZVxuICAgICAqICBzcGVjaWZpZWQgZnVuY3Rpb24gKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3JcbiAgICAgKiAgJSVrZXklJSkuXG4gICAgICpcbiAgICAgKiAgTW9zdCBkZXZlbG9wZXJzIHNob3VsZCBwcmVmZXIgdGhlIFtbcGFyc2VDYWxsUmVzdWx0XV0gbWV0aG9kIGluc3RlYWQsXG4gICAgICogIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBkZXRlY3QgYSBgYENBTExfRVhDRVBUSU9OYGAgYW5kIHRocm93IHRoZVxuICAgICAqICBjb3JyZXNwb25kaW5nIGVycm9yLlxuICAgICAqL1xuICAgIGRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXNzYWdlID0gXCJpbnZhbGlkIGxlbmd0aCBmb3IgcmVzdWx0IGRhdGFcIjtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlc0NvcHkoZGF0YSk7XG4gICAgICAgIGlmICgoYnl0ZXMubGVuZ3RoICUgMzIpID09PSAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQub3V0cHV0cywgYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiY291bGQgbm90IGRlY29kZSByZXN1bHQgZGF0YVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENhbGwgcmV0dXJuZWQgZGF0YSB3aXRoIG5vIGVycm9yLCBidXQgdGhlIGRhdGEgaXMganVua1xuICAgICAgICBhc3NlcnQoZmFsc2UsIG1lc3NhZ2UsIFwiQkFEX0RBVEFcIiwge1xuICAgICAgICAgICAgdmFsdWU6IGhleGxpZnkoYnl0ZXMpLFxuICAgICAgICAgICAgaW5mbzogeyBtZXRob2Q6IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZTogZnJhZ21lbnQuZm9ybWF0KCkgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFrZUVycm9yKF9kYXRhLCB0eCkge1xuICAgICAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBBYmlDb2Rlci5nZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihcImNhbGxcIiwgdHgsIGRhdGEpO1xuICAgICAgICAvLyBOb3QgYSBidWlsdC1pbiBlcnJvcjsgdHJ5IGZpbmRpbmcgYSBjdXN0b20gZXJyb3JcbiAgICAgICAgY29uc3QgY3VzdG9tUHJlZml4ID0gXCJleGVjdXRpb24gcmV2ZXJ0ZWQgKHVua25vd24gY3VzdG9tIGVycm9yKVwiO1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKGN1c3RvbVByZWZpeCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gaGV4bGlmeShkYXRhLnNsaWNlKDAsIDQpKTtcbiAgICAgICAgICAgIGNvbnN0IGVmID0gdGhpcy5nZXRFcnJvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoZWYpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGVmLmlucHV0cywgZGF0YS5zbGljZSg0KSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnJldmVydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVmLm5hbWUsIHNpZ25hdHVyZTogZWYuZm9ybWF0KCksIGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucmVhc29uID0gZXJyb3IucmV2ZXJ0LnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGBleGVjdXRpb24gcmV2ZXJ0ZWQ6ICR7ZXJyb3IucmVhc29ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgZXhlY3V0aW9uIHJldmVydGVkIChjb3VsdCBub3QgZGVjb2RlIGN1c3RvbSBlcnJvcilgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGludm9jYXRpb24sIGlmIGF2YWlsYWJsZVxuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICBlcnJvci5pbnZvY2F0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcGFyc2VkLm5hbWUsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBwYXJzZWQuc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIGFyZ3M6IHBhcnNlZC5hcmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuY29kZXMgdGhlIHJlc3VsdCBkYXRhIChlLmcuIGZyb20gYW4gYGBldGhfY2FsbGBgKSBmb3IgdGhlXG4gICAgICogIHNwZWNpZmllZCBmdW5jdGlvbiAoc2VlIFtbZ2V0RnVuY3Rpb25dXSBmb3IgdmFsaWQgdmFsdWVzXG4gICAgICogIGZvciAlJWZyYWdtZW50JSUpIHdpdGggJSV2YWx1ZXMlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZCBieSBtb3N0IGRldmVsb3BlcnMsIHVubGVzcyB0cnlpbmcgdG8gbW9ja1xuICAgICAqICBhIHJlc3VsdCBmcm9tIGEgQ29udHJhY3QuXG4gICAgICovXG4gICAgZW5jb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4bGlmeSh0aGlzLiNhYmlDb2Rlci5lbmNvZGUoZnJhZ21lbnQub3V0cHV0cywgdmFsdWVzIHx8IFtdKSk7XG4gICAgfVxuICAgIC8qXG4gICAgICAgIHNwZWx1bmsoaW5wdXRzOiBBcnJheTxQYXJhbVR5cGU+LCB2YWx1ZXM6IFJlYWRvbmx5QXJyYXk8YW55PiwgcHJvY2Vzc2Z1bmM6ICh0eXBlOiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IFByb21pc2U8YW55Pik6IFByb21pc2U8QXJyYXk8YW55Pj4ge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXM6IEFycmF5PFByb21pc2U8Pj4gPSBbIF07XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzID0gZnVuY3Rpb24odHlwZTogUGFyYW1UeXBlLCB2YWx1ZTogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjZW5kKHR5cGUuY2hpbGRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBjb25zdCBkZXNjZW5kID0gZnVuY3Rpb24gKGlucHV0czogQXJyYXk8UGFyYW1UeXBlPiwgdmFsdWVzOiBSZWFkb25seUFycmF5PGFueT4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggbWlzbWF0Y2hcIik7IH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PGFueT4gPSBbIF07XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZpbHRlcmluZyB3aXRoIHR1cGxlcyBvciBhcnJheXMgbm90IHN1cHBvcnRlZFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh2YWx1ZS5tYXAoKHZhbHVlKSA9PiBlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAqL1xuICAgIC8vIENyZWF0ZSB0aGUgZmlsdGVyIGZvciB0aGUgZXZlbnQgd2l0aCBzZWFyY2ggY3JpdGVyaWEgKGUuZy4gZm9yIGV0aF9maWx0ZXJMb2cpXG4gICAgZW5jb2RlRmlsdGVyVG9waWNzKGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQodmFsdWVzLmxlbmd0aCA8PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBgdG9vIG1hbnkgYXJndW1lbnRzIGZvciAke2ZyYWdtZW50LmZvcm1hdCgpfWAsIFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiLCB7IGNvdW50OiB2YWx1ZXMubGVuZ3RoLCBleHBlY3RlZENvdW50OiBmcmFnbWVudC5pbnB1dHMubGVuZ3RoIH0pO1xuICAgICAgICBjb25zdCB0b3BpY3MgPSBbXTtcbiAgICAgICAgaWYgKCFmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHRvcGljcy5wdXNoKGZyYWdtZW50LnRvcGljSGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IFVzZSB0aGUgY29kZXJzIGZvciB0aGlzOyB0byBwcm9wZXJseSBzdXBwb3J0IHR1cGxlcywgZXRjLlxuICAgICAgICBjb25zdCBlbmNvZGVUb3BpYyA9IChwYXJhbSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYoaGV4bGlmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwiYm9vbFwiICYmIHR5cGVvZiAodmFsdWUpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlID8gXCIweDAxXCIgOiBcIjB4MDBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlLm1hdGNoKC9edT9pbnQvKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9CZUhleCh2YWx1ZSk7IC8vIEBUT0RPOiBTaG91bGQgdGhpcyB0b1R3b3M/P1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZS5tYXRjaCgvXmJ5dGVzLykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHplcm9QYWRCeXRlcyh2YWx1ZSwgMzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBhZGRyZXNzZXMgYXJlIHZhbGlkXG4gICAgICAgICAgICAgICAgdGhpcy4jYWJpQ29kZXIuZW5jb2RlKFtcImFkZHJlc3NcIl0sIFt2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHplcm9QYWRWYWx1ZShoZXhsaWZ5KHZhbHVlKSwgMzIpO1xuICAgICAgICB9O1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IGZyYWdtZW50LmlucHV0c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIXBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA9PSBudWxsLCBcImNhbm5vdCBmaWx0ZXIgbm9uLWluZGV4ZWQgcGFyYW1ldGVyczsgbXVzdCBiZSBudWxsXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiZmlsdGVyaW5nIHdpdGggdHVwbGVzIG9yIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2godmFsdWUubWFwKCh2YWx1ZSkgPT4gZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmltIG9mZiB0cmFpbGluZyBudWxsc1xuICAgICAgICB3aGlsZSAodG9waWNzLmxlbmd0aCAmJiB0b3BpY3NbdG9waWNzLmxlbmd0aCAtIDFdID09PSBudWxsKSB7XG4gICAgICAgICAgICB0b3BpY3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcGljcztcbiAgICB9XG4gICAgZW5jb2RlRXZlbnRMb2coZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEV2ZW50KGZyYWdtZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGYsIFwidW5rbm93biBldmVudFwiLCBcImV2ZW50RnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhVHlwZXMgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YVZhbHVlcyA9IFtdO1xuICAgICAgICBpZiAoIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgdG9waWNzLnB1c2goZnJhZ21lbnQudG9waWNIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZXMubGVuZ3RoID09PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBcImV2ZW50IGFyZ3VtZW50cy92YWx1ZXMgbWlzbWF0Y2hcIiwgXCJ2YWx1ZXNcIiwgdmFsdWVzKTtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChpZCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goa2VjY2FrMjU2KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ET1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh0aGlzLiNhYmlDb2Rlci5lbmNvZGUoW3BhcmFtLnR5cGVdLCBbdmFsdWVdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGRhdGFWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogdGhpcy4jYWJpQ29kZXIuZW5jb2RlKGRhdGFUeXBlcywgZGF0YVZhbHVlcyksXG4gICAgICAgICAgICB0b3BpY3M6IHRvcGljc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBEZWNvZGUgYSBmaWx0ZXIgZm9yIHRoZSBldmVudCBhbmQgdGhlIHNlYXJjaCBjcml0ZXJpYVxuICAgIGRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBkYXRhLCB0b3BpY3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmLCBcInVua25vd24gZXZlbnRcIiwgXCJldmVudEZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9waWNzICE9IG51bGwgJiYgIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRUb3BpYyA9IGZyYWdtZW50LnRvcGljSGFzaDtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGlzSGV4U3RyaW5nKHRvcGljc1swXSwgMzIpICYmIHRvcGljc1swXS50b0xvd2VyQ2FzZSgpID09PSBldmVudFRvcGljLCBcImZyYWdtZW50L3RvcGljIG1pc21hdGNoXCIsIFwidG9waWNzWzBdXCIsIHRvcGljc1swXSk7XG4gICAgICAgICAgICB0b3BpY3MgPSB0b3BpY3Muc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXhlZCA9IFtdO1xuICAgICAgICBjb25zdCBub25JbmRleGVkID0gW107XG4gICAgICAgIGNvbnN0IGR5bmFtaWMgPSBbXTtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBwYXJhbS50eXBlID09PSBcImJ5dGVzXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChQYXJhbVR5cGUuZnJvbSh7IHR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBwYXJhbS5uYW1lIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub25JbmRleGVkLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHRJbmRleGVkID0gKHRvcGljcyAhPSBudWxsKSA/IHRoaXMuI2FiaUNvZGVyLmRlY29kZShpbmRleGVkLCBjb25jYXQodG9waWNzKSkgOiBudWxsO1xuICAgICAgICBjb25zdCByZXN1bHROb25JbmRleGVkID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKG5vbkluZGV4ZWQsIGRhdGEsIHRydWUpO1xuICAgICAgICAvL2NvbnN0IHJlc3VsdDogKEFycmF5PGFueT4gJiB7IFsga2V5OiBzdHJpbmcgXTogYW55IH0pID0gWyBdO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICBsZXQgbm9uSW5kZXhlZEluZGV4ID0gMCwgaW5kZXhlZEluZGV4ID0gMDtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdEluZGV4ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbmRleGVkKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkeW5hbWljW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbmRleGVkKHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0Tm9uSW5kZXhlZFtub25JbmRleGVkSW5kZXgrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMucHVzaChwYXJhbS5uYW1lIHx8IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5mcm9tSXRlbXModmFsdWVzLCBrZXlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhcnNlcyBhIHRyYW5zYWN0aW9uLCBmaW5kaW5nIHRoZSBtYXRjaGluZyBmdW5jdGlvbiBhbmQgZXh0cmFjdHNcbiAgICAgKiAgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYWxvbmcgd2l0aCBvdGhlciB1c2VmdWwgZnVuY3Rpb24gZGV0YWlscy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gY2Fubm90IGJlIGZvdW5kLCByZXR1cm4gbnVsbC5cbiAgICAgKi9cbiAgICBwYXJzZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRCeXRlcyh0eC5kYXRhLCBcInR4LmRhdGFcIik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0QmlnSW50KCh0eC52YWx1ZSAhPSBudWxsKSA/IHR4LnZhbHVlIDogMCwgXCJ0eC52YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGhleGxpZnkoZGF0YS5zbGljZSgwLCA0KSkpO1xuICAgICAgICBpZiAoIWZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50LmlucHV0cywgZGF0YS5zbGljZSg0KSk7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbihmcmFnbWVudCwgZnJhZ21lbnQuc2VsZWN0b3IsIGFyZ3MsIHZhbHVlKTtcbiAgICB9XG4gICAgcGFyc2VDYWxsUmVzdWx0KGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXJzZXMgYSByZWNlaXB0IGxvZywgZmluZGluZyB0aGUgbWF0Y2hpbmcgZXZlbnQgYW5kIGV4dHJhY3RzXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGV2ZW50IGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGV2ZW50IGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlTG9nKGxvZykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQgfHwgZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogSWYgYW5vbnltb3VzLCBhbmQgdGhlIG9ubHkgbWV0aG9kLCBhbmQgdGhlIGlucHV0IGNvdW50IG1hdGNoZXMsIHNob3VsZCB3ZSBwYXJzZT9cbiAgICAgICAgLy8gICAgICAgIFByb2JhYmx5IG5vdCwgYmVjYXVzZSBqdXN0IGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgZXZlbnQgaW4gdGhlIEFCSSBkb2VzXG4gICAgICAgIC8vICAgICAgICBub3QgbWVhbiB3ZSBoYXZlIHRoZSBmdWxsIEFCSTsgbWF5YmUganVzdCBhIGZyYWdtZW50P1xuICAgICAgICByZXR1cm4gbmV3IExvZ0Rlc2NyaXB0aW9uKGZyYWdtZW50LCBmcmFnbWVudC50b3BpY0hhc2gsIHRoaXMuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXJzZXMgYSByZXZlcnQgZGF0YSwgZmluZGluZyB0aGUgbWF0Y2hpbmcgZXJyb3IgYW5kIGV4dHJhY3RzXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGVycm9yIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGVycm9yIGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlRXJyb3IoZGF0YSkge1xuICAgICAgICBjb25zdCBoZXhEYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGRhdGFTbGljZShoZXhEYXRhLCAwLCA0KSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQuaW5wdXRzLCBkYXRhU2xpY2UoaGV4RGF0YSwgNCkpO1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yRGVzY3JpcHRpb24oZnJhZ21lbnQsIGZyYWdtZW50LnNlbGVjdG9yLCBhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tJbnRlcmZhY2VdXSBmcm9tIHRoZSBBQkkgJSV2YWx1ZSUlLlxuICAgICAqXG4gICAgICogIFRoZSAlJXZhbHVlJSUgbWF5IGJlIHByb3ZpZGVkIGFzIGFuIGV4aXN0aW5nIFtbSW50ZXJmYWNlXV0gb2JqZWN0LFxuICAgICAqICBhIEpTT04tZW5jb2RlZCBBQkkgb3IgYW55IEh1bWFuLVJlYWRhYmxlIEFCSSBmb3JtYXQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBhbiBJbnRlcmZhY2UsIHdoaWNoIGlzIGltbXV0YWJsZVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcmZhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBKU09OXG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UoSlNPTi5wYXJzZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFuIEludGVyZmFjZTsgcG9zc2libHkgZnJvbSBhbm90aGVyIHY2IGluc3RhbmNlXG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlLmZvcm1hdEpzb24pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlLmZvcm1hdEpzb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBsZWdhY3kgSW50ZXJmYWNlOyBmcm9tIGFuIG9sZGVyIHZlcnNpb25cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUuZm9ybWF0KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZSh2YWx1ZS5mb3JtYXQoXCJqc29uXCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheSBvZiBmcmFnbWVudHNcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UodmFsdWUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiXSwibmFtZXMiOlsia2VjY2FrMjU2IiwiaWQiLCJjb25jYXQiLCJkYXRhU2xpY2UiLCJnZXRCaWdJbnQiLCJnZXRCeXRlcyIsImdldEJ5dGVzQ29weSIsImhleGxpZnkiLCJ6ZXJvUGFkQnl0ZXMiLCJ6ZXJvUGFkVmFsdWUiLCJpc0hleFN0cmluZyIsImRlZmluZVByb3BlcnRpZXMiLCJhc3NlcnRBcmd1bWVudCIsInRvQmVIZXgiLCJhc3NlcnQiLCJBYmlDb2RlciIsImNoZWNrUmVzdWx0RXJyb3JzIiwiUmVzdWx0IiwiQ29uc3RydWN0b3JGcmFnbWVudCIsIkVycm9yRnJhZ21lbnQiLCJFdmVudEZyYWdtZW50IiwiRnJhZ21lbnQiLCJGdW5jdGlvbkZyYWdtZW50IiwiUGFyYW1UeXBlIiwiVHlwZWQiLCJMb2dEZXNjcmlwdGlvbiIsImNvbnN0cnVjdG9yIiwiZnJhZ21lbnQiLCJ0b3BpYyIsImFyZ3MiLCJuYW1lIiwic2lnbmF0dXJlIiwiZm9ybWF0IiwiVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiIsInNlbGVjdG9yIiwidmFsdWUiLCJFcnJvckRlc2NyaXB0aW9uIiwiSW5kZXhlZCIsImlzSW5kZXhlZCIsIl9pc0luZGV4ZWQiLCJoYXNoIiwiUGFuaWNSZWFzb25zIiwiQnVpbHRpbkVycm9ycyIsImlucHV0cyIsInJlYXNvbiIsIm1lc3NhZ2UiLCJKU09OIiwic3RyaW5naWZ5IiwiY29kZSIsInRvU3RyaW5nIiwiSW50ZXJmYWNlIiwiZXJyb3JzIiwiZXZlbnRzIiwiZnVuY3Rpb25zIiwiYWJpQ29kZXIiLCJmcmFnbWVudHMiLCJhYmkiLCJwYXJzZSIsIk1hcCIsImZyYWdzIiwiYSIsInB1c2giLCJmcm9tIiwiZXJyb3IiLCJjb25zb2xlIiwibG9nIiwiT2JqZWN0IiwiZnJlZXplIiwiZmFsbGJhY2siLCJyZWNlaXZlIiwiZ2V0QWJpQ29kZXIiLCJmb3JFYWNoIiwiaW5kZXgiLCJidWNrZXQiLCJ0eXBlIiwiZGVwbG95IiwibGVuZ3RoIiwicGF5YWJsZSIsImhhcyIsInNldCIsIm1pbmltYWwiLCJtYXAiLCJmIiwiZm9ybWF0SnNvbiIsImoiLCJkZWZhdWx0QWJpQ29kZXIiLCJnZXRGdW5jdGlvbiIsImtleSIsInZhbHVlcyIsImZvcmNlVW5pcXVlIiwidG9Mb3dlckNhc2UiLCJpbmRleE9mIiwibWF0Y2hpbmciLCJzcGxpdCIsImxhc3RWYWx1ZSIsInZhbHVlTGVuZ3RoIiwiYWxsb3dPcHRpb25zIiwiaXNUeXBlZCIsImkiLCJzcGxpY2UiLCJiYXNlVHlwZSIsImxhc3RBcmciLCJBcnJheSIsImlzQXJyYXkiLCJtYXRjaFN0ciIsIm0iLCJqb2luIiwicmVzdWx0IiwiZ2V0IiwiZ2V0RnVuY3Rpb25OYW1lIiwiaGFzRnVuY3Rpb24iLCJmb3JFYWNoRnVuY3Rpb24iLCJjYWxsYmFjayIsIm5hbWVzIiwia2V5cyIsInNvcnQiLCJiIiwibG9jYWxlQ29tcGFyZSIsImdldEV2ZW50IiwiZXZlbnRUb3BpYyIsInRvcGljSGFzaCIsImdldEV2ZW50TmFtZSIsImhhc0V2ZW50IiwiZm9yRWFjaEV2ZW50IiwiZ2V0RXJyb3IiLCJmb3JFYWNoRXJyb3IiLCJfZGVjb2RlUGFyYW1zIiwicGFyYW1zIiwiZGF0YSIsImRlY29kZSIsIl9lbmNvZGVQYXJhbXMiLCJlbmNvZGUiLCJlbmNvZGVEZXBsb3kiLCJkZWNvZGVFcnJvclJlc3VsdCIsImVuY29kZUVycm9yUmVzdWx0IiwiZGVjb2RlRnVuY3Rpb25EYXRhIiwiZW5jb2RlRnVuY3Rpb25EYXRhIiwiZGVjb2RlRnVuY3Rpb25SZXN1bHQiLCJieXRlcyIsIm91dHB1dHMiLCJpbmZvIiwibWV0aG9kIiwibWFrZUVycm9yIiwiX2RhdGEiLCJ0eCIsImdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uIiwiY3VzdG9tUHJlZml4Iiwic3RhcnRzV2l0aCIsInNsaWNlIiwiZWYiLCJyZXZlcnQiLCJlIiwicGFyc2VkIiwicGFyc2VUcmFuc2FjdGlvbiIsImludm9jYXRpb24iLCJlbmNvZGVGdW5jdGlvblJlc3VsdCIsImVuY29kZUZpbHRlclRvcGljcyIsImNvdW50IiwiZXhwZWN0ZWRDb3VudCIsInRvcGljcyIsImFub255bW91cyIsImVuY29kZVRvcGljIiwicGFyYW0iLCJtYXRjaCIsImluZGV4ZWQiLCJwb3AiLCJlbmNvZGVFdmVudExvZyIsImRhdGFUeXBlcyIsImRhdGFWYWx1ZXMiLCJFcnJvciIsImRlY29kZUV2ZW50TG9nIiwibm9uSW5kZXhlZCIsImR5bmFtaWMiLCJyZXN1bHRJbmRleGVkIiwicmVzdWx0Tm9uSW5kZXhlZCIsIm5vbkluZGV4ZWRJbmRleCIsImluZGV4ZWRJbmRleCIsImZyb21JdGVtcyIsInBhcnNlQ2FsbFJlc3VsdCIsInBhcnNlTG9nIiwicGFyc2VFcnJvciIsImhleERhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/abi/typed.js":
/*!**************************************************!*\
  !*** ./node_modules/ethers/lib.esm/abi/typed.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Typed: () => (/* binding */ Typed)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  A Typed object allows a value to have its type explicitly\n *  specified.\n *\n *  For example, in Solidity, the value ``45`` could represent a\n *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent\n *  a ``bytes2`` or ``bytes``.\n *\n *  Since JavaScript has no meaningful way to explicitly inform any\n *  APIs which what the type is, this allows transparent interoperation\n *  with Soldity.\n *\n *  @_subsection: api/abi:Typed Values\n */ \nconst _gaurd = {};\nfunction n(value, width) {\n    let signed = false;\n    if (width < 0) {\n        signed = true;\n        width *= -1;\n    }\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `${signed ? \"\" : \"u\"}int${width}`, value, {\n        signed,\n        width\n    });\n}\nfunction b(value, size) {\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `bytes${size ? size : \"\"}`, value, {\n        size\n    });\n}\nconst _typedSymbol = Symbol.for(\"_ethers_typed\");\n/**\n *  The **Typed** class to wrap values providing explicit type information.\n */ class Typed {\n    #options;\n    /**\n     *  @_ignore:\n     */ constructor(gaurd, type, value, options){\n        if (options == null) {\n            options = null;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(_gaurd, gaurd, \"Typed\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            _typedSymbol,\n            type,\n            value\n        });\n        this.#options = options;\n        // Check the value is valid\n        this.format();\n    }\n    /**\n     *  Format the type as a Human-Readable type.\n     */ format() {\n        if (this.type === \"array\") {\n            throw new Error(\"\");\n        } else if (this.type === \"dynamicArray\") {\n            throw new Error(\"\");\n        } else if (this.type === \"tuple\") {\n            return `tuple(${this.value.map((v)=>v.format()).join(\",\")})`;\n        }\n        return this.type;\n    }\n    /**\n     *  The default value returned by this type.\n     */ defaultValue() {\n        return 0;\n    }\n    /**\n     *  The minimum value for numeric types.\n     */ minValue() {\n        return 0;\n    }\n    /**\n     *  The maximum value for numeric types.\n     */ maxValue() {\n        return 0;\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].\n     */ isBigInt() {\n        return !!this.type.match(/^u?int[0-9]+$/);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedData]].\n     */ isData() {\n        return this.type.startsWith(\"bytes\");\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedString]].\n     */ isString() {\n        return this.type === \"string\";\n    }\n    /**\n     *  Returns the tuple name, if this is a tuple. Throws otherwise.\n     */ get tupleName() {\n        if (this.type !== \"tuple\") {\n            throw TypeError(\"not a tuple\");\n        }\n        return this.#options;\n    }\n    // Returns the length of this type as an array\n    // - `null` indicates the length is unforced, it could be dynamic\n    // - `-1` indicates the length is dynamic\n    // - any other value indicates it is a static array and is its length\n    /**\n     *  Returns the length of the array type or ``-1`` if it is dynamic.\n     *\n     *  Throws if the type is not an array.\n     */ get arrayLength() {\n        if (this.type !== \"array\") {\n            throw TypeError(\"not an array\");\n        }\n        if (this.#options === true) {\n            return -1;\n        }\n        if (this.#options === false) {\n            return this.value.length;\n        }\n        return null;\n    }\n    /**\n     *  Returns a new **Typed** of %%type%% with the %%value%%.\n     */ static from(type, value) {\n        return new Typed(_gaurd, type, value);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */ static uint8(v) {\n        return n(v, 8);\n    }\n    /**\n     *  Return a new ``uint16`` type for %%v%%.\n     */ static uint16(v) {\n        return n(v, 16);\n    }\n    /**\n     *  Return a new ``uint24`` type for %%v%%.\n     */ static uint24(v) {\n        return n(v, 24);\n    }\n    /**\n     *  Return a new ``uint32`` type for %%v%%.\n     */ static uint32(v) {\n        return n(v, 32);\n    }\n    /**\n     *  Return a new ``uint40`` type for %%v%%.\n     */ static uint40(v) {\n        return n(v, 40);\n    }\n    /**\n     *  Return a new ``uint48`` type for %%v%%.\n     */ static uint48(v) {\n        return n(v, 48);\n    }\n    /**\n     *  Return a new ``uint56`` type for %%v%%.\n     */ static uint56(v) {\n        return n(v, 56);\n    }\n    /**\n     *  Return a new ``uint64`` type for %%v%%.\n     */ static uint64(v) {\n        return n(v, 64);\n    }\n    /**\n     *  Return a new ``uint72`` type for %%v%%.\n     */ static uint72(v) {\n        return n(v, 72);\n    }\n    /**\n     *  Return a new ``uint80`` type for %%v%%.\n     */ static uint80(v) {\n        return n(v, 80);\n    }\n    /**\n     *  Return a new ``uint88`` type for %%v%%.\n     */ static uint88(v) {\n        return n(v, 88);\n    }\n    /**\n     *  Return a new ``uint96`` type for %%v%%.\n     */ static uint96(v) {\n        return n(v, 96);\n    }\n    /**\n     *  Return a new ``uint104`` type for %%v%%.\n     */ static uint104(v) {\n        return n(v, 104);\n    }\n    /**\n     *  Return a new ``uint112`` type for %%v%%.\n     */ static uint112(v) {\n        return n(v, 112);\n    }\n    /**\n     *  Return a new ``uint120`` type for %%v%%.\n     */ static uint120(v) {\n        return n(v, 120);\n    }\n    /**\n     *  Return a new ``uint128`` type for %%v%%.\n     */ static uint128(v) {\n        return n(v, 128);\n    }\n    /**\n     *  Return a new ``uint136`` type for %%v%%.\n     */ static uint136(v) {\n        return n(v, 136);\n    }\n    /**\n     *  Return a new ``uint144`` type for %%v%%.\n     */ static uint144(v) {\n        return n(v, 144);\n    }\n    /**\n     *  Return a new ``uint152`` type for %%v%%.\n     */ static uint152(v) {\n        return n(v, 152);\n    }\n    /**\n     *  Return a new ``uint160`` type for %%v%%.\n     */ static uint160(v) {\n        return n(v, 160);\n    }\n    /**\n     *  Return a new ``uint168`` type for %%v%%.\n     */ static uint168(v) {\n        return n(v, 168);\n    }\n    /**\n     *  Return a new ``uint176`` type for %%v%%.\n     */ static uint176(v) {\n        return n(v, 176);\n    }\n    /**\n     *  Return a new ``uint184`` type for %%v%%.\n     */ static uint184(v) {\n        return n(v, 184);\n    }\n    /**\n     *  Return a new ``uint192`` type for %%v%%.\n     */ static uint192(v) {\n        return n(v, 192);\n    }\n    /**\n     *  Return a new ``uint200`` type for %%v%%.\n     */ static uint200(v) {\n        return n(v, 200);\n    }\n    /**\n     *  Return a new ``uint208`` type for %%v%%.\n     */ static uint208(v) {\n        return n(v, 208);\n    }\n    /**\n     *  Return a new ``uint216`` type for %%v%%.\n     */ static uint216(v) {\n        return n(v, 216);\n    }\n    /**\n     *  Return a new ``uint224`` type for %%v%%.\n     */ static uint224(v) {\n        return n(v, 224);\n    }\n    /**\n     *  Return a new ``uint232`` type for %%v%%.\n     */ static uint232(v) {\n        return n(v, 232);\n    }\n    /**\n     *  Return a new ``uint240`` type for %%v%%.\n     */ static uint240(v) {\n        return n(v, 240);\n    }\n    /**\n     *  Return a new ``uint248`` type for %%v%%.\n     */ static uint248(v) {\n        return n(v, 248);\n    }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */ static uint256(v) {\n        return n(v, 256);\n    }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */ static uint(v) {\n        return n(v, 256);\n    }\n    /**\n     *  Return a new ``int8`` type for %%v%%.\n     */ static int8(v) {\n        return n(v, -8);\n    }\n    /**\n     *  Return a new ``int16`` type for %%v%%.\n     */ static int16(v) {\n        return n(v, -16);\n    }\n    /**\n     *  Return a new ``int24`` type for %%v%%.\n     */ static int24(v) {\n        return n(v, -24);\n    }\n    /**\n     *  Return a new ``int32`` type for %%v%%.\n     */ static int32(v) {\n        return n(v, -32);\n    }\n    /**\n     *  Return a new ``int40`` type for %%v%%.\n     */ static int40(v) {\n        return n(v, -40);\n    }\n    /**\n     *  Return a new ``int48`` type for %%v%%.\n     */ static int48(v) {\n        return n(v, -48);\n    }\n    /**\n     *  Return a new ``int56`` type for %%v%%.\n     */ static int56(v) {\n        return n(v, -56);\n    }\n    /**\n     *  Return a new ``int64`` type for %%v%%.\n     */ static int64(v) {\n        return n(v, -64);\n    }\n    /**\n     *  Return a new ``int72`` type for %%v%%.\n     */ static int72(v) {\n        return n(v, -72);\n    }\n    /**\n     *  Return a new ``int80`` type for %%v%%.\n     */ static int80(v) {\n        return n(v, -80);\n    }\n    /**\n     *  Return a new ``int88`` type for %%v%%.\n     */ static int88(v) {\n        return n(v, -88);\n    }\n    /**\n     *  Return a new ``int96`` type for %%v%%.\n     */ static int96(v) {\n        return n(v, -96);\n    }\n    /**\n     *  Return a new ``int104`` type for %%v%%.\n     */ static int104(v) {\n        return n(v, -104);\n    }\n    /**\n     *  Return a new ``int112`` type for %%v%%.\n     */ static int112(v) {\n        return n(v, -112);\n    }\n    /**\n     *  Return a new ``int120`` type for %%v%%.\n     */ static int120(v) {\n        return n(v, -120);\n    }\n    /**\n     *  Return a new ``int128`` type for %%v%%.\n     */ static int128(v) {\n        return n(v, -128);\n    }\n    /**\n     *  Return a new ``int136`` type for %%v%%.\n     */ static int136(v) {\n        return n(v, -136);\n    }\n    /**\n     *  Return a new ``int144`` type for %%v%%.\n     */ static int144(v) {\n        return n(v, -144);\n    }\n    /**\n     *  Return a new ``int52`` type for %%v%%.\n     */ static int152(v) {\n        return n(v, -152);\n    }\n    /**\n     *  Return a new ``int160`` type for %%v%%.\n     */ static int160(v) {\n        return n(v, -160);\n    }\n    /**\n     *  Return a new ``int168`` type for %%v%%.\n     */ static int168(v) {\n        return n(v, -168);\n    }\n    /**\n     *  Return a new ``int176`` type for %%v%%.\n     */ static int176(v) {\n        return n(v, -176);\n    }\n    /**\n     *  Return a new ``int184`` type for %%v%%.\n     */ static int184(v) {\n        return n(v, -184);\n    }\n    /**\n     *  Return a new ``int92`` type for %%v%%.\n     */ static int192(v) {\n        return n(v, -192);\n    }\n    /**\n     *  Return a new ``int200`` type for %%v%%.\n     */ static int200(v) {\n        return n(v, -200);\n    }\n    /**\n     *  Return a new ``int208`` type for %%v%%.\n     */ static int208(v) {\n        return n(v, -208);\n    }\n    /**\n     *  Return a new ``int216`` type for %%v%%.\n     */ static int216(v) {\n        return n(v, -216);\n    }\n    /**\n     *  Return a new ``int224`` type for %%v%%.\n     */ static int224(v) {\n        return n(v, -224);\n    }\n    /**\n     *  Return a new ``int232`` type for %%v%%.\n     */ static int232(v) {\n        return n(v, -232);\n    }\n    /**\n     *  Return a new ``int240`` type for %%v%%.\n     */ static int240(v) {\n        return n(v, -240);\n    }\n    /**\n     *  Return a new ``int248`` type for %%v%%.\n     */ static int248(v) {\n        return n(v, -248);\n    }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */ static int256(v) {\n        return n(v, -256);\n    }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */ static int(v) {\n        return n(v, -256);\n    }\n    /**\n     *  Return a new ``bytes1`` type for %%v%%.\n     */ static bytes1(v) {\n        return b(v, 1);\n    }\n    /**\n     *  Return a new ``bytes2`` type for %%v%%.\n     */ static bytes2(v) {\n        return b(v, 2);\n    }\n    /**\n     *  Return a new ``bytes3`` type for %%v%%.\n     */ static bytes3(v) {\n        return b(v, 3);\n    }\n    /**\n     *  Return a new ``bytes4`` type for %%v%%.\n     */ static bytes4(v) {\n        return b(v, 4);\n    }\n    /**\n     *  Return a new ``bytes5`` type for %%v%%.\n     */ static bytes5(v) {\n        return b(v, 5);\n    }\n    /**\n     *  Return a new ``bytes6`` type for %%v%%.\n     */ static bytes6(v) {\n        return b(v, 6);\n    }\n    /**\n     *  Return a new ``bytes7`` type for %%v%%.\n     */ static bytes7(v) {\n        return b(v, 7);\n    }\n    /**\n     *  Return a new ``bytes8`` type for %%v%%.\n     */ static bytes8(v) {\n        return b(v, 8);\n    }\n    /**\n     *  Return a new ``bytes9`` type for %%v%%.\n     */ static bytes9(v) {\n        return b(v, 9);\n    }\n    /**\n     *  Return a new ``bytes10`` type for %%v%%.\n     */ static bytes10(v) {\n        return b(v, 10);\n    }\n    /**\n     *  Return a new ``bytes11`` type for %%v%%.\n     */ static bytes11(v) {\n        return b(v, 11);\n    }\n    /**\n     *  Return a new ``bytes12`` type for %%v%%.\n     */ static bytes12(v) {\n        return b(v, 12);\n    }\n    /**\n     *  Return a new ``bytes13`` type for %%v%%.\n     */ static bytes13(v) {\n        return b(v, 13);\n    }\n    /**\n     *  Return a new ``bytes14`` type for %%v%%.\n     */ static bytes14(v) {\n        return b(v, 14);\n    }\n    /**\n     *  Return a new ``bytes15`` type for %%v%%.\n     */ static bytes15(v) {\n        return b(v, 15);\n    }\n    /**\n     *  Return a new ``bytes16`` type for %%v%%.\n     */ static bytes16(v) {\n        return b(v, 16);\n    }\n    /**\n     *  Return a new ``bytes17`` type for %%v%%.\n     */ static bytes17(v) {\n        return b(v, 17);\n    }\n    /**\n     *  Return a new ``bytes18`` type for %%v%%.\n     */ static bytes18(v) {\n        return b(v, 18);\n    }\n    /**\n     *  Return a new ``bytes19`` type for %%v%%.\n     */ static bytes19(v) {\n        return b(v, 19);\n    }\n    /**\n     *  Return a new ``bytes20`` type for %%v%%.\n     */ static bytes20(v) {\n        return b(v, 20);\n    }\n    /**\n     *  Return a new ``bytes21`` type for %%v%%.\n     */ static bytes21(v) {\n        return b(v, 21);\n    }\n    /**\n     *  Return a new ``bytes22`` type for %%v%%.\n     */ static bytes22(v) {\n        return b(v, 22);\n    }\n    /**\n     *  Return a new ``bytes23`` type for %%v%%.\n     */ static bytes23(v) {\n        return b(v, 23);\n    }\n    /**\n     *  Return a new ``bytes24`` type for %%v%%.\n     */ static bytes24(v) {\n        return b(v, 24);\n    }\n    /**\n     *  Return a new ``bytes25`` type for %%v%%.\n     */ static bytes25(v) {\n        return b(v, 25);\n    }\n    /**\n     *  Return a new ``bytes26`` type for %%v%%.\n     */ static bytes26(v) {\n        return b(v, 26);\n    }\n    /**\n     *  Return a new ``bytes27`` type for %%v%%.\n     */ static bytes27(v) {\n        return b(v, 27);\n    }\n    /**\n     *  Return a new ``bytes28`` type for %%v%%.\n     */ static bytes28(v) {\n        return b(v, 28);\n    }\n    /**\n     *  Return a new ``bytes29`` type for %%v%%.\n     */ static bytes29(v) {\n        return b(v, 29);\n    }\n    /**\n     *  Return a new ``bytes30`` type for %%v%%.\n     */ static bytes30(v) {\n        return b(v, 30);\n    }\n    /**\n     *  Return a new ``bytes31`` type for %%v%%.\n     */ static bytes31(v) {\n        return b(v, 31);\n    }\n    /**\n     *  Return a new ``bytes32`` type for %%v%%.\n     */ static bytes32(v) {\n        return b(v, 32);\n    }\n    /**\n     *  Return a new ``address`` type for %%v%%.\n     */ static address(v) {\n        return new Typed(_gaurd, \"address\", v);\n    }\n    /**\n     *  Return a new ``bool`` type for %%v%%.\n     */ static bool(v) {\n        return new Typed(_gaurd, \"bool\", !!v);\n    }\n    /**\n     *  Return a new ``bytes`` type for %%v%%.\n     */ static bytes(v) {\n        return new Typed(_gaurd, \"bytes\", v);\n    }\n    /**\n     *  Return a new ``string`` type for %%v%%.\n     */ static string(v) {\n        return new Typed(_gaurd, \"string\", v);\n    }\n    /**\n     *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.\n     */ static array(v, dynamic) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"array\", v, dynamic);\n    }\n    /**\n     *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.\n     */ static tuple(v, name) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"tuple\", v, name);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */ static overrides(v) {\n        return new Typed(_gaurd, \"overrides\", Object.assign({}, v));\n    }\n    /**\n     *  Returns true only if %%value%% is a [[Typed]] instance.\n     */ static isTyped(value) {\n        return value && typeof value === \"object\" && \"_typedSymbol\" in value && value._typedSymbol === _typedSymbol;\n    }\n    /**\n     *  If the value is a [[Typed]] instance, validates the underlying value\n     *  and returns it, otherwise returns value directly.\n     *\n     *  This is useful for functions that with to accept either a [[Typed]]\n     *  object or values.\n     */ static dereference(value, type) {\n        if (Typed.isTyped(value)) {\n            if (value.type !== type) {\n                throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);\n            }\n            return value.value;\n        }\n        return value;\n    }\n} //# sourceMappingURL=typed.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL3R5cGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDbUU7QUFDcEUsTUFBTUUsU0FBUyxDQUFDO0FBQ2hCLFNBQVNDLEVBQUVDLEtBQUssRUFBRUMsS0FBSztJQUNuQixJQUFJQyxTQUFTO0lBQ2IsSUFBSUQsUUFBUSxHQUFHO1FBQ1hDLFNBQVM7UUFDVEQsU0FBUyxDQUFDO0lBQ2Q7SUFDQSx3Q0FBd0M7SUFDeEMsT0FBTyxJQUFJRSxNQUFNTCxRQUFRLENBQUMsRUFBRUksU0FBUyxLQUFLLElBQUksR0FBRyxFQUFFRCxNQUFNLENBQUMsRUFBRUQsT0FBTztRQUFFRTtRQUFRRDtJQUFNO0FBQ3ZGO0FBQ0EsU0FBU0csRUFBRUosS0FBSyxFQUFFSyxJQUFJO0lBQ2xCLHdDQUF3QztJQUN4QyxPQUFPLElBQUlGLE1BQU1MLFFBQVEsQ0FBQyxLQUFLLEVBQUUsT0FBU08sT0FBTyxHQUFHLENBQUMsRUFBRUwsT0FBTztRQUFFSztJQUFLO0FBQ3pFO0FBQ0EsTUFBTUMsZUFBZUMsT0FBT0MsR0FBRyxDQUFDO0FBQ2hDOztDQUVDLEdBQ00sTUFBTUw7SUFTVCxDQUFDTSxPQUFPLENBQUM7SUFLVDs7S0FFQyxHQUNEQyxZQUFZQyxLQUFLLEVBQUVDLElBQUksRUFBRVosS0FBSyxFQUFFUyxPQUFPLENBQUU7UUFDckMsSUFBSUEsV0FBVyxNQUFNO1lBQ2pCQSxVQUFVO1FBQ2Q7UUFDQWIsOERBQWFBLENBQUNFLFFBQVFhLE9BQU87UUFDN0JkLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRVM7WUFBY007WUFBTVo7UUFBTTtRQUNuRCxJQUFJLENBQUMsQ0FBQ1MsT0FBTyxHQUFHQTtRQUNoQiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDSSxNQUFNO0lBQ2Y7SUFDQTs7S0FFQyxHQUNEQSxTQUFTO1FBQ0wsSUFBSSxJQUFJLENBQUNELElBQUksS0FBSyxTQUFTO1lB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QkFDckIsTUFBTSxJQUFJRSxNQUFNLENBQUMsdUJBQXVCLEVBQUVGLEtBQUssTUFBTSxFQUFFWixNQUFNWSxJQUFJLENBQUMsQ0FBQztZQUN2RTtZQUNBLE9BQU9aLE1BQU1BLEtBQUs7UUFDdEI7UUFDQSxPQUFPQTtJQUNYO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95aWQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWJpL3R5cGVkLmpzPzJkZTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQSBUeXBlZCBvYmplY3QgYWxsb3dzIGEgdmFsdWUgdG8gaGF2ZSBpdHMgdHlwZSBleHBsaWNpdGx5XG4gKiAgc3BlY2lmaWVkLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaW4gU29saWRpdHksIHRoZSB2YWx1ZSBgYDQ1YGAgY291bGQgcmVwcmVzZW50IGFcbiAqICBgYHVpbnQ4YGAgb3IgYSBgYHVpbnQyNTZgYC4gVGhlIHZhbHVlIGBgMHgxMjM0YGAgY291bGQgcmVwcmVzZW50XG4gKiAgYSBgYGJ5dGVzMmBgIG9yIGBgYnl0ZXNgYC5cbiAqXG4gKiAgU2luY2UgSmF2YVNjcmlwdCBoYXMgbm8gbWVhbmluZ2Z1bCB3YXkgdG8gZXhwbGljaXRseSBpbmZvcm0gYW55XG4gKiAgQVBJcyB3aGljaCB3aGF0IHRoZSB0eXBlIGlzLCB0aGlzIGFsbG93cyB0cmFuc3BhcmVudCBpbnRlcm9wZXJhdGlvblxuICogIHdpdGggU29sZGl0eS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvYWJpOlR5cGVkIFZhbHVlc1xuICovXG5pbXBvcnQgeyBhc3NlcnRQcml2YXRlLCBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5jb25zdCBfZ2F1cmQgPSB7fTtcbmZ1bmN0aW9uIG4odmFsdWUsIHdpZHRoKSB7XG4gICAgbGV0IHNpZ25lZCA9IGZhbHNlO1xuICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgd2lkdGggKj0gLTE7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBDaGVjayByYW5nZSBpcyB2YWxpZCBmb3IgdmFsdWVcbiAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgYCR7c2lnbmVkID8gXCJcIiA6IFwidVwifWludCR7d2lkdGh9YCwgdmFsdWUsIHsgc2lnbmVkLCB3aWR0aCB9KTtcbn1cbmZ1bmN0aW9uIGIodmFsdWUsIHNpemUpIHtcbiAgICAvLyBAVE9ETzogQ2hlY2sgcmFuZ2UgaXMgdmFsaWQgZm9yIHZhbHVlXG4gICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIGBieXRlcyR7KHNpemUpID8gc2l6ZSA6IFwiXCJ9YCwgdmFsdWUsIHsgc2l6ZSB9KTtcbn1cbmNvbnN0IF90eXBlZFN5bWJvbCA9IFN5bWJvbC5mb3IoXCJfZXRoZXJzX3R5cGVkXCIpO1xuLyoqXG4gKiAgVGhlICoqVHlwZWQqKiBjbGFzcyB0byB3cmFwIHZhbHVlcyBwcm92aWRpbmcgZXhwbGljaXQgdHlwZSBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFR5cGVkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHR5cGUsIGFzIGEgU29saWRpdHktY29tcGF0aWJsZSB0eXBlLlxuICAgICAqL1xuICAgIHR5cGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgdmFsdWUuXG4gICAgICovXG4gICAgdmFsdWU7XG4gICAgI29wdGlvbnM7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIF90eXBlZFN5bWJvbDtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2F1cmQsIHR5cGUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFByaXZhdGUoX2dhdXJkLCBnYXVyZCwgXCJUeXBlZFwiKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IF90eXBlZFN5bWJvbCwgdHlwZSwgdmFsdWUgfSk7XG4gICAgICAgIHRoaXMuI29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAvLyBDaGVjayB0aGUgdmFsdWUgaXMgdmFsaWRcbiAgICAgICAgdGhpcy5mb3JtYXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEZvcm1hdCB0aGUgdHlwZSBhcyBhIEh1bWFuLVJlYWRhYmxlIHR5cGUuXG4gICAgICovXG4gICAgZm9ybWF0KCkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwiZHluYW1pY0FycmF5XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIGB0dXBsZSgke3RoaXMudmFsdWUubWFwKCh2KSA9PiB2LmZvcm1hdCgpKS5qb2luKFwiLFwiKX0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuZWQgYnkgdGhpcyB0eXBlLlxuICAgICAqL1xuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWluaW11bSB2YWx1ZSBmb3IgbnVtZXJpYyB0eXBlcy5cbiAgICAgKi9cbiAgICBtaW5WYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB2YWx1ZSBmb3IgbnVtZXJpYyB0eXBlcy5cbiAgICAgKi9cbiAgICBtYXhWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaXMgdGhpcyBpcyBhIFtbVHlwZWRCaWdJbnRdXS5cbiAgICAgKi9cbiAgICBpc0JpZ0ludCgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMudHlwZS5tYXRjaCgvXnU/aW50WzAtOV0rJC8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpcyB0aGlzIGlzIGEgW1tUeXBlZERhdGFdXS5cbiAgICAgKi9cbiAgICBpc0RhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuc3RhcnRzV2l0aChcImJ5dGVzXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlzIHRoaXMgaXMgYSBbW1R5cGVkU3RyaW5nXV0uXG4gICAgICovXG4gICAgaXNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSBcInN0cmluZ1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHR1cGxlIG5hbWUsIGlmIHRoaXMgaXMgYSB0dXBsZS4gVGhyb3dzIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgdHVwbGVOYW1lKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIm5vdCBhIHR1cGxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNvcHRpb25zO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhpcyB0eXBlIGFzIGFuIGFycmF5XG4gICAgLy8gLSBgbnVsbGAgaW5kaWNhdGVzIHRoZSBsZW5ndGggaXMgdW5mb3JjZWQsIGl0IGNvdWxkIGJlIGR5bmFtaWNcbiAgICAvLyAtIGAtMWAgaW5kaWNhdGVzIHRoZSBsZW5ndGggaXMgZHluYW1pY1xuICAgIC8vIC0gYW55IG90aGVyIHZhbHVlIGluZGljYXRlcyBpdCBpcyBhIHN0YXRpYyBhcnJheSBhbmQgaXMgaXRzIGxlbmd0aFxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IHR5cGUgb3IgYGAtMWBgIGlmIGl0IGlzIGR5bmFtaWMuXG4gICAgICpcbiAgICAgKiAgVGhyb3dzIGlmIHRoZSB0eXBlIGlzIG5vdCBhbiBhcnJheS5cbiAgICAgKi9cbiAgICBnZXQgYXJyYXlMZW5ndGgoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI29wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipUeXBlZCoqIG9mICUldHlwZSUlIHdpdGggdGhlICUldmFsdWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0eXBlLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgdHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDgodikgeyByZXR1cm4gbih2LCA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE2KHYpIHsgcmV0dXJuIG4odiwgMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjQodikgeyByZXR1cm4gbih2LCAyNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQzMih2KSB7IHJldHVybiBuKHYsIDMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDQwKHYpIHsgcmV0dXJuIG4odiwgNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NDgodikgeyByZXR1cm4gbih2LCA0OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ1Nih2KSB7IHJldHVybiBuKHYsIDU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDY0KHYpIHsgcmV0dXJuIG4odiwgNjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ3MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NzIodikgeyByZXR1cm4gbih2LCA3Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDgwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ4MCh2KSB7IHJldHVybiBuKHYsIDgwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50ODhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDg4KHYpIHsgcmV0dXJuIG4odiwgODgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ5NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50OTYodikgeyByZXR1cm4gbih2LCA5Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEwNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTA0KHYpIHsgcmV0dXJuIG4odiwgMTA0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTEyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMTIodikgeyByZXR1cm4gbih2LCAxMTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDEyMCh2KSB7IHJldHVybiBuKHYsIDEyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEyOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTI4KHYpIHsgcmV0dXJuIG4odiwgMTI4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTM2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMzYodikgeyByZXR1cm4gbih2LCAxMzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE0NCh2KSB7IHJldHVybiBuKHYsIDE0NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE1MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTUyKHYpIHsgcmV0dXJuIG4odiwgMTUyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTYwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNjAodikgeyByZXR1cm4gbih2LCAxNjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE2OCh2KSB7IHJldHVybiBuKHYsIDE2OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE3NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTc2KHYpIHsgcmV0dXJuIG4odiwgMTc2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTg0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxODQodikgeyByZXR1cm4gbih2LCAxODQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxOTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE5Mih2KSB7IHJldHVybiBuKHYsIDE5Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIwMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjAwKHYpIHsgcmV0dXJuIG4odiwgMjAwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjA4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMDgodikgeyByZXR1cm4gbih2LCAyMDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIxNih2KSB7IHJldHVybiBuKHYsIDIxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjI0KHYpIHsgcmV0dXJuIG4odiwgMjI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMzIodikgeyByZXR1cm4gbih2LCAyMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDI0MCh2KSB7IHJldHVybiBuKHYsIDI0MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjQ4KHYpIHsgcmV0dXJuIG4odiwgMjQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNTYodikgeyByZXR1cm4gbih2LCAyNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludCh2KSB7IHJldHVybiBuKHYsIDI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ4KHYpIHsgcmV0dXJuIG4odiwgLTgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE2KHYpIHsgcmV0dXJuIG4odiwgLTE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNCh2KSB7IHJldHVybiBuKHYsIC0yNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MzIodikgeyByZXR1cm4gbih2LCAtMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDQwKHYpIHsgcmV0dXJuIG4odiwgLTQwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ0OCh2KSB7IHJldHVybiBuKHYsIC00OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NTYodikgeyByZXR1cm4gbih2LCAtNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDY0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDY0KHYpIHsgcmV0dXJuIG4odiwgLTY0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ3MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ3Mih2KSB7IHJldHVybiBuKHYsIC03Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50ODBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ODAodikgeyByZXR1cm4gbih2LCAtODApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDg4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDg4KHYpIHsgcmV0dXJuIG4odiwgLTg4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ5NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ5Nih2KSB7IHJldHVybiBuKHYsIC05Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTA0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEwNCh2KSB7IHJldHVybiBuKHYsIC0xMDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDExMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMTIodikgeyByZXR1cm4gbih2LCAtMTEyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMjBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTIwKHYpIHsgcmV0dXJuIG4odiwgLTEyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTI4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEyOCh2KSB7IHJldHVybiBuKHYsIC0xMjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDEzNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMzYodikgeyByZXR1cm4gbih2LCAtMTM2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTQ0KHYpIHsgcmV0dXJuIG4odiwgLTE0NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTUyKHYpIHsgcmV0dXJuIG4odiwgLTE1Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTYwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE2MCh2KSB7IHJldHVybiBuKHYsIC0xNjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE2OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNjgodikgeyByZXR1cm4gbih2LCAtMTY4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNzZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTc2KHYpIHsgcmV0dXJuIG4odiwgLTE3Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTg0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE4NCh2KSB7IHJldHVybiBuKHYsIC0xODQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDkyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE5Mih2KSB7IHJldHVybiBuKHYsIC0xOTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIwMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMDAodikgeyByZXR1cm4gbih2LCAtMjAwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjA4KHYpIHsgcmV0dXJuIG4odiwgLTIwOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIxNih2KSB7IHJldHVybiBuKHYsIC0yMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMjQodikgeyByZXR1cm4gbih2LCAtMjI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjMyKHYpIHsgcmV0dXJuIG4odiwgLTIzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI0MCh2KSB7IHJldHVybiBuKHYsIC0yNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI0OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNDgodikgeyByZXR1cm4gbih2LCAtMjQ4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjU2KHYpIHsgcmV0dXJuIG4odiwgLTI1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludCh2KSB7IHJldHVybiBuKHYsIC0yNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEodikgeyByZXR1cm4gYih2LCAxKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyKHYpIHsgcmV0dXJuIGIodiwgMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMyh2KSB7IHJldHVybiBiKHYsIDMpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczQodikgeyByZXR1cm4gYih2LCA0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczVgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM1KHYpIHsgcmV0dXJuIGIodiwgNSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNih2KSB7IHJldHVybiBiKHYsIDYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzN2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczcodikgeyByZXR1cm4gYih2LCA3KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM4KHYpIHsgcmV0dXJuIGIodiwgOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM5YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzOSh2KSB7IHJldHVybiBiKHYsIDkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMCh2KSB7IHJldHVybiBiKHYsIDEwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczExYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTEodikgeyByZXR1cm4gYih2LCAxMSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczEyKHYpIHsgcmV0dXJuIGIodiwgMTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMyh2KSB7IHJldHVybiBiKHYsIDEzKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTQodikgeyByZXR1cm4gYih2LCAxNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxNWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE1KHYpIHsgcmV0dXJuIGIodiwgMTUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNih2KSB7IHJldHVybiBiKHYsIDE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE3YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTcodikgeyByZXR1cm4gYih2LCAxNyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE4KHYpIHsgcmV0dXJuIGIodiwgMTgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTlgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxOSh2KSB7IHJldHVybiBiKHYsIDE5KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjAodikgeyByZXR1cm4gYih2LCAyMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIxKHYpIHsgcmV0dXJuIGIodiwgMjEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMih2KSB7IHJldHVybiBiKHYsIDIyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjModikgeyByZXR1cm4gYih2LCAyMyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI0KHYpIHsgcmV0dXJuIGIodiwgMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjVgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyNSh2KSB7IHJldHVybiBiKHYsIDI1KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjYodikgeyByZXR1cm4gYih2LCAyNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyN2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI3KHYpIHsgcmV0dXJuIGIodiwgMjcpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyOCh2KSB7IHJldHVybiBiKHYsIDI4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI5YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjkodikgeyByZXR1cm4gYih2LCAyOSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczMwKHYpIHsgcmV0dXJuIGIodiwgMzApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMzFgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzMSh2KSB7IHJldHVybiBiKHYsIDMxKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMzIodikgeyByZXR1cm4gYih2LCAzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYWRkcmVzc2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRyZXNzKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwiYWRkcmVzc1wiLCB2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBib29sYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJvb2wodikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJib29sXCIsICEhdik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXNgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXModikgeyByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJieXRlc1wiLCB2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBzdHJpbmdgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaW5nKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwic3RyaW5nXCIsIHYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGFycmF5YGAgdHlwZSBmb3IgJSV2JSUsIGFsbG93aW5nICUlZHluYW1pYyUlIGxlbmd0aC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJyYXkodiwgZHluYW1pYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJhcnJheVwiLCB2LCBkeW5hbWljKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHR1cGxlYGAgdHlwZSBmb3IgJSV2JSUsIHdpdGggdGhlIG9wdGlvbmFsICUlbmFtZSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB0dXBsZSh2LCBuYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcInR1cGxlXCIsIHYsIG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgb3ZlcnJpZGVzKHYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwib3ZlcnJpZGVzXCIsIE9iamVjdC5hc3NpZ24oe30sIHYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBvbmx5IGlmICUldmFsdWUlJSBpcyBhIFtbVHlwZWRdXSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNUeXBlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlXG4gICAgICAgICAgICAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgJiYgXCJfdHlwZWRTeW1ib2xcIiBpbiB2YWx1ZVxuICAgICAgICAgICAgJiYgdmFsdWUuX3R5cGVkU3ltYm9sID09PSBfdHlwZWRTeW1ib2wpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIHZhbHVlIGlzIGEgW1tUeXBlZF1dIGluc3RhbmNlLCB2YWxpZGF0ZXMgdGhlIHVuZGVybHlpbmcgdmFsdWVcbiAgICAgKiAgYW5kIHJldHVybnMgaXQsIG90aGVyd2lzZSByZXR1cm5zIHZhbHVlIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdXNlZnVsIGZvciBmdW5jdGlvbnMgdGhhdCB3aXRoIHRvIGFjY2VwdCBlaXRoZXIgYSBbW1R5cGVkXV1cbiAgICAgKiAgb2JqZWN0IG9yIHZhbHVlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVyZWZlcmVuY2UodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgaWYgKFR5cGVkLmlzVHlwZWQodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0eXBlOiBleHBlY2V0ZCAke3R5cGV9LCBnb3QgJHt2YWx1ZS50eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlZC5qcy5tYXAiXSwibmFtZXMiOlsiYXNzZXJ0UHJpdmF0ZSIsImRlZmluZVByb3BlcnRpZXMiLCJfZ2F1cmQiLCJuIiwidmFsdWUiLCJ3aWR0aCIsInNpZ25lZCIsIlR5cGVkIiwiYiIsInNpemUiLCJfdHlwZWRTeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJvcHRpb25zIiwiY29uc3RydWN0b3IiLCJnYXVyZCIsInR5cGUiLCJmb3JtYXQiLCJFcnJvciIsIm1hcCIsInYiLCJqb2luIiwiZGVmYXVsdFZhbHVlIiwibWluVmFsdWUiLCJtYXhWYWx1ZSIsImlzQmlnSW50IiwibWF0Y2giLCJpc0RhdGEiLCJzdGFydHNXaXRoIiwiaXNTdHJpbmciLCJ0dXBsZU5hbWUiLCJUeXBlRXJyb3IiLCJhcnJheUxlbmd0aCIsImxlbmd0aCIsImZyb20iLCJ1aW50OCIsInVpbnQxNiIsInVpbnQyNCIsInVpbnQzMiIsInVpbnQ0MCIsInVpbnQ0OCIsInVpbnQ1NiIsInVpbnQ2NCIsInVpbnQ3MiIsInVpbnQ4MCIsInVpbnQ4OCIsInVpbnQ5NiIsInVpbnQxMDQiLCJ1aW50MTEyIiwidWludDEyMCIsInVpbnQxMjgiLCJ1aW50MTM2IiwidWludDE0NCIsInVpbnQxNTIiLCJ1aW50MTYwIiwidWludDE2OCIsInVpbnQxNzYiLCJ1aW50MTg0IiwidWludDE5MiIsInVpbnQyMDAiLCJ1aW50MjA4IiwidWludDIxNiIsInVpbnQyMjQiLCJ1aW50MjMyIiwidWludDI0MCIsInVpbnQyNDgiLCJ1aW50MjU2IiwidWludCIsImludDgiLCJpbnQxNiIsImludDI0IiwiaW50MzIiLCJpbnQ0MCIsImludDQ4IiwiaW50NTYiLCJpbnQ2NCIsImludDcyIiwiaW50ODAiLCJpbnQ4OCIsImludDk2IiwiaW50MTA0IiwiaW50MTEyIiwiaW50MTIwIiwiaW50MTI4IiwiaW50MTM2IiwiaW50MTQ0IiwiaW50MTUyIiwiaW50MTYwIiwiaW50MTY4IiwiaW50MTc2IiwiaW50MTg0IiwiaW50MTkyIiwiaW50MjAwIiwiaW50MjA4IiwiaW50MjE2IiwiaW50MjI0IiwiaW50MjMyIiwiaW50MjQwIiwiaW50MjQ4IiwiaW50MjU2IiwiaW50IiwiYnl0ZXMxIiwiYnl0ZXMyIiwiYnl0ZXMzIiwiYnl0ZXM0IiwiYnl0ZXM1IiwiYnl0ZXM2IiwiYnl0ZXM3IiwiYnl0ZXM4IiwiYnl0ZXM5IiwiYnl0ZXMxMCIsImJ5dGVzMTEiLCJieXRlczEyIiwiYnl0ZXMxMyIsImJ5dGVzMTQiLCJieXRlczE1IiwiYnl0ZXMxNiIsImJ5dGVzMTciLCJieXRlczE4IiwiYnl0ZXMxOSIsImJ5dGVzMjAiLCJieXRlczIxIiwiYnl0ZXMyMiIsImJ5dGVzMjMiLCJieXRlczI0IiwiYnl0ZXMyNSIsImJ5dGVzMjYiLCJieXRlczI3IiwiYnl0ZXMyOCIsImJ5dGVzMjkiLCJieXRlczMwIiwiYnl0ZXMzMSIsImJ5dGVzMzIiLCJhZGRyZXNzIiwiYm9vbCIsImJ5dGVzIiwic3RyaW5nIiwiYXJyYXkiLCJkeW5hbWljIiwidHVwbGUiLCJuYW1lIiwib3ZlcnJpZGVzIiwiT2JqZWN0IiwiYXNzaWduIiwiaXNUeXBlZCIsImRlcmVmZXJlbmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/address/address.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/address/address.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAddress: () => (/* binding */ getAddress),\n/* harmony export */   getIcapAddress: () => (/* binding */ getIcapAddress)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n\n\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\nfunction getChecksumAddress(address) {\n    //    if (!isHexString(address, 20)) {\n    //        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    //    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for(let i = 0; i < 40; i++){\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.getBytes)((0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_1__.keccak256)(expanded));\n    for(let i = 0; i < 40; i += 2){\n        if (hashed[i >> 1] >> 4 >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor(let i = 0; i < 10; i++){\n    ibanLookup[String(i)] = String(i);\n}\nfor(let i = 0; i < 26; i++){\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c)=>{\n        return ibanLookup[c];\n    }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while(expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - parseInt(expanded, 10) % 97);\n    while(checksum.length < 2){\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nconst Base36 = function() {\n    ;\n    const result = {};\n    for(let i = 0; i < 36; i++){\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n        result[key] = BigInt(i);\n    }\n    return result;\n}();\nfunction fromBase36(value) {\n    value = value.toLowerCase();\n    let result = BN_0;\n    for(let i = 0; i < value.length; i++){\n        result = result * BN_36 + Base36[value[i]];\n    }\n    return result;\n}\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */ function getAddress(address) {\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(typeof address === \"string\", \"invalid address\", \"address\", address);\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) {\n            address = \"0x\" + address;\n        }\n        const result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, \"bad address checksum\", \"address\", address);\n        return result;\n    }\n    // Maybe ICAP? (we only support direct mode)\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n        let result = fromBase36(address.substring(4)).toString(16);\n        while(result.length < 40){\n            result = \"0\" + result;\n        }\n        return getChecksumAddress(\"0x\" + result);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assertArgument)(false, \"invalid address\", \"address\", address);\n}\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */ function getIcapAddress(address) {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while(base36.length < 30){\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n} //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQStDO0FBQ2M7QUFDN0QsTUFBTUcsT0FBT0MsT0FBTztBQUNwQixNQUFNQyxRQUFRRCxPQUFPO0FBQ3JCLFNBQVNFLG1CQUFtQkMsT0FBTztJQUMvQixzQ0FBc0M7SUFDdEMsMkVBQTJFO0lBQzNFLE9BQU87SUFDUEEsVUFBVUEsUUFBUUMsV0FBVztJQUM3QixNQUFNQyxRQUFRRixRQUFRRyxTQUFTLENBQUMsR0FBR0MsS0FBSyxDQUFDO0lBQ3pDLE1BQU1DLFdBQVcsSUFBSUMsV0FBVztJQUNoQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO1FBQ3pCRixRQUFRLENBQUNFLEVBQUUsR0FBR0wsS0FBSyxDQUFDSyxFQUFFLENBQUNDLFVBQVUsQ0FBQztJQUN0QztJQUNBLE1BQU1DLFNBQVNmLHlEQUFRQSxDQUFDRCwyREFBU0EsQ0FBQ1k7SUFDbEMsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUksSUFBSUEsS0FBSyxFQUFHO1FBQzVCLElBQUksTUFBTyxDQUFDQSxLQUFLLEVBQUUsSUFBSSxLQUFNLEdBQUc7WUFDNUJMLEtBQUssQ0FBQ0ssRUFBRSxHQUFHTCxLQUFLLENBQUNLLEVBQUUsQ0FBQ0csV0FBVztRQUNuQztRQUNBLElBQUksQ0FBQ0QsTUFBTSxDQUFDRixLQUFLLEVBQUUsR0FBRyxJQUFHLEtBQU0sR0FBRztZQUM5QkwsS0FBSyxDQUFDSyxJQUFJLEVBQUUsR0FBR0wsS0FBSyxDQUFDSyxJQUFJLEVBQUUsQ0FBQ0csV0FBVztRQUMzQztJQUNKO0lBQ0EsT0FBTyxPQUFPUixNQUFNUyxJQUFJLENBQUM7QUFDN0I7QUFDQSx1RUFBdUU7QUFDdkUsc0JBQXNCO0FBQ3RCLE1BQU1DLGFBQWEsQ0FBQztBQUNwQixJQUFLLElBQUlMLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO0lBQ3pCSyxV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ZWhDLE9BQU87SUFDbEMsMkVBQTJFO0lBQzNFLElBQUlpQyxTQUFTcEMsT0FBTytCLFdBQVc1QixVQUFVK0IsUUFBUSxDQUFDLElBQUlyQixXQUFXO0lBQ2pFLE1BQU91QixPQUFPZCxNQUFNLEdBQUcsR0FBSTtRQUN2QmMsU0FBUyxNQUFNQTtJQUNuQjtJQUNBLE9BQU8sT0FBT2pCLGFBQWEsU0FBU2lCLFVBQVVBO0FBQ2xELEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veWlkLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2FkZHJlc3MvYWRkcmVzcy5qcz9hMTk3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCIuLi9jcnlwdG8vaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzM2ID0gQmlnSW50KDM2KTtcbmZ1bmN0aW9uIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgLy8gICAgaWYgKCFpc0hleFN0cmluZyhhZGRyZXNzLCAyMCkpIHtcbiAgICAvLyAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgLy8gICAgfVxuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY2hhcnMgPSBhZGRyZXNzLnN1YnN0cmluZygyKS5zcGxpdChcIlwiKTtcbiAgICBjb25zdCBleHBhbmRlZCA9IG5ldyBVaW50OEFycmF5KDQwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpKyspIHtcbiAgICAgICAgZXhwYW5kZWRbaV0gPSBjaGFyc1tpXS5jaGFyQ29kZUF0KDApO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZWQgPSBnZXRCeXRlcyhrZWNjYWsyNTYoZXhwYW5kZWQpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSA+PiA0KSA+PSA4KSB7XG4gICAgICAgICAgICBjaGFyc1tpXSA9IGNoYXJzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSAmIDB4MGYpID49IDgpIHtcbiAgICAgICAgICAgIGNoYXJzW2kgKyAxXSA9IGNoYXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBjaGFycy5qb2luKFwiXCIpO1xufVxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcm5hdGlvbmFsX0JhbmtfQWNjb3VudF9OdW1iZXJcbi8vIENyZWF0ZSBsb29rdXAgdGFibGVcbmNvbnN0IGliYW5Mb29rdXAgPSB7fTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nKGkpXSA9IFN0cmluZyhpKTtcbn1cbmZvciAobGV0IGkgPSAwOyBpIDwgMjY7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIGkpXSA9IFN0cmluZygxMCArIGkpO1xufVxuLy8gSG93IG1hbnkgZGVjaW1hbCBkaWdpdHMgY2FuIHdlIHByb2Nlc3M/IChmb3IgNjQtYml0IGZsb2F0LCB0aGlzIGlzIDE1KVxuLy8gaS5lLiBNYXRoLmZsb29yKE1hdGgubG9nMTAoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKTtcbmNvbnN0IHNhZmVEaWdpdHMgPSAxNTtcbmZ1bmN0aW9uIGliYW5DaGVja3N1bShhZGRyZXNzKSB7XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9VcHBlckNhc2UoKTtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy5zdWJzdHJpbmcoNCkgKyBhZGRyZXNzLnN1YnN0cmluZygwLCAyKSArIFwiMDBcIjtcbiAgICBsZXQgZXhwYW5kZWQgPSBhZGRyZXNzLnNwbGl0KFwiXCIpLm1hcCgoYykgPT4geyByZXR1cm4gaWJhbkxvb2t1cFtjXTsgfSkuam9pbihcIlwiKTtcbiAgICAvLyBKYXZhc2NyaXB0IGNhbiBoYW5kbGUgaW50ZWdlcnMgc2FmZWx5IHVwIHRvIDE1IChkZWNpbWFsKSBkaWdpdHNcbiAgICB3aGlsZSAoZXhwYW5kZWQubGVuZ3RoID49IHNhZmVEaWdpdHMpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gZXhwYW5kZWQuc3Vic3RyaW5nKDAsIHNhZmVEaWdpdHMpO1xuICAgICAgICBleHBhbmRlZCA9IHBhcnNlSW50KGJsb2NrLCAxMCkgJSA5NyArIGV4cGFuZGVkLnN1YnN0cmluZyhibG9jay5sZW5ndGgpO1xuICAgIH1cbiAgICBsZXQgY2hlY2tzdW0gPSBTdHJpbmcoOTggLSAocGFyc2VJbnQoZXhwYW5kZWQsIDEwKSAlIDk3KSk7XG4gICAgd2hpbGUgKGNoZWNrc3VtLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgY2hlY2tzdW0gPSBcIjBcIiArIGNoZWNrc3VtO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tzdW07XG59XG47XG5jb25zdCBCYXNlMzYgPSAoZnVuY3Rpb24gKCkge1xuICAgIDtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM2OyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIltpXTtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBCaWdJbnQoaSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59KSgpO1xuZnVuY3Rpb24gZnJvbUJhc2UzNih2YWx1ZSkge1xuICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgcmVzdWx0ID0gQk5fMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCAqIEJOXzM2ICsgQmFzZTM2W3ZhbHVlW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBub3JtYWxpemVkIGFuZCBjaGVja3N1bWVkIGFkZHJlc3MgZm9yICUlYWRkcmVzcyUlLlxuICogIFRoaXMgYWNjZXB0cyBub24tY2hlY2tzdW0gYWRkcmVzc2VzLCBjaGVja3N1bSBhZGRyZXNzZXMgYW5kXG4gKiAgW1tnZXRJY2FwQWRkcmVzc11dIGZvcm1hdHMuXG4gKlxuICogIFRoZSBjaGVja3N1bSBpbiBFdGhlcmV1bSB1c2VzIHRoZSBjYXBpdGFsaXphdGlvbiAodXBwZXItY2FzZVxuICogIHZzIGxvd2VyLWNhc2UpIG9mIHRoZSBjaGFyYWN0ZXJzIHdpdGhpbiBhbiBhZGRyZXNzIHRvIGVuY29kZVxuICogIGl0cyBjaGVja3N1bSwgd2hpY2ggb2ZmZXJzLCBvbiBhdmVyYWdlLCBhIGNoZWNrc3VtIG9mIDE1LWJpdHMuXG4gKlxuICogIElmICUlYWRkcmVzcyUlIGNvbnRhaW5zIGJvdGggdXBwZXItY2FzZSBhbmQgbG93ZXItY2FzZSwgaXQgaXNcbiAqICBhc3N1bWVkIHRvIGFscmVhZHkgYmUgYSBjaGVja3N1bSBhZGRyZXNzIGFuZCBpdHMgY2hlY2tzdW0gaXNcbiAqICB2YWxpZGF0ZWQsIGFuZCBpZiB0aGUgYWRkcmVzcyBmYWlscyBpdHMgZXhwZWN0ZWQgY2hlY2tzdW0gYW5cbiAqICBlcnJvciBpcyB0aHJvd24uXG4gKlxuICogIElmIHlvdSB3aXNoIHRoZSBjaGVja3N1bSBvZiAlJWFkZHJlc3MlJSB0byBiZSBpZ25vcmUsIGl0IHNob3VsZFxuICogIGJlIGNvbnZlcnRlZCB0byBsb3dlci1jYXNlIChpLmUuIGBgLnRvTG93ZXJjYXNlKClgYCkgYmVmb3JlXG4gKiAgYmVpbmcgcGFzc2VkIGluLiBUaGlzIHNob3VsZCBiZSBhIHZlcnkgcmFyZSBzaXR1YXRpb24gdGhvdWdoLFxuICogIHRoYXQgeW91IHdpc2ggdG8gYnlwYXNzIHRoZSBzYWZlZ2F1cmRzIGluIHBsYWNlIHRvIHByb3RlY3RcbiAqICBhZ2FpbnN0IGFuIGFkZHJlc3MgdGhhdCBoYXMgYmVlbiBpbmNvcnJlY3RseSBjb3BpZWQgZnJvbSBhbm90aGVyXG4gKiAgc291cmNlLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIEFkZHMgdGhlIGNoZWNrc3VtICh2aWEgdXBwZXItY2FzaW5nIHNwZWNpZmljIGxldHRlcnMpXG4gKiAgICBnZXRBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJkNDMyODAzMDEyNjQ1YWMxMzZkZGQ2NGRiYTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gQ29udmVydHMgSUNBUCBhZGRyZXNzIGFuZCBhZGRzIGNoZWNrc3VtXG4gKiAgICBnZXRBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzZcIik7XG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFuIGFkZHJlc3MgY29udGFpbnMgbWl4ZWQgY2FzZSxcbiAqICAgIC8vIGJ1dCB0aGUgY2hlY2tzdW0gZmFpbHNcbiAqICAgIGdldEFkZHJlc3MoXCIweDhCYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChhZGRyZXNzKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXXs0MH0kLykpIHtcbiAgICAgICAgLy8gTWlzc2luZyB0aGUgMHggcHJlZml4XG4gICAgICAgIGlmICghYWRkcmVzcy5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBcIjB4XCIgKyBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgLy8gSXQgaXMgYSBjaGVja3N1bW1lZCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoIWFkZHJlc3MubWF0Y2goLyhbQS1GXS4qW2EtZl0pfChbYS1mXS4qW0EtRl0pLykgfHwgcmVzdWx0ID09PSBhZGRyZXNzLCBcImJhZCBhZGRyZXNzIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gTWF5YmUgSUNBUD8gKHdlIG9ubHkgc3VwcG9ydCBkaXJlY3QgbW9kZSlcbiAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXlhFWzAtOV17Mn1bMC05QS1aYS16XXszMCwzMX0kLykpIHtcbiAgICAgICAgLy8gSXQgaXMgYW4gSUNBUCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgYXNzZXJ0QXJndW1lbnQoYWRkcmVzcy5zdWJzdHJpbmcoMiwgNCkgPT09IGliYW5DaGVja3N1bShhZGRyZXNzKSwgXCJiYWQgaWNhcCBjaGVja3N1bVwiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBmcm9tQmFzZTM2KGFkZHJlc3Muc3Vic3RyaW5nKDQpKS50b1N0cmluZygxNik7XG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgNDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRDaGVja3N1bUFkZHJlc3MoXCIweFwiICsgcmVzdWx0KTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbn1cbi8qKlxuICogIFRoZSBbSUNBUCBBZGRyZXNzIGZvcm1hdF0obGluay1pY2FwKSBmb3JtYXQgaXMgYW4gZWFybHkgY2hlY2tzdW1cbiAqICBmb3JtYXQgd2hpY2ggYXR0ZW1wdHMgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBiYW5raW5nXG4gKiAgaW5kdXN0cnkgW0lCQU4gZm9ybWF0XShsaW5rLXdpa2ktaWJhbikgZm9yIGJhbmsgYWNjb3VudHMuXG4gKlxuICogIEl0IGlzIG5vIGxvbmdlciBjb21tb24gb3IgYSByZWNvbW1lbmRlZCBmb3JtYXQuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgZ2V0SWNhcEFkZHJlc3MoXCIweDhiYTFmMTA5NTUxYmQ0MzI4MDMwMTI2NDVhYzEzNmRkZDY0ZGJhNzJcIik7XG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgZ2V0SWNhcEFkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIElDQVAgY2hlY2tzdW0gaXMgd3JvbmdcbiAqICAgIGdldEljYXBBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzdcIik7XG4gKiAgICAvL19lcnJvcjpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEljYXBBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAvL2xldCBiYXNlMzYgPSBfYmFzZTE2VG8zNihnZXRBZGRyZXNzKGFkZHJlc3MpLnN1YnN0cmluZygyKSkudG9VcHBlckNhc2UoKTtcbiAgICBsZXQgYmFzZTM2ID0gQmlnSW50KGdldEFkZHJlc3MoYWRkcmVzcykpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHdoaWxlIChiYXNlMzYubGVuZ3RoIDwgMzApIHtcbiAgICAgICAgYmFzZTM2ID0gXCIwXCIgKyBiYXNlMzY7XG4gICAgfVxuICAgIHJldHVybiBcIlhFXCIgKyBpYmFuQ2hlY2tzdW0oXCJYRTAwXCIgKyBiYXNlMzYpICsgYmFzZTM2O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOlsia2VjY2FrMjU2IiwiZ2V0Qnl0ZXMiLCJhc3NlcnRBcmd1bWVudCIsIkJOXzAiLCJCaWdJbnQiLCJCTl8zNiIsImdldENoZWNrc3VtQWRkcmVzcyIsImFkZHJlc3MiLCJ0b0xvd2VyQ2FzZSIsImNoYXJzIiwic3Vic3RyaW5nIiwic3BsaXQiLCJleHBhbmRlZCIsIlVpbnQ4QXJyYXkiLCJpIiwiY2hhckNvZGVBdCIsImhhc2hlZCIsInRvVXBwZXJDYXNlIiwiam9pbiIsImliYW5Mb29rdXAiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzYWZlRGlnaXRzIiwiaWJhbkNoZWNrc3VtIiwibWFwIiwiYyIsImxlbmd0aCIsImJsb2NrIiwicGFyc2VJbnQiLCJjaGVja3N1bSIsIkJhc2UzNiIsInJlc3VsdCIsImtleSIsImZyb21CYXNlMzYiLCJ2YWx1ZSIsImdldEFkZHJlc3MiLCJtYXRjaCIsInN0YXJ0c1dpdGgiLCJ0b1N0cmluZyIsImdldEljYXBBZGRyZXNzIiwiYmFzZTM2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/address/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/address/checks.js":
/*!*******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/address/checks.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAddress: () => (/* binding */ isAddress),\n/* harmony export */   isAddressable: () => (/* binding */ isAddressable),\n/* harmony export */   resolveAddress: () => (/* binding */ resolveAddress)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./address.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n\n\n/**\n *  Returns true if %%value%% is an object which implements the\n *  [[Addressable]] interface.\n *\n *  @example:\n *    // Wallets and AbstractSigner sub-classes\n *    isAddressable(Wallet.createRandom())\n *    //_result:\n *\n *    // Contracts\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\n *    isAddressable(contract)\n *    //_result:\n */ function isAddressable(value) {\n    return value && typeof value.getAddress === \"function\";\n}\n/**\n *  Returns true if %%value%% is a valid address.\n *\n *  @example:\n *    // Valid address\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Valid ICAP address\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n *    //_result:\n *\n *    // Invalid checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n *    //_result:\n *\n *    // Invalid ICAP checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Not an address (an ENS name requires a provided and an\n *    // asynchronous API to access)\n *    isAddress(\"ricmoo.eth\")\n *    //_result:\n */ function isAddress(value) {\n    try {\n        (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(value);\n        return true;\n    } catch (error) {}\n    return false;\n}\nasync function checkAddress(target, promise) {\n    const result = await promise;\n    if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof target !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", {\n            value: target\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n    }\n    return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(result);\n}\n/**\n *  Resolves to an address for the %%target%%, which may be any\n *  supported address type, an [[Addressable]] or a Promise which\n *  resolves to an address.\n *\n *  If an ENS name is provided, but that name has not been correctly\n *  configured a [[UnconfiguredNameError]] is thrown.\n *\n *  @example:\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n *\n *    // Addresses are return synchronously\n *    resolveAddress(addr, provider)\n *    //_result:\n *\n *    // Address promises are resolved asynchronously\n *    resolveAddress(Promise.resolve(addr))\n *    //_result:\n *\n *    // ENS names are resolved asynchronously\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\n *    //_result:\n *\n *    // Addressable objects are resolved asynchronously\n *    contract = new Contract(addr, [ ])\n *    resolveAddress(contract, provider)\n *    //_result:\n *\n *    // Unconfigured ENS names reject\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\n *    //_error:\n *\n *    // ENS names require a NameResolver object passed in\n *    // (notice the provider was omitted)\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\n *    //_error:\n */ function resolveAddress(target, resolver) {\n    if (typeof target === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) {\n            return (0,_address_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(target);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assert)(resolver != null, \"ENS resolution requires a provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"resolveName\"\n        });\n        return checkAddress(target, resolver.resolveName(target));\n    } else if (isAddressable(target)) {\n        return checkAddress(target, target.getAddress());\n    } else if (target && typeof target.then === \"function\") {\n        return checkAddress(target, target);\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(false, \"unsupported addressable value\", \"target\", target);\n} //# sourceMappingURL=checks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vYWRkcmVzcy9jaGVja3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMkQ7QUFDakI7QUFDMUM7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNNLFNBQVNHLGNBQWNDLEtBQUs7SUFDL0IsT0FBUUEsU0FBUyxPQUFRQSxNQUFNRixVQUFVLEtBQU07QUFDbkQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBd0JDLEdBQ00sU0FBU0csVUFBVUQsS0FBSztJQUMzQixJQUFJO1FBQ0FGLHVEQUFVQSxDQUFDRTtRQUNYLE9BQU87SUFDWCxFQUNBLE9BQU9FLE9BQU8sQ0FBRTtJQUNoQixPQUFPO0FBQ1g7QUFDQSxlQUFlQyxhQUFhQyxNQUFNLEVBQUVDLE9BQU87SUFDdkMsTUFBTUMsU0FBUyxNQUFNRDtJQUNyQixJQUFJQyxVQUFVLFFBQVFBLFdBQVcsOENBQThDO1FBQzNFVix1REFBTUEsQ0FBQyxPQUFRUSxXQUFZLFVBQVUscUJBQXFCLHFCQUFxQjtZQUFFSixPQUFPSTtRQUFPO1FBQy9GUCwrREFBY0EsQ0FBQyxPQUFPLGlFQUFpRSxVQUFVTztJQUNyRztJQUNBLE9BQU9OLHVEQUFVQSxDQUFDUTtBQUN0QjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQ0MsR0FDTSxTQUFTQyxlQUFlSCxNQUFNLEVBQUVJLFFBQVE7SUFDM0MsSUFBSSxPQUFRSixXQUFZLFVBQVU7UUFDOUIsSUFBSUEsT0FBT0ssS0FBSyxDQUFDLHNCQUFzQjtZQUNuQyxPQUFPWCx1REFBVUEsQ0FBQ007UUFDdEI7UUFDQVIsdURBQU1BLENBQUNZLFlBQVksTUFBTSxzQ0FBc0MseUJBQXlCO1lBQUVFLFdBQVc7UUFBYztRQUNuSCxPQUFPUCxhQUFhQyxRQUFRSSxTQUFTRyxXQUFXLENBQUNQO0lBQ3JELE9BQ0ssSUFBSUwsY0FBY0ssU0FBUztRQUM1QixPQUFPRCxhQUFhQyxRQUFRQSxPQUFPTixVQUFVO0lBQ2pELE9BQ0ssSUFBSU0sVUFBVSxPQUFRQSxPQUFPUSxJQUFJLEtBQU0sWUFBWTtRQUNwRCxPQUFPVCxhQUFhQyxRQUFRQTtJQUNoQztJQUNBUCwrREFBY0EsQ0FBQyxPQUFPLGlDQUFpQyxVQUFVTztBQUNyRSxFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3lpZC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9hZGRyZXNzL2NoZWNrcy5qcz84NDcyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiLi9hZGRyZXNzLmpzXCI7XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIG9iamVjdCB3aGljaCBpbXBsZW1lbnRzIHRoZVxuICogIFtbQWRkcmVzc2FibGVdXSBpbnRlcmZhY2UuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gV2FsbGV0cyBhbmQgQWJzdHJhY3RTaWduZXIgc3ViLWNsYXNzZXNcbiAqICAgIGlzQWRkcmVzc2FibGUoV2FsbGV0LmNyZWF0ZVJhbmRvbSgpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIENvbnRyYWN0c1xuICogICAgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoXCJkYWkudG9rZW5zLmV0aGVycy5ldGhcIiwgWyBdLCBwcm92aWRlcilcbiAqICAgIGlzQWRkcmVzc2FibGUoY29udHJhY3QpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FkZHJlc3NhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmdldEFkZHJlc3MpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIGFkZHJlc3MuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gVmFsaWQgYWRkcmVzc1xuICogICAgaXNBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVmFsaWQgSUNBUCBhZGRyZXNzXG4gKiAgICBpc0FkZHJlc3MoXCJYRTY1R0I2TEROWFlPRlRYME5TVjNGVVdLT1dJWEFNSkszNlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEludmFsaWQgY2hlY2tzdW1cbiAqICAgIGlzQWRkcmVzcyhcIjB4OEJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQmE3MlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEludmFsaWQgSUNBUCBjaGVja3N1bVxuICogICAgaXNBZGRyZXNzKFwiMHg4QmExZjEwOTU1MWJENDMyODAzMDEyNjQ1QWMxMzZkZGQ2NERCQTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gTm90IGFuIGFkZHJlc3MgKGFuIEVOUyBuYW1lIHJlcXVpcmVzIGEgcHJvdmlkZWQgYW5kIGFuXG4gKiAgICAvLyBhc3luY2hyb25vdXMgQVBJIHRvIGFjY2VzcylcbiAqICAgIGlzQWRkcmVzcyhcInJpY21vby5ldGhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQWRkcmVzcyh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGdldEFkZHJlc3ModmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5hc3luYyBmdW5jdGlvbiBjaGVja0FkZHJlc3ModGFyZ2V0LCBwcm9taXNlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcbiAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0ID09PSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgKHRhcmdldCkgIT09IFwic3RyaW5nXCIsIFwidW5jb25maWd1cmVkIG5hbWVcIiwgXCJVTkNPTkZJR1VSRURfTkFNRVwiLCB7IHZhbHVlOiB0YXJnZXQgfSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgQWRkcmVzc0xpa2UgdmFsdWU7IGRpZCBub3QgcmVzb2x2ZSB0byBhIHZhbHVlIGFkZHJlc3NcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3MocmVzdWx0KTtcbn1cbi8qKlxuICogIFJlc29sdmVzIHRvIGFuIGFkZHJlc3MgZm9yIHRoZSAlJXRhcmdldCUlLCB3aGljaCBtYXkgYmUgYW55XG4gKiAgc3VwcG9ydGVkIGFkZHJlc3MgdHlwZSwgYW4gW1tBZGRyZXNzYWJsZV1dIG9yIGEgUHJvbWlzZSB3aGljaFxuICogIHJlc29sdmVzIHRvIGFuIGFkZHJlc3MuXG4gKlxuICogIElmIGFuIEVOUyBuYW1lIGlzIHByb3ZpZGVkLCBidXQgdGhhdCBuYW1lIGhhcyBub3QgYmVlbiBjb3JyZWN0bHlcbiAqICBjb25maWd1cmVkIGEgW1tVbmNvbmZpZ3VyZWROYW1lRXJyb3JdXSBpcyB0aHJvd24uXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgYWRkciA9IFwiMHg2QjE3NTQ3NEU4OTA5NEM0NERhOThiOTU0RWVkZUFDNDk1MjcxZDBGXCJcbiAqXG4gKiAgICAvLyBBZGRyZXNzZXMgYXJlIHJldHVybiBzeW5jaHJvbm91c2x5XG4gKiAgICByZXNvbHZlQWRkcmVzcyhhZGRyLCBwcm92aWRlcilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBBZGRyZXNzIHByb21pc2VzIGFyZSByZXNvbHZlZCBhc3luY2hyb25vdXNseVxuICogICAgcmVzb2x2ZUFkZHJlc3MoUHJvbWlzZS5yZXNvbHZlKGFkZHIpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEVOUyBuYW1lcyBhcmUgcmVzb2x2ZWQgYXN5bmNocm9ub3VzbHlcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwiZGFpLnRva2Vucy5ldGhlcnMuZXRoXCIsIHByb3ZpZGVyKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEFkZHJlc3NhYmxlIG9iamVjdHMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XG4gKiAgICBjb250cmFjdCA9IG5ldyBDb250cmFjdChhZGRyLCBbIF0pXG4gKiAgICByZXNvbHZlQWRkcmVzcyhjb250cmFjdCwgcHJvdmlkZXIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVW5jb25maWd1cmVkIEVOUyBuYW1lcyByZWplY3RcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIiwgcHJvdmlkZXIpXG4gKiAgICAvL19lcnJvcjpcbiAqXG4gKiAgICAvLyBFTlMgbmFtZXMgcmVxdWlyZSBhIE5hbWVSZXNvbHZlciBvYmplY3QgcGFzc2VkIGluXG4gKiAgICAvLyAobm90aWNlIHRoZSBwcm92aWRlciB3YXMgb21pdHRlZClcbiAqICAgIHJlc29sdmVBZGRyZXNzKFwibm90aGluZy1oZXJlLnJpY21vby5ldGhcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUFkZHJlc3ModGFyZ2V0LCByZXNvbHZlcikge1xuICAgIGlmICh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHRhcmdldC5tYXRjaCgvXjB4WzAtOWEtZl17NDB9JC9pKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQocmVzb2x2ZXIgIT0gbnVsbCwgXCJFTlMgcmVzb2x1dGlvbiByZXF1aXJlcyBhIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlc29sdmVOYW1lXCIgfSk7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCByZXNvbHZlci5yZXNvbHZlTmFtZSh0YXJnZXQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBZGRyZXNzYWJsZSh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCB0YXJnZXQuZ2V0QWRkcmVzcygpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGFyZ2V0ICYmIHR5cGVvZiAodGFyZ2V0LnRoZW4pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHRhcmdldCk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcInVuc3VwcG9ydGVkIGFkZHJlc3NhYmxlIHZhbHVlXCIsIFwidGFyZ2V0XCIsIHRhcmdldCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja3MuanMubWFwIl0sIm5hbWVzIjpbImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiZ2V0QWRkcmVzcyIsImlzQWRkcmVzc2FibGUiLCJ2YWx1ZSIsImlzQWRkcmVzcyIsImVycm9yIiwiY2hlY2tBZGRyZXNzIiwidGFyZ2V0IiwicHJvbWlzZSIsInJlc3VsdCIsInJlc29sdmVBZGRyZXNzIiwicmVzb2x2ZXIiLCJtYXRjaCIsIm9wZXJhdGlvbiIsInJlc29sdmVOYW1lIiwidGhlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/address/checks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/contract/contract.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/contract/contract.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseContract: () => (/* binding */ BaseContract),\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   copyOverrides: () => (/* binding */ copyOverrides),\n/* harmony export */   resolveArgs: () => (/* binding */ resolveArgs)\n/* harmony export */ });\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../abi/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/typed.js\");\n/* harmony import */ var _abi_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../abi/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/checks.js\");\n/* harmony import */ var _providers_provider_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../providers/provider.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _wrappers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./wrappers.js */ \"(ssr)/./node_modules/ethers/lib.esm/contract/wrappers.js\");\n\n\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\n\n\n\nconst BN_0 = BigInt(0);\nfunction canCall(value) {\n    return value && typeof value.call === \"function\";\n}\nfunction canEstimate(value) {\n    return value && typeof value.estimateGas === \"function\";\n}\nfunction canResolve(value) {\n    return value && typeof value.resolveName === \"function\";\n}\nfunction canSend(value) {\n    return value && typeof value.sendTransaction === \"function\";\n}\nfunction getResolver(value) {\n    if (value != null) {\n        if (canResolve(value)) {\n            return value;\n        }\n        if (value.provider) {\n            return value.provider;\n        }\n    }\n    return undefined;\n}\nclass PreparedTopicFilter {\n    #filter;\n    constructor(contract, fragment, args){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            fragment\n        });\n        if (fragment.inputs.length < args.length) {\n            throw new Error(\"too many arguments\");\n        }\n        // Recursively descend into args and resolve any addresses\n        const runner = getRunner(contract.runner, \"resolveName\");\n        const resolver = canResolve(runner) ? runner : null;\n        this.#filter = async function() {\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index)=>{\n                const arg = args[index];\n                if (arg == null) {\n                    return null;\n                }\n                return param.walkAsync(args[index], (type, value)=>{\n                    if (type === \"address\") {\n                        if (Array.isArray(value)) {\n                            return Promise.all(value.map((v)=>(0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(v, resolver)));\n                        }\n                        return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(value, resolver);\n                    }\n                    return value;\n                });\n            }));\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n        }();\n    }\n    getTopicFilter() {\n        return this.#filter;\n    }\n}\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\nfunction getRunner(value, feature) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof value[feature] === \"function\") {\n        return value;\n    }\n    if (value.provider && typeof value.provider[feature] === \"function\") {\n        return value.provider;\n    }\n    return null;\n}\nfunction getProvider(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.provider || null;\n}\n/**\n *  @_ignore:\n */ async function copyOverrides(arg, allowed) {\n    // Make sure the overrides passed in are a valid overrides object\n    const _overrides = _abi_index_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(arg, \"overrides\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof _overrides === \"object\", \"invalid overrides parameter\", \"overrides\", arg);\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n    const overrides = (0,_providers_provider_js__WEBPACK_IMPORTED_MODULE_4__.copyRequest)(_overrides);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\n    // Resolve any from\n    if (overrides.from) {\n        overrides.from = overrides.from;\n    }\n    return overrides;\n}\n/**\n *  @_ignore:\n */ async function resolveArgs(_runner, inputs, args) {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner : null;\n    return await Promise.all(inputs.map((param, index)=>{\n        return param.walkAsync(args[index], (type, value)=>{\n            value = _abi_index_js__WEBPACK_IMPORTED_MODULE_2__.Typed.dereference(value, type);\n            if (type === \"address\") {\n                return (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(value, resolver);\n            }\n            return value;\n        });\n    }));\n}\nfunction buildWrappedFallback(contract) {\n    const populateTransaction = async function(overrides) {\n        // If an overrides was passed in, copy it and normalize the values\n        const tx = await copyOverrides(overrides, [\n            \"data\"\n        ]);\n        tx.to = await contract.getAddress();\n        if (tx.from) {\n            tx.from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(tx.from, getResolver(contract.runner));\n        }\n        const iface = contract.interface;\n        const noValue = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_5__.getBigInt)(tx.value || BN_0, \"overrides.value\") === BN_0;\n        const noData = (tx.data || \"0x\") === \"0x\";\n        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || iface.fallback && iface.fallback.payable;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(payable || noValue, \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n        // Only allow fallback contracts to set non-empty data\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        return tx;\n    };\n    const staticCall = async function(overrides) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"call\"\n        });\n        const tx = await populateTransaction(overrides);\n        try {\n            return await runner.call(tx);\n        } catch (error) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    };\n    const send = async function(overrides) {\n        const runner = contract.runner;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function(overrides) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"estimateGas\"\n        });\n        return await runner.estimateGas(await populateTransaction(overrides));\n    };\n    const method = async (overrides)=>{\n        return await send(overrides);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        _contract: contract,\n        estimateGas,\n        populateTransaction,\n        send,\n        staticCall\n    });\n    return method;\n}\nfunction buildWrappedMethod(contract, key) {\n    const getFragment = function(...args) {\n        const fragment = contract.interface.getFunction(key, args);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: {\n                key,\n                args\n            }\n        });\n        return fragment;\n    };\n    const populateTransaction = async function(...args) {\n        const fragment = getFragment(...args);\n        // If an overrides was passed in, copy it and normalize the values\n        let overrides = {};\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n            if (overrides.from) {\n                overrides.from = await (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.resolveAddress)(overrides.from, getResolver(contract.runner));\n            }\n        }\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n        }\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n        return Object.assign({}, overrides, await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n            to: contract.getAddress(),\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n        }));\n    };\n    const staticCall = async function(...args) {\n        const result = await staticCallResult(...args);\n        if (result.length === 1) {\n            return result[0];\n        }\n        return result;\n    };\n    const send = async function(...args) {\n        const runner = contract.runner;\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function(...args) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"estimateGas\"\n        });\n        return await runner.estimateGas(await populateTransaction(...args));\n    };\n    const staticCallResult = async function(...args) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"call\"\n        });\n        const tx = await populateTransaction(...args);\n        let result = \"0x\";\n        try {\n            result = await runner.call(tx);\n        } catch (error) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n        const fragment = getFragment(...args);\n        return contract.interface.decodeFunctionResult(fragment, result);\n    };\n    const method = async (...args)=>{\n        const fragment = getFragment(...args);\n        if (fragment.constant) {\n            return await staticCall(...args);\n        }\n        return await send(...args);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        name: contract.interface.getFunctionName(key),\n        _contract: contract,\n        _key: key,\n        getFragment,\n        estimateGas,\n        populateTransaction,\n        send,\n        staticCall,\n        staticCallResult\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: ()=>{\n            const fragment = contract.interface.getFunction(key);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: {\n                    key\n                }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\nfunction buildWrappedEvent(contract, key) {\n    const getFragment = function(...args) {\n        const fragment = contract.interface.getEvent(key, args);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: {\n                key,\n                args\n            }\n        });\n        return fragment;\n    };\n    const method = function(...args) {\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\n    };\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(method, {\n        name: contract.interface.getEventName(key),\n        _contract: contract,\n        _key: key,\n        getFragment\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: ()=>{\n            const fragment = contract.interface.getEvent(key);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: {\n                    key\n                }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\nconst internal = Symbol.for(\"_ethersInternal_contract\");\nconst internalValues = new WeakMap();\nfunction setInternal(contract, values) {\n    internalValues.set(contract[internal], values);\n}\nfunction getInternal(contract) {\n    return internalValues.get(contract[internal]);\n}\nfunction isDeferred(value) {\n    return value && typeof value === \"object\" && \"getTopicFilter\" in value && typeof value.getTopicFilter === \"function\" && value.fragment;\n}\nasync function getSubInfo(contract, event) {\n    let topics;\n    let fragment = null;\n    // Convert named events to topicHash and get the fragment for\n    // events which need deconstructing.\n    if (Array.isArray(event)) {\n        const topicHashify = function(name) {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.isHexString)(name, 32)) {\n                return name;\n            }\n            const fragment = contract.interface.getEvent(name);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n        };\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n        topics = event.map((e)=>{\n            if (e == null) {\n                return null;\n            }\n            if (Array.isArray(e)) {\n                return e.map(topicHashify);\n            }\n            return topicHashify(e);\n        });\n    } else if (event === \"*\") {\n        topics = [\n            null\n        ];\n    } else if (typeof event === \"string\") {\n        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.isHexString)(event, 32)) {\n            // Topic Hash\n            topics = [\n                event\n            ];\n        } else {\n            // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(fragment, \"unknown fragment\", \"event\", event);\n            topics = [\n                fragment.topicHash\n            ];\n        }\n    } else if (isDeferred(event)) {\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n        topics = await event.getTopicFilter();\n    } else if (\"fragment\" in event) {\n        // ContractEvent; e.g. `contract.filter.Transfer`\n        fragment = event.fragment;\n        topics = [\n            fragment.topicHash\n        ];\n    } else {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(false, \"unknown event name\", \"event\", event);\n    }\n    // Normalize topics and sort TopicSets\n    topics = topics.map((t)=>{\n        if (t == null) {\n            return null;\n        }\n        if (Array.isArray(t)) {\n            const items = Array.from(new Set(t.map((t)=>t.toLowerCase())).values());\n            if (items.length === 1) {\n                return items[0];\n            }\n            items.sort();\n            return items;\n        }\n        return t.toLowerCase();\n    });\n    const tag = topics.map((t)=>{\n        if (t == null) {\n            return \"null\";\n        }\n        if (Array.isArray(t)) {\n            return t.join(\"|\");\n        }\n        return t;\n    }).join(\"&\");\n    return {\n        fragment,\n        tag,\n        topics\n    };\n}\nasync function hasSub(contract, event) {\n    const { subs } = getInternal(contract);\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\nasync function getSub(contract, operation, event) {\n    // Make sure our runner can actually subscribe to events\n    const provider = getProvider(contract.runner);\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", {\n        operation\n    });\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\n    const { addr, subs } = getInternal(contract);\n    let sub = subs.get(tag);\n    if (!sub) {\n        const address = addr ? addr : contract;\n        const filter = {\n            address,\n            topics\n        };\n        const listener = (log)=>{\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\n                } catch (error) {}\n            }\n            // If fragment is null, we do not deconstruct the args to emit\n            if (foundFragment) {\n                const _foundFragment = foundFragment;\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\n                emit(contract, event, args, (listener)=>{\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n            } else {\n                emit(contract, event, [], (listener)=>{\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractUnknownEventPayload(contract, listener, event, log);\n                });\n            }\n        };\n        let starting = [];\n        const start = ()=>{\n            if (starting.length) {\n                return;\n            }\n            starting.push(provider.on(filter, listener));\n        };\n        const stop = async ()=>{\n            if (starting.length == 0) {\n                return;\n            }\n            let started = starting;\n            starting = [];\n            await Promise.all(started);\n            provider.off(filter, listener);\n        };\n        sub = {\n            tag,\n            listeners: [],\n            start,\n            stop\n        };\n        subs.set(tag, sub);\n    }\n    return sub;\n}\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit = Promise.resolve();\nasync function _emit(contract, event, args, payloadFunc) {\n    await lastEmit;\n    const sub = await hasSub(contract, event);\n    if (!sub) {\n        return false;\n    }\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({ listener, once })=>{\n        const passArgs = Array.from(args);\n        if (payloadFunc) {\n            passArgs.push(payloadFunc(once ? null : listener));\n        }\n        try {\n            listener.call(contract, ...passArgs);\n        } catch (error) {}\n        return !once;\n    });\n    if (sub.listeners.length === 0) {\n        sub.stop();\n        getInternal(contract).subs.delete(sub.tag);\n    }\n    return count > 0;\n}\nasync function emit(contract, event, args, payloadFunc) {\n    try {\n        await lastEmit;\n    } catch (error) {}\n    const resultPromise = _emit(contract, event, args, payloadFunc);\n    lastEmit = resultPromise;\n    return await resultPromise;\n}\nconst passProperties = [\n    \"then\"\n];\nclass BaseContract {\n    /**\n     *  Creates a new contract connected to %%target%% with the %%abi%% and\n     *  optionally connected to a %%runner%% to perform operations on behalf\n     *  of.\n     */ constructor(target, abi, runner, _deployTx){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assertArgument)(typeof target === \"string\" || (0,_address_index_js__WEBPACK_IMPORTED_MODULE_1__.isAddressable)(target), \"invalid value for Contract target\", \"target\", target);\n        if (runner == null) {\n            runner = null;\n        }\n        const iface = _abi_index_js__WEBPACK_IMPORTED_MODULE_8__.Interface.from(abi);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            target,\n            runner,\n            interface: iface\n        });\n        Object.defineProperty(this, internal, {\n            value: {}\n        });\n        let addrPromise;\n        let addr = null;\n        let deployTx = null;\n        if (_deployTx) {\n            const provider = getProvider(runner);\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            deployTx = new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.ContractTransactionResponse(this.interface, provider, _deployTx);\n        }\n        let subs = new Map();\n        // Resolve the target as the address\n        if (typeof target === \"string\") {\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_7__.isHexString)(target)) {\n                addr = target;\n                addrPromise = Promise.resolve(target);\n            } else {\n                const resolver = getRunner(runner, \"resolveName\");\n                if (!canResolve(resolver)) {\n                    throw (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"resolveName\"\n                    });\n                }\n                addrPromise = resolver.resolveName(target).then((addr)=>{\n                    if (addr == null) {\n                        throw (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.makeError)(\"an ENS name used for a contract target must be correctly configured\", \"UNCONFIGURED_NAME\", {\n                            value: target\n                        });\n                    }\n                    getInternal(this).addr = addr;\n                    return addr;\n                });\n            }\n        } else {\n            addrPromise = target.getAddress().then((addr)=>{\n                if (addr == null) {\n                    throw new Error(\"TODO\");\n                }\n                getInternal(this).addr = addr;\n                return addr;\n            });\n        }\n        // Set our private values\n        setInternal(this, {\n            addrPromise,\n            addr,\n            deployTx,\n            subs\n        });\n        // Add the event filters\n        const filters = new Proxy({}, {\n            get: (target, prop, receiver)=>{\n                // Pass important checks (like `then` for Promise) through\n                if (typeof prop === \"symbol\" || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                try {\n                    return this.getEvent(prop);\n                } catch (error) {\n                    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop)=>{\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n            }\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            filters\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null\n        });\n        // Return a Proxy that will respond to functions\n        return new Proxy(this, {\n            get: (target, prop, receiver)=>{\n                if (typeof prop === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                // Undefined properties should return undefined\n                try {\n                    return target.getFunction(prop);\n                } catch (error) {\n                    if (!(0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop)=>{\n                if (typeof prop === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return target.interface.hasFunction(prop);\n            }\n        });\n    }\n    /**\n     *  Return a new Contract instance with the same target and ABI, but\n     *  a different %%runner%%.\n     */ connect(runner) {\n        return new BaseContract(this.target, this.interface, runner);\n    }\n    /**\n     *  Return a new Contract instance with the same ABI and runner, but\n     *  a different %%target%%.\n     */ attach(target) {\n        return new BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Return the resolved address of this Contract.\n     */ async getAddress() {\n        return await getInternal(this).addrPromise;\n    }\n    /**\n     *  Return the deployed bytecode or null if no bytecode is found.\n     */ async getDeployedCode() {\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getDeployedCode\"\n        });\n        const code = await provider.getCode(await this.getAddress());\n        if (code === \"0x\") {\n            return null;\n        }\n        return code;\n    }\n    /**\n     *  Resolve to this Contract once the bytecode has been deployed, or\n     *  resolve immediately if already deployed.\n     */ async waitForDeployment() {\n        // We have the deployement transaction; just use that (throws if deployement fails)\n        const deployTx = this.deploymentTransaction();\n        if (deployTx) {\n            await deployTx.wait();\n            return this;\n        }\n        // Check for code\n        const code = await this.getDeployedCode();\n        if (code != null) {\n            return this;\n        }\n        // Make sure we can subscribe to a provider event\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"waitForDeployment\"\n        });\n        return new Promise((resolve, reject)=>{\n            const checkCode = async ()=>{\n                try {\n                    const code = await this.getDeployedCode();\n                    if (code != null) {\n                        return resolve(this);\n                    }\n                    provider.once(\"block\", checkCode);\n                } catch (error) {\n                    reject(error);\n                }\n            };\n            checkCode();\n        });\n    }\n    /**\n     *  Return the transaction used to deploy this contract.\n     *\n     *  This is only available if this instance was returned from a\n     *  [[ContractFactory]].\n     */ deploymentTransaction() {\n        return getInternal(this).deployTx;\n    }\n    /**\n     *  Return the function for a given name. This is useful when a contract\n     *  method name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */ getFunction(key) {\n        if (typeof key !== \"string\") {\n            key = key.format();\n        }\n        const func = buildWrappedMethod(this, key);\n        return func;\n    }\n    /**\n     *  Return the event for a given name. This is useful when a contract\n     *  event name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */ getEvent(key) {\n        if (typeof key !== \"string\") {\n            key = key.format();\n        }\n        return buildWrappedEvent(this, key);\n    }\n    /**\n     *  @_ignore:\n     */ async queryTransaction(hash) {\n        throw new Error(\"@TODO\");\n    }\n    /*\n    // @TODO: this is a non-backwards compatible change, but will be added\n    //        in v7 and in a potential SmartContract class in an upcoming\n    //        v6 release\n    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryTransaction\" });\n\n        const receipt = await provider.getTransactionReceipt(hash);\n        if (receipt == null) { return null; }\n\n        return new ContractTransactionReceipt(this.interface, provider, receipt);\n    }\n    */ /**\n     *  Provide historic access to event data for %%event%% in the range\n     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n     *  inclusive.\n     */ async queryFilter(event, fromBlock, toBlock) {\n        if (fromBlock == null) {\n            fromBlock = 0;\n        }\n        if (toBlock == null) {\n            toBlock = \"latest\";\n        }\n        const { addr, addrPromise } = getInternal(this);\n        const address = addr ? addr : await addrPromise;\n        const { fragment, topics } = await getSubInfo(this, event);\n        const filter = {\n            address,\n            topics,\n            fromBlock,\n            toBlock\n        };\n        const provider = getProvider(this.runner);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"queryFilter\"\n        });\n        return (await provider.getLogs(filter)).map((log)=>{\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = this.interface.getEvent(log.topics[0]);\n                } catch (error) {}\n            }\n            if (foundFragment) {\n                try {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.EventLog(log, this.interface, foundFragment);\n                } catch (error) {\n                    return new _wrappers_js__WEBPACK_IMPORTED_MODULE_6__.UndecodedEventLog(log, error);\n                }\n            }\n            return new _providers_provider_js__WEBPACK_IMPORTED_MODULE_4__.Log(log, provider);\n        });\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%.\n     */ async on(event, listener) {\n        const sub = await getSub(this, \"on\", event);\n        sub.listeners.push({\n            listener,\n            once: false\n        });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%, but remove the listener\n     *  after it is fired once.\n     */ async once(event, listener) {\n        const sub = await getSub(this, \"once\", event);\n        sub.listeners.push({\n            listener,\n            once: true\n        });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Emit an %%event%% calling all listeners with %%args%%.\n     *\n     *  Resolves to ``true`` if any listeners were called.\n     */ async emit(event, ...args) {\n        return await emit(this, event, args, null);\n    }\n    /**\n     *  Resolves to the number of listeners of %%event%% or the total number\n     *  of listeners if unspecified.\n     */ async listenerCount(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        const { subs } = getInternal(this);\n        let total = 0;\n        for (const { listeners } of subs.values()){\n            total += listeners.length;\n        }\n        return total;\n    }\n    /**\n     *  Resolves to the listeners subscribed to %%event%% or all listeners\n     *  if unspecified.\n     */ async listeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener })=>listener);\n        }\n        const { subs } = getInternal(this);\n        let result = [];\n        for (const { listeners } of subs.values()){\n            result = result.concat(listeners.map(({ listener })=>listener));\n        }\n        return result;\n    }\n    /**\n     *  Remove the %%listener%% from the listeners for %%event%% or remove\n     *  all listeners if unspecified.\n     */ async off(event, listener) {\n        const sub = await hasSub(this, event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener })=>listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (listener == null || sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n        return this;\n    }\n    /**\n     *  Remove all the listeners for %%event%% or remove all listeners if\n     *  unspecified.\n     */ async removeAllListeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return this;\n            }\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        } else {\n            const { subs } = getInternal(this);\n            for (const { tag, stop } of subs.values()){\n                stop();\n                subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    /**\n     *  Alias for [on].\n     */ async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    /**\n     *  Alias for [off].\n     */ async removeListener(event, listener) {\n        return await this.off(event, listener);\n    }\n    /**\n     *  Create a new Class for the %%abi%%.\n     */ static buildClass(abi) {\n        class CustomContract extends BaseContract {\n            constructor(address, runner = null){\n                super(address, abi, runner);\n            }\n        }\n        return CustomContract;\n    }\n    /**\n     *  Create a new BaseContract with a specified Interface.\n     */ static from(target, abi, runner) {\n        if (runner == null) {\n            runner = null;\n        }\n        const contract = new this(target, abi, runner);\n        return contract;\n    }\n}\nfunction _ContractBase() {\n    return BaseContract;\n}\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */ class Contract extends _ContractBase() {\n} //# sourceMappingURL=contract.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3QvY29udHJhY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFtRDtBQUNpQjtBQUNwRSxzRUFBc0U7QUFDdEUseUJBQXlCO0FBQ21DO0FBQ2lHO0FBQ2pCO0FBQzVJLE1BQU1vQixPQUFPQyxPQUFPO0FBQ3BCLFNBQVNDLFFBQVFDLEtBQUs7SUFDbEIsT0FBUUEsU0FBUyxPQUFRQSxNQUFNQyxJQUFJLEtBQU07QUFDN0M7QUFDQSxTQUFTQyxZQUFZRixLQUFLO0lBQ3RCLE9BQVFBLFNBQVMsT0FBUUEsTUFBTUcsV0FBVyxLQUFNO0FBQ3BEO0FBQ0EsU0FBU0MsV0FBV0osS0FBSztJQUNyQixPQUFRQSxTQUFTLE9BQVFBLE1BQU1LLFdBQVcsS0FBTTtBQUNwRDtBQUNBLFNBQVNDLFFBQVFOLEtBQUs7SUFDbEIsT0FBUUEsU0FBUyxPQUFRQSxNQUFNTyxlQUFlLEtBQU07QUFDeEQ7QUFDQSxTQUFTQyxZQUFZUixLQUFLO0lBQ3RCLElBQUlBLFNBQVMsTUFBTTtRQUNmLElBQUlJLFdBQVdKLFFBQVE7WUFDbkIsT0FBT0E7UUFDWDtRQUNBLElBQUlBLE1BQU1TLFFBQVEsRUFBRTtZQUNoQixPQUFPVCxNQUFNUyxRQUFRO1FBQ3pCO0lBQ0o7SUFDQSxPQUFPQztBQUNYO0FBQ0EsTUFBTUM7SUFDRixDQUFDQyxNQUFNLENBQUM7SUFFUkMsWUFBWUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLElBQUksQ0FBRTtRQUNsQ2pDLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRWdDO1FBQVM7UUFDbEMsSUFBSUEsU0FBU0UsTUFBTSxDQUFDQyxNQUFNLEdBQUdGLEtBQUtFLE1BQU0sRUFBRTtZQUN0QyxNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSwwREFBMEQ7UUFDMUQsTUFBTUMsU0FBU0MsVUFBVVAsU0FBU00sTUFBTSxFQUFFO1FBQzFDLE1BQU1FLFdBQVdsQixXQUFXZ0IsVUFB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QUFFa0IsUUFBUSxFQUFFO1FBQ2xDLE9BQU8sTUFBTSxJQUFJLENBQUNZLEdBQUcsQ0FBQzlCLE9BQU9rQjtJQUNqQztJQUNBOztLQUVDLEdBQ0QsT0FBT21FLFdBQVd6QyxHQUFHLEVBQUU7UUFDbkIsTUFBTTBDLHVCQUF1QjVDO1lBQ3pCbEksWUFBWXlHLE9BQU8sRUFBRWxHLFNBQVMsSUFBSSxDQUFFO2dCQUNoQyxLQUFLLENBQUNrRyxTQUFTMkIsS0FBSzdIO1lBQ3hCO1FBQ0o7UUFDQSxPQUFPdUs7SUFDWDtJQUVBOztLQUVDLEdBQ0QsT0FBTzNJLEtBQUtnRyxNQUFNLEVBQUVDLEdBQUcsRUFBRTdILE1BQU0sRUFBRTtRQUM3QixJQUFJQSxVQUFVLE1BQU07WUFDaEJBLFNBQVM7UUFDYjtRQUNBLE1BQU1OLFdBQVcsSUFBSSxJQUFJLENBQUNrSSxRQUFRQyxLQUFLN0g7UUFDdkMsT0FBT047SUFDWDtBQUNKO0FBQ0EsU0FBUzhLO0lBQ0wsT0FBTzdDO0FBQ1g7QUFDQTs7Q0FFQyxHQUNNLE1BQU04QyxpQkFBaUJEO0FBQzlCLEVBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veWlkLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnRyYWN0L2NvbnRyYWN0LmpzPzI2NjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW50ZXJmYWNlLCBUeXBlZCB9IGZyb20gXCIuLi9hYmkvaW5kZXguanNcIjtcbmltcG9ydCB7IGlzQWRkcmVzc2FibGUsIHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIi4uL2FkZHJlc3MvaW5kZXguanNcIjtcbi8vIGltcG9ydCBmcm9tIHByb3ZpZGVyLnRzIGluc3RlYWQgb2YgaW5kZXgudHMgdG8gcHJldmVudCBjaXJjdWxhciBkZXBcbi8vIGZyb20gRXRoZXJzY2FuUHJvdmlkZXJcbmltcG9ydCB7IGNvcHlSZXF1ZXN0LCBMb2cgfSBmcm9tIFwiLi4vcHJvdmlkZXJzL3Byb3ZpZGVyLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGlzQ2FsbEV4Y2VwdGlvbiwgaXNIZXhTdHJpbmcsIHJlc29sdmVQcm9wZXJ0aWVzLCBpc0Vycm9yLCBtYWtlRXJyb3IsIGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IENvbnRyYWN0RXZlbnRQYXlsb2FkLCBDb250cmFjdFVua25vd25FdmVudFBheWxvYWQsIENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSwgRXZlbnRMb2csIFVuZGVjb2RlZEV2ZW50TG9nIH0gZnJvbSBcIi4vd3JhcHBlcnMuanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5mdW5jdGlvbiBjYW5DYWxsKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmNhbGwpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gY2FuRXN0aW1hdGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuZXN0aW1hdGVHYXMpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gY2FuUmVzb2x2ZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5yZXNvbHZlTmFtZSkgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBjYW5TZW5kKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnNlbmRUcmFuc2FjdGlvbikgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBnZXRSZXNvbHZlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChjYW5SZXNvbHZlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5jbGFzcyBQcmVwYXJlZFRvcGljRmlsdGVyIHtcbiAgICAjZmlsdGVyO1xuICAgIGZyYWdtZW50O1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncykge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZnJhZ21lbnQgfSk7XG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50c1wiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBkZXNjZW5kIGludG8gYXJncyBhbmQgcmVzb2x2ZSBhbnkgYWRkcmVzc2VzXG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwicmVzb2x2ZU5hbWVcIik7XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gY2FuUmVzb2x2ZShydW5uZXIpID8gcnVubmVyIDogbnVsbDtcbiAgICAgICAgdGhpcy4jZmlsdGVyID0gKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkQXJncyA9IGF3YWl0IFByb21pc2UuYWxsKGZyYWdtZW50LmlucHV0cy5tYXAoKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChhcmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtLndhbGtBc3luYyhhcmdzW2luZGV4XSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHZhbHVlLm1hcCgodikgPT4gcmVzb2x2ZUFkZHJlc3ModiwgcmVzb2x2ZXIpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUFkZHJlc3ModmFsdWUsIHJlc29sdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZpbHRlclRvcGljcyhmcmFnbWVudCwgcmVzb2x2ZWRBcmdzKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZ2V0VG9waWNGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmaWx0ZXI7XG4gICAgfVxufVxuLy8gQSA9IEFyZ3VtZW50cyBwYXNzZWQgaW4gYXMgYSB0dXBsZVxuLy8gUiA9IFRoZSByZXN1bHQgdHlwZSBvZiB0aGUgY2FsbCAoaS5lLiBpZiBvbmx5IG9uZSByZXR1cm4gdHlwZSxcbi8vICAgICB0aGUgcXVhbGlmaWVkIHR5cGUsIG90aGVyd2lzZSBSZXN1bHQpXG4vLyBEID0gVGhlIHR5cGUgdGhlIGRlZmF1bHQgY2FsbCB3aWxsIHJldHVybiAoaS5lLiBSIGZvciB2aWV3L3B1cmUsXG4vLyAgICAgVHJhbnNhY3Rpb25SZXNwb25zZSBvdGhlcndpc2UpXG4vL2V4cG9ydCBpbnRlcmZhY2UgQ29udHJhY3RNZXRob2Q8QSBleHRlbmRzIEFycmF5PGFueT4gPSBBcnJheTxhbnk+LCBSID0gYW55LCBEIGV4dGVuZHMgUiB8IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSA9IENvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZT4ge1xuZnVuY3Rpb24gZ2V0UnVubmVyKHZhbHVlLCBmZWF0dXJlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlW2ZlYXR1cmVdKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnByb3ZpZGVyICYmIHR5cGVvZiAodmFsdWUucHJvdmlkZXJbZmVhdHVyZV0pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnByb3ZpZGVyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFByb3ZpZGVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5wcm92aWRlciB8fCBudWxsO1xufVxuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb3B5T3ZlcnJpZGVzKGFyZywgYWxsb3dlZCkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgb3ZlcnJpZGVzIHBhc3NlZCBpbiBhcmUgYSB2YWxpZCBvdmVycmlkZXMgb2JqZWN0XG4gICAgY29uc3QgX292ZXJyaWRlcyA9IFR5cGVkLmRlcmVmZXJlbmNlKGFyZywgXCJvdmVycmlkZXNcIik7XG4gICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mIChfb3ZlcnJpZGVzKSA9PT0gXCJvYmplY3RcIiwgXCJpbnZhbGlkIG92ZXJyaWRlcyBwYXJhbWV0ZXJcIiwgXCJvdmVycmlkZXNcIiwgYXJnKTtcbiAgICAvLyBDcmVhdGUgYSBzaGFsbG93IGNvcHkgKHdlJ2xsIGRlZXAtaWZ5IGFueXRoaW5nIG5lZWRlZCBkdXJpbmcgbm9ybWFsaXppbmcpXG4gICAgY29uc3Qgb3ZlcnJpZGVzID0gY29weVJlcXVlc3QoX292ZXJyaWRlcyk7XG4gICAgYXNzZXJ0QXJndW1lbnQob3ZlcnJpZGVzLnRvID09IG51bGwgfHwgKGFsbG93ZWQgfHwgW10pLmluZGV4T2YoXCJ0b1wiKSA+PSAwLCBcImNhbm5vdCBvdmVycmlkZSB0b1wiLCBcIm92ZXJyaWRlcy50b1wiLCBvdmVycmlkZXMudG8pO1xuICAgIGFzc2VydEFyZ3VtZW50KG92ZXJyaWRlcy5kYXRhID09IG51bGwgfHwgKGFsbG93ZWQgfHwgW10pLmluZGV4T2YoXCJkYXRhXCIpID49IDAsIFwiY2Fubm90IG92ZXJyaWRlIGRhdGFcIiwgXCJvdmVycmlkZXMuZGF0YVwiLCBvdmVycmlkZXMuZGF0YSk7XG4gICAgLy8gUmVzb2x2ZSBhbnkgZnJvbVxuICAgIGlmIChvdmVycmlkZXMuZnJvbSkge1xuICAgICAgICBvdmVycmlkZXMuZnJvbSA9IG92ZXJyaWRlcy5mcm9tO1xuICAgIH1cbiAgICByZXR1cm4gb3ZlcnJpZGVzO1xufVxuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlQXJncyhfcnVubmVyLCBpbnB1dHMsIGFyZ3MpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBkZXNjZW5kIGludG8gYXJncyBhbmQgcmVzb2x2ZSBhbnkgYWRkcmVzc2VzXG4gICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKF9ydW5uZXIsIFwicmVzb2x2ZU5hbWVcIik7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBjYW5SZXNvbHZlKHJ1bm5lcikgPyBydW5uZXIgOiBudWxsO1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChpbnB1dHMubWFwKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIHBhcmFtLndhbGtBc3luYyhhcmdzW2luZGV4XSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZSA9IFR5cGVkLmRlcmVmZXJlbmNlKHZhbHVlLCB0eXBlKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzcyh2YWx1ZSwgcmVzb2x2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9KSk7XG59XG5mdW5jdGlvbiBidWlsZFdyYXBwZWRGYWxsYmFjayhjb250cmFjdCkge1xuICAgIGNvbnN0IHBvcHVsYXRlVHJhbnNhY3Rpb24gPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIC8vIElmIGFuIG92ZXJyaWRlcyB3YXMgcGFzc2VkIGluLCBjb3B5IGl0IGFuZCBub3JtYWxpemUgdGhlIHZhbHVlc1xuICAgICAgICBjb25zdCB0eCA9IChhd2FpdCBjb3B5T3ZlcnJpZGVzKG92ZXJyaWRlcywgW1wiZGF0YVwiXSkpO1xuICAgICAgICB0eC50byA9IGF3YWl0IGNvbnRyYWN0LmdldEFkZHJlc3MoKTtcbiAgICAgICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSBhd2FpdCByZXNvbHZlQWRkcmVzcyh0eC5mcm9tLCBnZXRSZXNvbHZlcihjb250cmFjdC5ydW5uZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZmFjZSA9IGNvbnRyYWN0LmludGVyZmFjZTtcbiAgICAgICAgY29uc3Qgbm9WYWx1ZSA9IChnZXRCaWdJbnQoKHR4LnZhbHVlIHx8IEJOXzApLCBcIm92ZXJyaWRlcy52YWx1ZVwiKSA9PT0gQk5fMCk7XG4gICAgICAgIGNvbnN0IG5vRGF0YSA9ICgodHguZGF0YSB8fCBcIjB4XCIpID09PSBcIjB4XCIpO1xuICAgICAgICBpZiAoaWZhY2UuZmFsbGJhY2sgJiYgIWlmYWNlLmZhbGxiYWNrLnBheWFibGUgJiYgaWZhY2UucmVjZWl2ZSAmJiAhbm9EYXRhICYmICFub1ZhbHVlKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJjYW5ub3Qgc2VuZCBkYXRhIHRvIHJlY2VpdmUgb3Igc2VuZCB2YWx1ZSB0byBub24tcGF5YWJsZSBmYWxsYmFja1wiLCBcIm92ZXJyaWRlc1wiLCBvdmVycmlkZXMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGlmYWNlLmZhbGxiYWNrIHx8IG5vRGF0YSwgXCJjYW5ub3Qgc2VuZCBkYXRhIHRvIHJlY2VpdmUtb25seSBjb250cmFjdFwiLCBcIm92ZXJyaWRlcy5kYXRhXCIsIHR4LmRhdGEpO1xuICAgICAgICAvLyBPbmx5IGFsbG93IHBheWFibGUgY29udHJhY3RzIHRvIHNldCBub24temVybyB2YWx1ZVxuICAgICAgICBjb25zdCBwYXlhYmxlID0gaWZhY2UucmVjZWl2ZSB8fCAoaWZhY2UuZmFsbGJhY2sgJiYgaWZhY2UuZmFsbGJhY2sucGF5YWJsZSk7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHBheWFibGUgfHwgbm9WYWx1ZSwgXCJjYW5ub3Qgc2VuZCB2YWx1ZSB0byBub24tcGF5YWJsZSBmYWxsYmFja1wiLCBcIm92ZXJyaWRlcy52YWx1ZVwiLCB0eC52YWx1ZSk7XG4gICAgICAgIC8vIE9ubHkgYWxsb3cgZmFsbGJhY2sgY29udHJhY3RzIHRvIHNldCBub24tZW1wdHkgZGF0YVxuICAgICAgICBhc3NlcnRBcmd1bWVudChpZmFjZS5mYWxsYmFjayB8fCBub0RhdGEsIFwiY2Fubm90IHNlbmQgZGF0YSB0byByZWNlaXZlLW9ubHkgY29udHJhY3RcIiwgXCJvdmVycmlkZXMuZGF0YVwiLCB0eC5kYXRhKTtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH07XG4gICAgY29uc3Qgc3RhdGljQ2FsbCA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gZ2V0UnVubmVyKGNvbnRyYWN0LnJ1bm5lciwgXCJjYWxsXCIpO1xuICAgICAgICBhc3NlcnQoY2FuQ2FsbChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGNhbGxpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiY2FsbFwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24ob3ZlcnJpZGVzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBydW5uZXIuY2FsbCh0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNDYWxsRXhjZXB0aW9uKGVycm9yKSAmJiBlcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY29udHJhY3QuaW50ZXJmYWNlLm1ha2VFcnJvcihlcnJvci5kYXRhLCB0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2VuZCA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gY29udHJhY3QucnVubmVyO1xuICAgICAgICBhc3NlcnQoY2FuU2VuZChydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IHNlbmRpbmcgdHJhbnNhY3Rpb25zXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiIH0pO1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHJ1bm5lci5zZW5kVHJhbnNhY3Rpb24oYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbihvdmVycmlkZXMpKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihjb250cmFjdC5ydW5uZXIpO1xuICAgICAgICAvLyBAVE9ETzogdGhlIHByb3ZpZGVyIGNhbiBiZSBudWxsOyBtYWtlIGEgY3VzdG9tIGR1bW15IHByb3ZpZGVyIHRoYXQgd2lsbCB0aHJvdyBhXG4gICAgICAgIC8vIG1lYW5pbmdmdWwgZXJyb3JcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UoY29udHJhY3QuaW50ZXJmYWNlLCBwcm92aWRlciwgdHgpO1xuICAgIH07XG4gICAgY29uc3QgZXN0aW1hdGVHYXMgPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiZXN0aW1hdGVHYXNcIik7XG4gICAgICAgIGFzc2VydChjYW5Fc3RpbWF0ZShydW5uZXIpLCBcImNvbnRyYWN0IHJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IGdhcyBlc3RpbWF0aW9uXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImVzdGltYXRlR2FzXCIgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCBydW5uZXIuZXN0aW1hdGVHYXMoYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbihvdmVycmlkZXMpKTtcbiAgICB9O1xuICAgIGNvbnN0IG1ldGhvZCA9IGFzeW5jIChvdmVycmlkZXMpID0+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlbmQob3ZlcnJpZGVzKTtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnRpZXMobWV0aG9kLCB7XG4gICAgICAgIF9jb250cmFjdDogY29udHJhY3QsXG4gICAgICAgIGVzdGltYXRlR2FzLFxuICAgICAgICBwb3B1bGF0ZVRyYW5zYWN0aW9uLFxuICAgICAgICBzZW5kLCBzdGF0aWNDYWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkV3JhcHBlZE1ldGhvZChjb250cmFjdCwga2V5KSB7XG4gICAgY29uc3QgZ2V0RnJhZ21lbnQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRGdW5jdGlvbihrZXksIGFyZ3MpO1xuICAgICAgICBhc3NlcnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnJhZ21lbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICBpbmZvOiB7IGtleSwgYXJncyB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgfTtcbiAgICBjb25zdCBwb3B1bGF0ZVRyYW5zYWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBnZXRGcmFnbWVudCguLi5hcmdzKTtcbiAgICAgICAgLy8gSWYgYW4gb3ZlcnJpZGVzIHdhcyBwYXNzZWQgaW4sIGNvcHkgaXQgYW5kIG5vcm1hbGl6ZSB0aGUgdmFsdWVzXG4gICAgICAgIGxldCBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggKyAxID09PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgb3ZlcnJpZGVzID0gYXdhaXQgY29weU92ZXJyaWRlcyhhcmdzLnBvcCgpKTtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZXMuZnJvbSkge1xuICAgICAgICAgICAgICAgIG92ZXJyaWRlcy5mcm9tID0gYXdhaXQgcmVzb2x2ZUFkZHJlc3Mob3ZlcnJpZGVzLmZyb20sIGdldFJlc29sdmVyKGNvbnRyYWN0LnJ1bm5lcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoICE9PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJuYWwgZXJyb3I6IGZyYWdtZW50IGlucHV0cyBkb2Vzbid0IG1hdGNoIGFyZ3VtZW50czsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRBcmdzID0gYXdhaXQgcmVzb2x2ZUFyZ3MoY29udHJhY3QucnVubmVyLCBmcmFnbWVudC5pbnB1dHMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3ZlcnJpZGVzLCBhd2FpdCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICB0bzogY29udHJhY3QuZ2V0QWRkcmVzcygpLFxuICAgICAgICAgICAgZGF0YTogY29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgcmVzb2x2ZWRBcmdzKVxuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNDYWxsID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RhdGljQ2FsbFJlc3VsdCguLi5hcmdzKTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGNvbnN0IHNlbmQgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBjb250cmFjdC5ydW5uZXI7XG4gICAgICAgIGFzc2VydChjYW5TZW5kKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgc2VuZGluZyB0cmFuc2FjdGlvbnNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwic2VuZFRyYW5zYWN0aW9uXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcnVubmVyLnNlbmRUcmFuc2FjdGlvbihhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKC4uLmFyZ3MpKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihjb250cmFjdC5ydW5uZXIpO1xuICAgICAgICAvLyBAVE9ETzogdGhlIHByb3ZpZGVyIGNhbiBiZSBudWxsOyBtYWtlIGEgY3VzdG9tIGR1bW15IHByb3ZpZGVyIHRoYXQgd2lsbCB0aHJvdyBhXG4gICAgICAgIC8vIG1lYW5pbmdmdWwgZXJyb3JcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UoY29udHJhY3QuaW50ZXJmYWNlLCBwcm92aWRlciwgdHgpO1xuICAgIH07XG4gICAgY29uc3QgZXN0aW1hdGVHYXMgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBnZXRSdW5uZXIoY29udHJhY3QucnVubmVyLCBcImVzdGltYXRlR2FzXCIpO1xuICAgICAgICBhc3NlcnQoY2FuRXN0aW1hdGUocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBnYXMgZXN0aW1hdGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJlc3RpbWF0ZUdhc1wiIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgcnVubmVyLmVzdGltYXRlR2FzKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24oLi4uYXJncykpO1xuICAgIH07XG4gICAgY29uc3Qgc3RhdGljQ2FsbFJlc3VsdCA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiY2FsbFwiKTtcbiAgICAgICAgYXNzZXJ0KGNhbkNhbGwocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBjYWxsaW5nXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImNhbGxcIiB9KTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKC4uLmFyZ3MpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgcnVubmVyLmNhbGwodHgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQ2FsbEV4Y2VwdGlvbihlcnJvcikgJiYgZXJyb3IuZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNvbnRyYWN0LmludGVyZmFjZS5tYWtlRXJyb3IoZXJyb3IuZGF0YSwgdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBnZXRGcmFnbWVudCguLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgcmVzdWx0KTtcbiAgICB9O1xuICAgIGNvbnN0IG1ldGhvZCA9IGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZ2V0RnJhZ21lbnQoLi4uYXJncyk7XG4gICAgICAgIGlmIChmcmFnbWVudC5jb25zdGFudCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHN0YXRpY0NhbGwoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlbmQoLi4uYXJncyk7XG4gICAgfTtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKG1ldGhvZCwge1xuICAgICAgICBuYW1lOiBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RnVuY3Rpb25OYW1lKGtleSksXG4gICAgICAgIF9jb250cmFjdDogY29udHJhY3QsIF9rZXk6IGtleSxcbiAgICAgICAgZ2V0RnJhZ21lbnQsXG4gICAgICAgIGVzdGltYXRlR2FzLFxuICAgICAgICBwb3B1bGF0ZVRyYW5zYWN0aW9uLFxuICAgICAgICBzZW5kLCBzdGF0aWNDYWxsLCBzdGF0aWNDYWxsUmVzdWx0LFxuICAgIH0pO1xuICAgIC8vIE9ubHkgd29ya3Mgb24gbm9uLWFtYmlndW91cyBrZXlzIChyZWZpbmVkIGZyYWdtZW50IGlzIGFsd2F5cyBub24tYW1iaWd1b3VzKVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRob2QsIFwiZnJhZ21lbnRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEZ1bmN0aW9uKGtleSk7XG4gICAgICAgICAgICBhc3NlcnQoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnJhZ21lbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgICAgIGluZm86IHsga2V5IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkV3JhcHBlZEV2ZW50KGNvbnRyYWN0LCBrZXkpIHtcbiAgICBjb25zdCBnZXRGcmFnbWVudCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KGtleSwgYXJncyk7XG4gICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgIGluZm86IHsga2V5LCBhcmdzIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICB9O1xuICAgIGNvbnN0IG1ldGhvZCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJlcGFyZWRUb3BpY0ZpbHRlcihjb250cmFjdCwgZ2V0RnJhZ21lbnQoLi4uYXJncyksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmaW5lUHJvcGVydGllcyhtZXRob2QsIHtcbiAgICAgICAgbmFtZTogY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50TmFtZShrZXkpLFxuICAgICAgICBfY29udHJhY3Q6IGNvbnRyYWN0LCBfa2V5OiBrZXksXG4gICAgICAgIGdldEZyYWdtZW50XG4gICAgfSk7XG4gICAgLy8gT25seSB3b3JrcyBvbiBub24tYW1iaWd1b3VzIGtleXMgKHJlZmluZWQgZnJhZ21lbnQgaXMgYWx3YXlzIG5vbi1hbWJpZ3VvdXMpXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGhvZCwgXCJmcmFnbWVudFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoa2V5KTtcbiAgICAgICAgICAgIGFzc2VydChmcmFnbWVudCwgXCJubyBtYXRjaGluZyBmcmFnbWVudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyBrZXkgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxuLy8gVGhlIGNvbWJpbmF0aW9uIG9mIFR5cGVTY3J5cGUsIFByaXZhdGUgRmllbGRzIGFuZCBQcm94aWVzIG1ha2VzXG4vLyB0aGUgd29ybGQgZ28gYm9vbTsgc28gd2UgaGlkZSB2YXJpYWJsZXMgd2l0aCBzb21lIHRyaWNrZXJ5IGtlZXBpbmdcbi8vIGEgc3ltYm9sIGF0dGFjaGVkIHRvIGVhY2ggQmFzZUNvbnRyYWN0IHdoaWNoIGl0cyBzdWItY2xhc3MgKGV2ZW5cbi8vIHZpYSBhIFByb3h5KSBjYW4gcmVhY2ggYW5kIHVzZSB0byBsb29rIHVwIGl0cyBpbnRlcm5hbCB2YWx1ZXMuXG5jb25zdCBpbnRlcm5hbCA9IFN5bWJvbC5mb3IoXCJfZXRoZXJzSW50ZXJuYWxfY29udHJhY3RcIik7XG5jb25zdCBpbnRlcm5hbFZhbHVlcyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBzZXRJbnRlcm5hbChjb250cmFjdCwgdmFsdWVzKSB7XG4gICAgaW50ZXJuYWxWYWx1ZXMuc2V0KGNvbnRyYWN0W2ludGVybmFsXSwgdmFsdWVzKTtcbn1cbmZ1bmN0aW9uIGdldEludGVybmFsKGNvbnRyYWN0KSB7XG4gICAgcmV0dXJuIGludGVybmFsVmFsdWVzLmdldChjb250cmFjdFtpbnRlcm5hbF0pO1xufVxuZnVuY3Rpb24gaXNEZWZlcnJlZCh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgKFwiZ2V0VG9waWNGaWx0ZXJcIiBpbiB2YWx1ZSkgJiZcbiAgICAgICAgKHR5cGVvZiAodmFsdWUuZ2V0VG9waWNGaWx0ZXIpID09PSBcImZ1bmN0aW9uXCIpICYmIHZhbHVlLmZyYWdtZW50KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFN1YkluZm8oY29udHJhY3QsIGV2ZW50KSB7XG4gICAgbGV0IHRvcGljcztcbiAgICBsZXQgZnJhZ21lbnQgPSBudWxsO1xuICAgIC8vIENvbnZlcnQgbmFtZWQgZXZlbnRzIHRvIHRvcGljSGFzaCBhbmQgZ2V0IHRoZSBmcmFnbWVudCBmb3JcbiAgICAvLyBldmVudHMgd2hpY2ggbmVlZCBkZWNvbnN0cnVjdGluZy5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgY29uc3QgdG9waWNIYXNoaWZ5ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhuYW1lLCAzMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KG5hbWUpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZnJhZ21lbnQsIFwidW5rbm93biBmcmFnbWVudFwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQudG9waWNIYXNoO1xuICAgICAgICB9O1xuICAgICAgICAvLyBBcnJheSBvZiBUb3BpY3MgYW5kIE5hbWVzOyBlLmcuIGBbIFwiMHgxMjM0Li4uODlhYlwiLCBcIlRyYW5zZmVyKGFkZHJlc3MpXCIgXWBcbiAgICAgICAgdG9waWNzID0gZXZlbnQubWFwKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLm1hcCh0b3BpY0hhc2hpZnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvcGljSGFzaGlmeShlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV2ZW50ID09PSBcIipcIikge1xuICAgICAgICB0b3BpY3MgPSBbbnVsbF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAoZXZlbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChpc0hleFN0cmluZyhldmVudCwgMzIpKSB7XG4gICAgICAgICAgICAvLyBUb3BpYyBIYXNoXG4gICAgICAgICAgICB0b3BpY3MgPSBbZXZlbnRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTmFtZSBvciBTaWduYXR1cmU7IGUuZy4gYFwiVHJhbnNmZXJcIiwgYFwiVHJhbnNmZXIoYWRkcmVzcylcImBcbiAgICAgICAgICAgIGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZyYWdtZW50LCBcInVua25vd24gZnJhZ21lbnRcIiwgXCJldmVudFwiLCBldmVudCk7XG4gICAgICAgICAgICB0b3BpY3MgPSBbZnJhZ21lbnQudG9waWNIYXNoXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc0RlZmVycmVkKGV2ZW50KSkge1xuICAgICAgICAvLyBEZWZlcnJlZCBUb3BpYyBGaWx0ZXI7IGUuZy4gYGNvbnRyYWN0LmZpbHRlci5UcmFuc2Zlcihmcm9tKWBcbiAgICAgICAgdG9waWNzID0gYXdhaXQgZXZlbnQuZ2V0VG9waWNGaWx0ZXIoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXCJmcmFnbWVudFwiIGluIGV2ZW50KSB7XG4gICAgICAgIC8vIENvbnRyYWN0RXZlbnQ7IGUuZy4gYGNvbnRyYWN0LmZpbHRlci5UcmFuc2ZlcmBcbiAgICAgICAgZnJhZ21lbnQgPSBldmVudC5mcmFnbWVudDtcbiAgICAgICAgdG9waWNzID0gW2ZyYWdtZW50LnRvcGljSGFzaF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NlcnRBcmd1bWVudChmYWxzZSwgXCJ1bmtub3duIGV2ZW50IG5hbWVcIiwgXCJldmVudFwiLCBldmVudCk7XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSB0b3BpY3MgYW5kIHNvcnQgVG9waWNTZXRzXG4gICAgdG9waWNzID0gdG9waWNzLm1hcCgodCkgPT4ge1xuICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5mcm9tKG5ldyBTZXQodC5tYXAoKHQpID0+IHQudG9Mb3dlckNhc2UoKSkpLnZhbHVlcygpKTtcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtcy5zb3J0KCk7XG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcbiAgICBjb25zdCB0YWcgPSB0b3BpY3MubWFwKCh0KSA9PiB7XG4gICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHQuam9pbihcInxcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSkuam9pbihcIiZcIik7XG4gICAgcmV0dXJuIHsgZnJhZ21lbnQsIHRhZywgdG9waWNzIH07XG59XG5hc3luYyBmdW5jdGlvbiBoYXNTdWIoY29udHJhY3QsIGV2ZW50KSB7XG4gICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbChjb250cmFjdCk7XG4gICAgcmV0dXJuIHN1YnMuZ2V0KChhd2FpdCBnZXRTdWJJbmZvKGNvbnRyYWN0LCBldmVudCkpLnRhZykgfHwgbnVsbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFN1Yihjb250cmFjdCwgb3BlcmF0aW9uLCBldmVudCkge1xuICAgIC8vIE1ha2Ugc3VyZSBvdXIgcnVubmVyIGNhbiBhY3R1YWxseSBzdWJzY3JpYmUgdG8gZXZlbnRzXG4gICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihjb250cmFjdC5ydW5uZXIpO1xuICAgIGFzc2VydChwcm92aWRlciwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBzdWJzY3JpYmluZ1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbiB9KTtcbiAgICBjb25zdCB7IGZyYWdtZW50LCB0YWcsIHRvcGljcyB9ID0gYXdhaXQgZ2V0U3ViSW5mbyhjb250cmFjdCwgZXZlbnQpO1xuICAgIGNvbnN0IHsgYWRkciwgc3VicyB9ID0gZ2V0SW50ZXJuYWwoY29udHJhY3QpO1xuICAgIGxldCBzdWIgPSBzdWJzLmdldCh0YWcpO1xuICAgIGlmICghc3ViKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSAoYWRkciA/IGFkZHIgOiBjb250cmFjdCk7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHsgYWRkcmVzcywgdG9waWNzIH07XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKGxvZykgPT4ge1xuICAgICAgICAgICAgbGV0IGZvdW5kRnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWdtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZEZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgZnJhZ21lbnQgaXMgbnVsbCwgd2UgZG8gbm90IGRlY29uc3RydWN0IHRoZSBhcmdzIHRvIGVtaXRcbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2ZvdW5kRnJhZ21lbnQgPSBmb3VuZEZyYWdtZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBmcmFnbWVudCA/IGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpIDogW107XG4gICAgICAgICAgICAgICAgZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0RXZlbnRQYXlsb2FkKGNvbnRyYWN0LCBsaXN0ZW5lciwgZXZlbnQsIF9mb3VuZEZyYWdtZW50LCBsb2cpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW1pdChjb250cmFjdCwgZXZlbnQsIFtdLCAobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFVua25vd25FdmVudFBheWxvYWQoY29udHJhY3QsIGxpc3RlbmVyLCBldmVudCwgbG9nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHN0YXJ0aW5nID0gW107XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXJ0aW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0aW5nLnB1c2gocHJvdmlkZXIub24oZmlsdGVyLCBsaXN0ZW5lcikpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdG9wID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXJ0aW5nLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0ZWQgPSBzdGFydGluZztcbiAgICAgICAgICAgIHN0YXJ0aW5nID0gW107XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChzdGFydGVkKTtcbiAgICAgICAgICAgIHByb3ZpZGVyLm9mZihmaWx0ZXIsIGxpc3RlbmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3ViID0geyB0YWcsIGxpc3RlbmVyczogW10sIHN0YXJ0LCBzdG9wIH07XG4gICAgICAgIHN1YnMuc2V0KHRhZywgc3ViKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Yjtcbn1cbi8vIFdlIHVzZSB0aGlzIHRvIGVuc3VyZSBvbmUgZW1pdCByZXNvbHZlcyBiZWZvcmUgZmlyaW5nIHRoZSBuZXh0IHRvXG4vLyBlbnN1cmUgY29ycmVjdCBvcmRlcmluZyAobm90ZSB0aGlzIGNhbm5vdCB0aHJvdyBhbmQganVzdCBhZGRzIHRoZVxuLy8gbm90aWNlIHRvIHRoZSBldmVudCBxdWV1IHVzaW5nIHNldFRpbWVvdXQpLlxubGV0IGxhc3RFbWl0ID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5hc3luYyBmdW5jdGlvbiBfZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIHBheWxvYWRGdW5jKSB7XG4gICAgYXdhaXQgbGFzdEVtaXQ7XG4gICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKGNvbnRyYWN0LCBldmVudCk7XG4gICAgaWYgKCFzdWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb3VudCA9IHN1Yi5saXN0ZW5lcnMubGVuZ3RoO1xuICAgIHN1Yi5saXN0ZW5lcnMgPSBzdWIubGlzdGVuZXJzLmZpbHRlcigoeyBsaXN0ZW5lciwgb25jZSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhc3NBcmdzID0gQXJyYXkuZnJvbShhcmdzKTtcbiAgICAgICAgaWYgKHBheWxvYWRGdW5jKSB7XG4gICAgICAgICAgICBwYXNzQXJncy5wdXNoKHBheWxvYWRGdW5jKG9uY2UgPyBudWxsIDogbGlzdGVuZXIpKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGlzdGVuZXIuY2FsbChjb250cmFjdCwgLi4ucGFzc0FyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiAhb25jZTtcbiAgICB9KTtcbiAgICBpZiAoc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3ViLnN0b3AoKTtcbiAgICAgICAgZ2V0SW50ZXJuYWwoY29udHJhY3QpLnN1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgIH1cbiAgICByZXR1cm4gKGNvdW50ID4gMCk7XG59XG5hc3luYyBmdW5jdGlvbiBlbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgcGF5bG9hZEZ1bmMpIHtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBsYXN0RW1pdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICBjb25zdCByZXN1bHRQcm9taXNlID0gX2VtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCBwYXlsb2FkRnVuYyk7XG4gICAgbGFzdEVtaXQgPSByZXN1bHRQcm9taXNlO1xuICAgIHJldHVybiBhd2FpdCByZXN1bHRQcm9taXNlO1xufVxuY29uc3QgcGFzc1Byb3BlcnRpZXMgPSBbXCJ0aGVuXCJdO1xuZXhwb3J0IGNsYXNzIEJhc2VDb250cmFjdCB7XG4gICAgLyoqXG4gICAgICogIFRoZSB0YXJnZXQgdG8gY29ubmVjdCB0by5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiBiZSBhbiBhZGRyZXNzLCBFTlMgbmFtZSBvciBhbnkgW1tBZGRyZXNzYWJsZV1dLCBzdWNoIGFzXG4gICAgICogIGFub3RoZXIgY29udHJhY3QuIFRvIGdldCB0aGUgcmVzb3ZsZWQgYWRkcmVzcywgdXNlIHRoZSBgYGdldEFkZHJlc3NgYFxuICAgICAqICBtZXRob2QuXG4gICAgICovXG4gICAgdGFyZ2V0O1xuICAgIC8qKlxuICAgICAqICBUaGUgY29udHJhY3QgSW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGludGVyZmFjZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbm5lY3RlZCBydW5uZXIuIFRoaXMgaXMgZ2VuZXJhbGx5IGEgW1tQcm92aWRlcl1dIG9yIGFcbiAgICAgKiAgW1tTaWduZXJdXSwgd2hpY2ggZGljdGF0ZXMgd2hhdCBvcGVyYXRpb25zIGFyZSBzdXBwb3J0ZWQuXG4gICAgICpcbiAgICAgKiAgRm9yIGV4YW1wbGUsIGEgKipDb250cmFjdCoqIGNvbm5lY3RlZCB0byBhIFtbUHJvdmlkZXJdXSBtYXlcbiAgICAgKiAgb25seSBleGVjdXRlIHJlYWQtb25seSBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIHJ1bm5lcjtcbiAgICAvKipcbiAgICAgKiAgQWxsIHRoZSBFdmVudHMgYXZhaWxhYmxlIG9uIHRoaXMgY29udHJhY3QuXG4gICAgICovXG4gICAgZmlsdGVycztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgW2ludGVybmFsXTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZhbGxiYWNrIG9yIHJlY2VpdmUgZnVuY3Rpb24gaWYgYW55LlxuICAgICAqL1xuICAgIGZhbGxiYWNrO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IGNvbnRyYWN0IGNvbm5lY3RlZCB0byAlJXRhcmdldCUlIHdpdGggdGhlICUlYWJpJSUgYW5kXG4gICAgICogIG9wdGlvbmFsbHkgY29ubmVjdGVkIHRvIGEgJSVydW5uZXIlJSB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gYmVoYWxmXG4gICAgICogIG9mLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgYWJpLCBydW5uZXIsIF9kZXBsb3lUeCkge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIgfHwgaXNBZGRyZXNzYWJsZSh0YXJnZXQpLCBcImludmFsaWQgdmFsdWUgZm9yIENvbnRyYWN0IHRhcmdldFwiLCBcInRhcmdldFwiLCB0YXJnZXQpO1xuICAgICAgICBpZiAocnVubmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJ1bm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWZhY2UgPSBJbnRlcmZhY2UuZnJvbShhYmkpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgdGFyZ2V0LCBydW5uZXIsIGludGVyZmFjZTogaWZhY2UgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZToge30gfSk7XG4gICAgICAgIGxldCBhZGRyUHJvbWlzZTtcbiAgICAgICAgbGV0IGFkZHIgPSBudWxsO1xuICAgICAgICBsZXQgZGVwbG95VHggPSBudWxsO1xuICAgICAgICBpZiAoX2RlcGxveVR4KSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHJ1bm5lcik7XG4gICAgICAgICAgICAvLyBAVE9ETzogdGhlIHByb3ZpZGVyIGNhbiBiZSBudWxsOyBtYWtlIGEgY3VzdG9tIGR1bW15IHByb3ZpZGVyIHRoYXQgd2lsbCB0aHJvdyBhXG4gICAgICAgICAgICAvLyBtZWFuaW5nZnVsIGVycm9yXG4gICAgICAgICAgICBkZXBsb3lUeCA9IG5ldyBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UodGhpcy5pbnRlcmZhY2UsIHByb3ZpZGVyLCBfZGVwbG95VHgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBSZXNvbHZlIHRoZSB0YXJnZXQgYXMgdGhlIGFkZHJlc3NcbiAgICAgICAgaWYgKHR5cGVvZiAodGFyZ2V0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBhZGRyID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIGFkZHJQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IGdldFJ1bm5lcihydW5uZXIsIFwicmVzb2x2ZU5hbWVcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5SZXNvbHZlKHJlc29sdmVyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBtYWtlRXJyb3IoXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBuYW1lIHJlc29sdXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlc29sdmVOYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZHJQcm9taXNlID0gcmVzb2x2ZXIucmVzb2x2ZU5hbWUodGFyZ2V0KS50aGVuKChhZGRyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG1ha2VFcnJvcihcImFuIEVOUyBuYW1lIHVzZWQgZm9yIGEgY29udHJhY3QgdGFyZ2V0IG11c3QgYmUgY29ycmVjdGx5IGNvbmZpZ3VyZWRcIiwgXCJVTkNPTkZJR1VSRURfTkFNRVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuYWRkciA9IGFkZHI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWRkclByb21pc2UgPSB0YXJnZXQuZ2V0QWRkcmVzcygpLnRoZW4oKGFkZHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLmFkZHIgPSBhZGRyO1xuICAgICAgICAgICAgICAgIHJldHVybiBhZGRyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IG91ciBwcml2YXRlIHZhbHVlc1xuICAgICAgICBzZXRJbnRlcm5hbCh0aGlzLCB7IGFkZHJQcm9taXNlLCBhZGRyLCBkZXBsb3lUeCwgc3VicyB9KTtcbiAgICAgICAgLy8gQWRkIHRoZSBldmVudCBmaWx0ZXJzXG4gICAgICAgIGNvbnN0IGZpbHRlcnMgPSBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQYXNzIGltcG9ydGFudCBjaGVja3MgKGxpa2UgYHRoZW5gIGZvciBQcm9taXNlKSB0aHJvdWdoXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3ltYm9sXCIgfHwgcGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXZlbnQocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRXJyb3IoZXJyb3IsIFwiSU5WQUxJRF9BUkdVTUVOVFwiKSB8fCBlcnJvci5hcmd1bWVudCAhPT0gXCJrZXlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXM6ICh0YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQYXNzIGltcG9ydGFudCBjaGVja3MgKGxpa2UgYHRoZW5gIGZvciBQcm9taXNlKSB0aHJvdWdoXG4gICAgICAgICAgICAgICAgaWYgKHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCkgfHwgdGhpcy5pbnRlcmZhY2UuaGFzRXZlbnQoU3RyaW5nKHByb3ApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBmaWx0ZXJzIH0pO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgICAgICAgIGZhbGxiYWNrOiAoKGlmYWNlLnJlY2VpdmUgfHwgaWZhY2UuZmFsbGJhY2spID8gKGJ1aWxkV3JhcHBlZEZhbGxiYWNrKHRoaXMpKSA6IG51bGwpXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZXR1cm4gYSBQcm94eSB0aGF0IHdpbGwgcmVzcG9uZCB0byBmdW5jdGlvbnNcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh0aGlzLCB7XG4gICAgICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3ltYm9sXCIgfHwgcHJvcCBpbiB0YXJnZXQgfHwgcGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5kZWZpbmVkIHByb3BlcnRpZXMgc2hvdWxkIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmdldEZ1bmN0aW9uKHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Vycm9yKGVycm9yLCBcIklOVkFMSURfQVJHVU1FTlRcIikgfHwgZXJyb3IuYXJndW1lbnQgIT09IFwia2V5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3ltYm9sXCIgfHwgcHJvcCBpbiB0YXJnZXQgfHwgcGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmludGVyZmFjZS5oYXNGdW5jdGlvbihwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgQ29udHJhY3QgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSB0YXJnZXQgYW5kIEFCSSwgYnV0XG4gICAgICogIGEgZGlmZmVyZW50ICUlcnVubmVyJSUuXG4gICAgICovXG4gICAgY29ubmVjdChydW5uZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlQ29udHJhY3QodGhpcy50YXJnZXQsIHRoaXMuaW50ZXJmYWNlLCBydW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IENvbnRyYWN0IGluc3RhbmNlIHdpdGggdGhlIHNhbWUgQUJJIGFuZCBydW5uZXIsIGJ1dFxuICAgICAqICBhIGRpZmZlcmVudCAlJXRhcmdldCUlLlxuICAgICAqL1xuICAgIGF0dGFjaCh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlQ29udHJhY3QodGFyZ2V0LCB0aGlzLmludGVyZmFjZSwgdGhpcy5ydW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSByZXNvbHZlZCBhZGRyZXNzIG9mIHRoaXMgQ29udHJhY3QuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWRkcmVzcygpIHsgcmV0dXJuIGF3YWl0IGdldEludGVybmFsKHRoaXMpLmFkZHJQcm9taXNlOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZGVwbG95ZWQgYnl0ZWNvZGUgb3IgbnVsbCBpZiBubyBieXRlY29kZSBpcyBmb3VuZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXREZXBsb3llZENvZGUoKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICBhc3NlcnQocHJvdmlkZXIsIFwicnVubmVyIGRvZXMgbm90IHN1cHBvcnQgLnByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImdldERlcGxveWVkQ29kZVwiIH0pO1xuICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgcHJvdmlkZXIuZ2V0Q29kZShhd2FpdCB0aGlzLmdldEFkZHJlc3MoKSk7XG4gICAgICAgIGlmIChjb2RlID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZSB0byB0aGlzIENvbnRyYWN0IG9uY2UgdGhlIGJ5dGVjb2RlIGhhcyBiZWVuIGRlcGxveWVkLCBvclxuICAgICAqICByZXNvbHZlIGltbWVkaWF0ZWx5IGlmIGFscmVhZHkgZGVwbG95ZWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdEZvckRlcGxveW1lbnQoKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdGhlIGRlcGxveWVtZW50IHRyYW5zYWN0aW9uOyBqdXN0IHVzZSB0aGF0ICh0aHJvd3MgaWYgZGVwbG95ZW1lbnQgZmFpbHMpXG4gICAgICAgIGNvbnN0IGRlcGxveVR4ID0gdGhpcy5kZXBsb3ltZW50VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgaWYgKGRlcGxveVR4KSB7XG4gICAgICAgICAgICBhd2FpdCBkZXBsb3lUeC53YWl0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3IgY29kZVxuICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgdGhpcy5nZXREZXBsb3llZENvZGUoKTtcbiAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGNhbiBzdWJzY3JpYmUgdG8gYSBwcm92aWRlciBldmVudFxuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcbiAgICAgICAgYXNzZXJ0KHByb3ZpZGVyICE9IG51bGwsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgLnByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIndhaXRGb3JEZXBsb3ltZW50XCIgfSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGVja0NvZGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHRoaXMuZ2V0RGVwbG95ZWRDb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLm9uY2UoXCJibG9ja1wiLCBjaGVja0NvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2hlY2tDb2RlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSB0cmFuc2FjdGlvbiB1c2VkIHRvIGRlcGxveSB0aGlzIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgb25seSBhdmFpbGFibGUgaWYgdGhpcyBpbnN0YW5jZSB3YXMgcmV0dXJuZWQgZnJvbSBhXG4gICAgICogIFtbQ29udHJhY3RGYWN0b3J5XV0uXG4gICAgICovXG4gICAgZGVwbG95bWVudFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWwodGhpcykuZGVwbG95VHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG5hbWUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBjb250cmFjdFxuICAgICAqICBtZXRob2QgbmFtZSBjb25mbGljdHMgd2l0aCBhIEphdmFTY3JpcHQgbmFtZSBzdWNoIGFzIGBgcHJvdG90eXBlYGAgb3JcbiAgICAgKiAgd2hlbiB1c2luZyBhIENvbnRyYWN0IHByb2dyYW1hdGljYWxseS5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoa2V5KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAga2V5ID0ga2V5LmZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBidWlsZFdyYXBwZWRNZXRob2QodGhpcywga2V5KTtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGV2ZW50IGZvciBhIGdpdmVuIG5hbWUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBjb250cmFjdFxuICAgICAqICBldmVudCBuYW1lIGNvbmZsaWN0cyB3aXRoIGEgSmF2YVNjcmlwdCBuYW1lIHN1Y2ggYXMgYGBwcm90b3R5cGVgYCBvclxuICAgICAqICB3aGVuIHVzaW5nIGEgQ29udHJhY3QgcHJvZ3JhbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIGdldEV2ZW50KGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIChrZXkpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuZm9ybWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkV3JhcHBlZEV2ZW50KHRoaXMsIGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBhc3luYyBxdWVyeVRyYW5zYWN0aW9uKGhhc2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgfVxuICAgIC8qXG4gICAgLy8gQFRPRE86IHRoaXMgaXMgYSBub24tYmFja3dhcmRzIGNvbXBhdGlibGUgY2hhbmdlLCBidXQgd2lsbCBiZSBhZGRlZFxuICAgIC8vICAgICAgICBpbiB2NyBhbmQgaW4gYSBwb3RlbnRpYWwgU21hcnRDb250cmFjdCBjbGFzcyBpbiBhbiB1cGNvbWluZ1xuICAgIC8vICAgICAgICB2NiByZWxlYXNlXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2g6IHN0cmluZyk6IFByb21pc2U8bnVsbCB8IENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0PiB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICBhc3NlcnQocHJvdmlkZXIsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IGhhdmUgYSBwcm92aWRlclwiLFxuICAgICAgICAgICAgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicXVlcnlUcmFuc2FjdGlvblwiIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMuaW50ZXJmYWNlLCBwcm92aWRlciwgcmVjZWlwdCk7XG4gICAgfVxuICAgICovXG4gICAgLyoqXG4gICAgICogIFByb3ZpZGUgaGlzdG9yaWMgYWNjZXNzIHRvIGV2ZW50IGRhdGEgZm9yICUlZXZlbnQlJSBpbiB0aGUgcmFuZ2VcbiAgICAgKiAgJSVmcm9tQmxvY2slJSAoZGVmYXVsdDogYGAwYGApIHRvICUldG9CbG9jayUlIChkZWZhdWx0OiBgYFwibGF0ZXN0XCJgYClcbiAgICAgKiAgaW5jbHVzaXZlLlxuICAgICAqL1xuICAgIGFzeW5jIHF1ZXJ5RmlsdGVyKGV2ZW50LCBmcm9tQmxvY2ssIHRvQmxvY2spIHtcbiAgICAgICAgaWYgKGZyb21CbG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICBmcm9tQmxvY2sgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b0Jsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRvQmxvY2sgPSBcImxhdGVzdFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYWRkciwgYWRkclByb21pc2UgfSA9IGdldEludGVybmFsKHRoaXMpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gKGFkZHIgPyBhZGRyIDogKGF3YWl0IGFkZHJQcm9taXNlKSk7XG4gICAgICAgIGNvbnN0IHsgZnJhZ21lbnQsIHRvcGljcyB9ID0gYXdhaXQgZ2V0U3ViSW5mbyh0aGlzLCBldmVudCk7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHsgYWRkcmVzcywgdG9waWNzLCBmcm9tQmxvY2ssIHRvQmxvY2sgfTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgIGFzc2VydChwcm92aWRlciwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3QgaGF2ZSBhIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInF1ZXJ5RmlsdGVyXCIgfSk7XG4gICAgICAgIHJldHVybiAoYXdhaXQgcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpKS5tYXAoKGxvZykgPT4ge1xuICAgICAgICAgICAgbGV0IGZvdW5kRnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWdtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZEZyYWdtZW50ID0gdGhpcy5pbnRlcmZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRMb2cobG9nLCB0aGlzLmludGVyZmFjZSwgZm91bmRGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVuZGVjb2RlZEV2ZW50TG9nKGxvZywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9nKGxvZywgcHJvdmlkZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFkZCBhbiBldmVudCAlJWxpc3RlbmVyJSUgZm9yIHRoZSAlJWV2ZW50JSUuXG4gICAgICovXG4gICAgYXN5bmMgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGdldFN1Yih0aGlzLCBcIm9uXCIsIGV2ZW50KTtcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IGZhbHNlIH0pO1xuICAgICAgICBzdWIuc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBZGQgYW4gZXZlbnQgJSVsaXN0ZW5lciUlIGZvciB0aGUgJSVldmVudCUlLCBidXQgcmVtb3ZlIHRoZSBsaXN0ZW5lclxuICAgICAqICBhZnRlciBpdCBpcyBmaXJlZCBvbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGdldFN1Yih0aGlzLCBcIm9uY2VcIiwgZXZlbnQpO1xuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgc3ViLnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW1pdCBhbiAlJWV2ZW50JSUgY2FsbGluZyBhbGwgbGlzdGVuZXJzIHdpdGggJSVhcmdzJSUuXG4gICAgICpcbiAgICAgKiAgUmVzb2x2ZXMgdG8gYGB0cnVlYGAgaWYgYW55IGxpc3RlbmVycyB3ZXJlIGNhbGxlZC5cbiAgICAgKi9cbiAgICBhc3luYyBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBlbWl0KHRoaXMsIGV2ZW50LCBhcmdzLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIG9mICUlZXZlbnQlJSBvciB0aGUgdG90YWwgbnVtYmVyXG4gICAgICogIG9mIGxpc3RlbmVycyBpZiB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3ViLmxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcbiAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgZm9yIChjb25zdCB7IGxpc3RlbmVycyB9IG9mIHN1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHRvdGFsICs9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGxpc3RlbmVycyBzdWJzY3JpYmVkIHRvICUlZXZlbnQlJSBvciBhbGwgbGlzdGVuZXJzXG4gICAgICogIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2Ygc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChsaXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlbW92ZSB0aGUgJSVsaXN0ZW5lciUlIGZyb20gdGhlIGxpc3RlbmVycyBmb3IgJSVldmVudCUlIG9yIHJlbW92ZVxuICAgICAqICBhbGwgbGlzdGVuZXJzIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIG9mZihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzdWIubGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcikuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHN1Yi5saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCB8fCBzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc3ViLnN0b3AoKTtcbiAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLnN1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIGZvciAlJWV2ZW50JSUgb3IgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgaWZcbiAgICAgKiAgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWIuc3RvcCgpO1xuICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKHRoaXMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IHRhZywgc3RvcCB9IG9mIHN1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICAgc3Vicy5kZWxldGUodGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFsaWFzIGZvciBbb25dLlxuICAgICAqL1xuICAgIGFzeW5jIGFkZExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWxpYXMgZm9yIFtvZmZdLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBDbGFzcyBmb3IgdGhlICUlYWJpJSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ1aWxkQ2xhc3MoYWJpKSB7XG4gICAgICAgIGNsYXNzIEN1c3RvbUNvbnRyYWN0IGV4dGVuZHMgQmFzZUNvbnRyYWN0IHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHJ1bm5lciA9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdXBlcihhZGRyZXNzLCBhYmksIHJ1bm5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEN1c3RvbUNvbnRyYWN0O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBCYXNlQ29udHJhY3Qgd2l0aCBhIHNwZWNpZmllZCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odGFyZ2V0LCBhYmksIHJ1bm5lcikge1xuICAgICAgICBpZiAocnVubmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJ1bm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgdGhpcyh0YXJnZXQsIGFiaSwgcnVubmVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9Db250cmFjdEJhc2UoKSB7XG4gICAgcmV0dXJuIEJhc2VDb250cmFjdDtcbn1cbi8qKlxuICogIEEgW1tCYXNlQ29udHJhY3RdXSB3aXRoIG5vIHR5cGUgZ3VhcmRzIG9uIGl0cyBtZXRob2RzIG9yIGV2ZW50cy5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0IGV4dGVuZHMgX0NvbnRyYWN0QmFzZSgpIHtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRyYWN0LmpzLm1hcCJdLCJuYW1lcyI6WyJJbnRlcmZhY2UiLCJUeXBlZCIsImlzQWRkcmVzc2FibGUiLCJyZXNvbHZlQWRkcmVzcyIsImNvcHlSZXF1ZXN0IiwiTG9nIiwiZGVmaW5lUHJvcGVydGllcyIsImdldEJpZ0ludCIsImlzQ2FsbEV4Y2VwdGlvbiIsImlzSGV4U3RyaW5nIiwicmVzb2x2ZVByb3BlcnRpZXMiLCJpc0Vycm9yIiwibWFrZUVycm9yIiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJDb250cmFjdEV2ZW50UGF5bG9hZCIsIkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCIsIkNvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSIsIkV2ZW50TG9nIiwiVW5kZWNvZGVkRXZlbnRMb2ciLCJCTl8wIiwiQmlnSW50IiwiY2FuQ2FsbCIsInZhbHVlIiwiY2FsbCIsImNhbkVzdGltYXRlIiwiZXN0aW1hdGVHYXMiLCJjYW5SZXNvbHZlIiwicmVzb2x2ZU5hbWUiLCJjYW5TZW5kIiwic2VuZFRyYW5zYWN0aW9uIiwiZ2V0UmVzb2x2ZXIiLCJwcm92aWRlciIsInVuZGVmaW5lZCIsIlByZXBhcmVkVG9waWNGaWx0ZXIiLCJmaWx0ZXIiLCJjb25zdHJ1Y3RvciIsImNvbnRyYWN0IiwiZnJhZ21lbnQiLCJhcmdzIiwiaW5wdXRzIiwibGVuZ3RoIiwiRXJyb3IiLCJydW5uZXIiLCJnZXRSdW5uZXIiLCJyZXNvbHZlciIsInJlc29sdmVkQXJncyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJwYXJhbSIsImluZGV4IiwiYXJnIiwid2Fsa0FzeW5jIiwidHlwZSIsIkFycmF5IiwiaXNBcnJheSIsInYiLCJpbnRlcmZhY2UiLCJlbmNvZGVGaWx0ZXJUb3BpY3MiLCJnZXRUb3BpY0ZpbHRlciIsImZlYXR1cmUiLCJnZXRQcm92aWRlciIsImNvcHlPdmVycmlkZXMiLCJhbGxvd2VkIiwiX292ZXJyaWRlcyIsImRlcmVmZXJlbmNlIiwib3ZlcnJpZGVzIiwidG8iLCJpbmRleE9mIiwiZGF0YSIsImZyb20iLCJyZXNvbHZlQXJncyIsIl9ydW5uZXIiLCJidWlsZFdyYXBwZWRGYWxsYmFjayIsInBvcHVsYXRlVHJhbnNhY3Rpb24iLCJ0eCIsImdldEFkZHJlc3MiLCJpZmFjZSIsIm5vVmFsdWUiLCJub0RhdGEiLCJmYWxsYmFjayIsInBheWFibGUiLCJyZWNlaXZlIiwic3RhdGljQ2FsbCIsIm9wZXJhdGlvbiIsImVycm9yIiwic2VuZCIsIm1ldGhvZCIsIl9jb250cmFjdCIsImJ1aWxkV3JhcHBlZE1ldGhvZCIsImtleSIsImdldEZyYWdtZW50IiwiZ2V0RnVuY3Rpb24iLCJpbmZvIiwicG9wIiwiT2JqZWN0IiwiYXNzaWduIiwiZW5jb2RlRnVuY3Rpb25EYXRhIiwicmVzdWx0Iiwic3RhdGljQ2FsbFJlc3VsdCIsImRlY29kZUZ1bmN0aW9uUmVzdWx0IiwiY29uc3RhbnQiLCJuYW1lIiwiZ2V0RnVuY3Rpb25OYW1lIiwiX2tleSIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImJ1aWxkV3JhcHBlZEV2ZW50IiwiZ2V0RXZlbnQiLCJnZXRFdmVudE5hbWUiLCJpbnRlcm5hbCIsIlN5bWJvbCIsImZvciIsImludGVybmFsVmFsdWVzIiwiV2Vha01hcCIsInNldEludGVybmFsIiwidmFsdWVzIiwic2V0IiwiZ2V0SW50ZXJuYWwiLCJpc0RlZmVycmVkIiwiZ2V0U3ViSW5mbyIsImV2ZW50IiwidG9waWNzIiwidG9waWNIYXNoaWZ5IiwidG9waWNIYXNoIiwiZSIsInQiLCJpdGVtcyIsIlNldCIsInRvTG93ZXJDYXNlIiwic29ydCIsInRhZyIsImpvaW4iLCJoYXNTdWIiLCJzdWJzIiwiZ2V0U3ViIiwiYWRkciIsInN1YiIsImFkZHJlc3MiLCJsaXN0ZW5lciIsImxvZyIsImZvdW5kRnJhZ21lbnQiLCJfZm91bmRGcmFnbWVudCIsImRlY29kZUV2ZW50TG9nIiwiZW1pdCIsInN0YXJ0aW5nIiwic3RhcnQiLCJwdXNoIiwib24iLCJzdG9wIiwic3RhcnRlZCIsIm9mZiIsImxpc3RlbmVycyIsImxhc3RFbWl0IiwicmVzb2x2ZSIsIl9lbWl0IiwicGF5bG9hZEZ1bmMiLCJjb3VudCIsIm9uY2UiLCJwYXNzQXJncyIsImRlbGV0ZSIsInJlc3VsdFByb21pc2UiLCJwYXNzUHJvcGVydGllcyIsIkJhc2VDb250cmFjdCIsInRhcmdldCIsImFiaSIsIl9kZXBsb3lUeCIsImFkZHJQcm9taXNlIiwiZGVwbG95VHgiLCJNYXAiLCJ0aGVuIiwiZmlsdGVycyIsIlByb3h5IiwicHJvcCIsInJlY2VpdmVyIiwiUmVmbGVjdCIsImFyZ3VtZW50IiwiaGFzIiwiaGFzRXZlbnQiLCJTdHJpbmciLCJoYXNGdW5jdGlvbiIsImNvbm5lY3QiLCJhdHRhY2giLCJnZXREZXBsb3llZENvZGUiLCJjb2RlIiwiZ2V0Q29kZSIsIndhaXRGb3JEZXBsb3ltZW50IiwiZGVwbG95bWVudFRyYW5zYWN0aW9uIiwid2FpdCIsInJlamVjdCIsImNoZWNrQ29kZSIsImZvcm1hdCIsImZ1bmMiLCJxdWVyeVRyYW5zYWN0aW9uIiwiaGFzaCIsInF1ZXJ5RmlsdGVyIiwiZnJvbUJsb2NrIiwidG9CbG9jayIsImdldExvZ3MiLCJsaXN0ZW5lckNvdW50IiwidG90YWwiLCJjb25jYXQiLCJzcGxpY2UiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiYnVpbGRDbGFzcyIsIkN1c3RvbUNvbnRyYWN0IiwiX0NvbnRyYWN0QmFzZSIsIkNvbnRyYWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/contract/contract.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/contract/wrappers.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/contract/wrappers.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContractEventPayload: () => (/* binding */ ContractEventPayload),\n/* harmony export */   ContractTransactionReceipt: () => (/* binding */ ContractTransactionReceipt),\n/* harmony export */   ContractTransactionResponse: () => (/* binding */ ContractTransactionResponse),\n/* harmony export */   ContractUnknownEventPayload: () => (/* binding */ ContractUnknownEventPayload),\n/* harmony export */   EventLog: () => (/* binding */ EventLog),\n/* harmony export */   UndecodedEventLog: () => (/* binding */ UndecodedEventLog)\n/* harmony export */ });\n/* harmony import */ var _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../providers/provider.js */ \"(ssr)/./node_modules/ethers/lib.esm/providers/provider.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/events.js\");\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\n\n\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */ class EventLog extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.Log {\n    /**\n     * @_ignore:\n     */ constructor(log, iface, fragment){\n        super(log, log.provider);\n        const args = iface.decodeEventLog(fragment, log.data, log.topics);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            args,\n            fragment,\n            interface: iface\n        });\n    }\n    /**\n     *  The name of the event.\n     */ get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The signature of the event.\n     */ get eventSignature() {\n        return this.fragment.format();\n    }\n}\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */ class UndecodedEventLog extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.Log {\n    /**\n     * @_ignore:\n     */ constructor(log, error){\n        super(log, log.provider);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            error\n        });\n    }\n}\n/**\n *  A **ContractTransactionReceipt** includes the parsed logs from a\n *  [[TransactionReceipt]].\n */ class ContractTransactionReceipt extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.TransactionReceipt {\n    #iface;\n    /**\n     *  @_ignore:\n     */ constructor(iface, provider, tx){\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  The parsed logs for any [[Log]] which has a matching event in the\n     *  Contract ABI.\n     */ get logs() {\n        return super.logs.map((log)=>{\n            const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;\n            if (fragment) {\n                try {\n                    return new EventLog(log, this.#iface, fragment);\n                } catch (error) {\n                    return new UndecodedEventLog(log, error);\n                }\n            }\n            return log;\n        });\n    }\n}\n/**\n *  A **ContractTransactionResponse** will return a\n *  [[ContractTransactionReceipt]] when waited on.\n */ class ContractTransactionResponse extends _providers_provider_js__WEBPACK_IMPORTED_MODULE_0__.TransactionResponse {\n    #iface;\n    /**\n     *  @_ignore:\n     */ constructor(iface, provider, tx){\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */ async wait(confirms, timeout) {\n        const receipt = await super.wait(confirms, timeout);\n        if (receipt == null) {\n            return null;\n        }\n        return new ContractTransactionReceipt(this.#iface, this.provider, receipt);\n    }\n}\n/**\n *  A **ContractUnknownEventPayload** is included as the last parameter to\n *  Contract Events when the event does not match any events in the ABI.\n */ class ContractUnknownEventPayload extends _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.EventPayload {\n    /**\n     *  @_event:\n     */ constructor(contract, listener, filter, log){\n        super(contract, listener, filter);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            log\n        });\n    }\n    /**\n     *  Resolves to the block the event occured in.\n     */ async getBlock() {\n        return await this.log.getBlock();\n    }\n    /**\n     *  Resolves to the transaction the event occured in.\n     */ async getTransaction() {\n        return await this.log.getTransaction();\n    }\n    /**\n     *  Resolves to the transaction receipt the event occured in.\n     */ async getTransactionReceipt() {\n        return await this.log.getTransactionReceipt();\n    }\n}\n/**\n *  A **ContractEventPayload** is included as the last parameter to\n *  Contract Events when the event is known.\n */ class ContractEventPayload extends ContractUnknownEventPayload {\n    /**\n     *  @_ignore:\n     */ constructor(contract, listener, filter, fragment, _log){\n        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\n        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(this, {\n            args,\n            fragment\n        });\n    }\n    /**\n     *  The event name.\n     */ get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The event signature.\n     */ get eventSignature() {\n        return this.fragment.format();\n    }\n} //# sourceMappingURL=wrappers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY29udHJhY3Qvd3JhcHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsc0VBQXNFO0FBQ3RFLHlCQUF5QjtBQUMrRDtBQUNyQjtBQUNuRTs7Q0FFQyxHQUNNLE1BQU1LLGlCQUFpQkwsdURBQUdBO0lBYTdCOztLQUVDLEdBQ0RNLFlBQVlDLEdBQUcsRUFBRUMsS0FBSyxFQUFFQyxRQUFRLENBQUU7UUFDOUIsS0FBSyxDQUFDRixLQUFLQSxJQUFJRyxRQUFRO1FBQ3ZCLE1BQU1DLE9BQU9ILE1BQU1JLGNBQWMsQ0FBQ0gsVUFBVUYsSUFBSU0sSUFBSSxFQUFFTixJQUFJTyxNQUFNO1FBQ2hFWCxpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVRO1lBQU1GO1lBQVVNLFdBQVdQO1FBQU07SUFDOUQ7SUFDQTs7S0FFQyxHQUNELElBQUlRLFlBQVk7UUFBRSxPQUFPLElBQUksQ0FBQ1AsUUFBUSxDQUFDUSxJQUFJO0lBQUU7SUFDN0M7O0tBRUMsR0FDRCxJQUFJQyxpQkFBaUI7UUFBRSxPQUFPLElBQUksQ0FBQ1QsUUFBUSxDQUFDVSxNQUFNO0lBQUk7QUFDMUQ7QUFDQTs7Q0FFQyxHQUNNLE1BQU1DLDBCQUEwQnBCLHVEQUFHQTtJQUt0Qzs7S0FFQyxHQUNETSxZQUFZQyxHQUFHLEVBQUVjLEtBQUssQ0FBRTtRQUNwQixLQUFLLENBQUNkLEtBQUtBLElBQUlHLFFBQVE7UUFDdkJQLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRWtCO1FBQU07SUFDbkM7QUFDSjtBQUNBOzs7Q0FHQyxHQUNNLE1BQU1DLG1DQUFtQ3JCLHNFQUFrQkE7SUFDOUQsQ0FBQ08sS0FBSyxDQUFDO0lBQ1A7O0tBRUMsR0FDREYsWUFBWUUsS0FBSyxFQUFFRSxRQUFRLEVBQUVhLEVBQUUsQ0FBRTtRQUM3QixLQUFLLENBQUNBLElBQUliO1FBQ1YsSUFBSSxDQUFDLENBQUNGLEtBQUssR0FBR0E7SUFDbEI7SUFDQTs7O0tBR0MsR0FDRCxJQUFJZ0IsT0FBTztRQUNQLE9BQU8sS0FBSyxDQUFDQSxLQUFLQyxHQUFHLENBQUMsQ0FBQ2xCO1lBQ25CLE1BQU1FLFdBQVdGLElBQUlPLE1BQU0sQ0FBQ1ksTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDbEIsS0FBSyxDQUFDbUIsUUFBUSxDQUFDcEIsSUFBSU8sTUFBTSxDQUFDLEVBQUUsSUFBSTtZQUMzRSxJQUFJTCxVQUFVO2dCQUNWLElBQUk7b0JBQ0EsT0FBTyxJQUFJSixTQUFTRSxLQUFLLElBQUksQ0FBQyxDQUFDQyxLQUFLLEVBQUVDO2dCQUMxQyxFQUNBLE9BQU9ZLE9BQU87b0JBQ1YsT0FBTyxJQUFJRCxrQkFBa0JiLEtBQUtjO2dCQUN0QztZQUNKO1lBQ0EsT0FBT2Q7UUFDWDtJQUNKO0FBQ0o7QUFDQTs7O0NBR0MsR0FDTSxNQUFNcUIsb0NBQW9DMUIsdUVBQW1CQTtJQUNoRSxDQUFDTSxLQUFLLENBQUM7SUFDUDs7S0FFQyxHQUNERixZQUFZRSxLQUFLLEVBQUVFLFFBQVEsRUFBRWEsRUFBRSxDQUFFO1FBQzdCLEtBQUssQ0FBQ0EsSUFBSWI7UUFDVixJQUFJLENBQUMsQ0FBQ0YsS0FBSyxHQUFHQTtJQUNsQjtJQUNBOzs7Ozs7OztLQVFDLEdBQ0QsTUFBTXFCLEtBQUtDLFFBQVEsRUFBRUMsT0FBTyxFQUFFO1FBQzFCLE1BQU1DLFVBQVUsTUFBTSxLQUFLLENBQUNILEtBQUtDLFVBQVVDO1FBQzNDLElBQUlDLFdBQVcsTUFBTTtZQUNqQixPQUFPO1FBQ1g7UUFDQSxPQUFPLElBQUlWLDJCQUEyQixJQUFJLENBQUMsQ0FBQ2QsS0FBSyxFQUFFLElBQUksQ0FBQ0UsUUFBUSxFQUFFc0I7SUFDdEU7QUFDSjtBQUNBOzs7Q0FHQyxHQUNNLE1BQU1DLG9DQUFvQzdCLHlEQUFZQTtJQUt6RDs7S0FFQyxHQUNERSxZQUFZNEIsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLE1BQU0sRUFBRTdCLEdBQUcsQ0FBRTtRQUN6QyxLQUFLLENBQUMyQixVQUFVQyxVQUFVQztRQUMxQmpDLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFBRUk7UUFBSTtJQUNqQztJQUNBOztLQUVDLEdBQ0QsTUFBTThCLFdBQVc7UUFDYixPQUFPLE1BQU0sSUFBSSxDQUFDOUIsR0FBRyxDQUFDOEIsUUFBUTtJQUNsQztJQUNBOztLQUVDLEdBQ0QsTUFBTUMsaUJBQWlCO1FBQ25CLE9BQU8sTUFBTSxJQUFJLENBQUMvQixHQUFHLENBQUMrQixjQUFjO0lBQ3hDO0lBQ0E7O0tBRUMsR0FDRCxNQUFNQyx3QkFBd0I7UUFDMUIsT0FBTyxNQUFNLElBQUksQ0FBQ2hDLEdBQUcsQ0FBQ2dDLHFCQUFxQjtJQUMvQztBQUNKO0FBQ0E7OztDQUdDLEdBQ00sTUFBTUMsNkJBQTZCUDtJQUN0Qzs7S0FFQyxHQUNEM0IsWUFBWTRCLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxNQUFNLEVBQUUzQixRQUFRLEVBQUVnQyxJQUFJLENBQUU7UUFDcEQsS0FBSyxDQUFDUCxVQUFVQyxVQUFVQyxRQUFRLElBQUkvQixTQUFTb0MsTUFBTVAsU0FBU25CLFNBQVMsRUFBRU47UUFDekUsTUFBTUUsT0FBT3VCLFNBQVNuQixTQUFTLENBQUNILGNBQWMsQ0FBQ0gsVUFBVSxJQUFJLENBQUNGLEdBQUcsQ0FBQ00sSUFBSSxFQUFFLElBQUksQ0FBQ04sR0FBRyxDQUFDTyxNQUFNO1FBQ3ZGWCxpRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVRO1lBQU1GO1FBQVM7SUFDNUM7SUFDQTs7S0FFQyxHQUNELElBQUlPLFlBQVk7UUFDWixPQUFPLElBQUksQ0FBQ1AsUUFBUSxDQUFDUSxJQUFJO0lBQzdCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJQyxpQkFBaUI7UUFDakIsT0FBTyxJQUFJLENBQUNULFFBQVEsQ0FBQ1UsTUFBTTtJQUMvQjtBQUNKLEVBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veWlkLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2NvbnRyYWN0L3dyYXBwZXJzLmpzP2UwNjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0IGZyb20gcHJvdmlkZXIudHMgaW5zdGVhZCBvZiBpbmRleC50cyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcFxuLy8gZnJvbSBFdGhlcnNjYW5Qcm92aWRlclxuaW1wb3J0IHsgTG9nLCBUcmFuc2FjdGlvblJlY2VpcHQsIFRyYW5zYWN0aW9uUmVzcG9uc2UgfSBmcm9tIFwiLi4vcHJvdmlkZXJzL3Byb3ZpZGVyLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBFdmVudFBheWxvYWQgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbi8qKlxuICogIEFuICoqRXZlbnRMb2cqKiBjb250YWlucyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgcGFyc2VkIGZyb20gdGhlIFtbTG9nXV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudExvZyBleHRlbmRzIExvZyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBDb250cmFjdCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgaW50ZXJmYWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZXZlbnQuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBwYXJzZWQgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZXZlbnQgYnkgYGBlbWl0YGAuXG4gICAgICovXG4gICAgYXJncztcbiAgICAvKipcbiAgICAgKiBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2csIGlmYWNlLCBmcmFnbWVudCkge1xuICAgICAgICBzdXBlcihsb2csIGxvZy5wcm92aWRlcik7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBpZmFjZS5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgYXJncywgZnJhZ21lbnQsIGludGVyZmFjZTogaWZhY2UgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50TmFtZSgpIHsgcmV0dXJuIHRoaXMuZnJhZ21lbnQubmFtZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgc2lnbmF0dXJlIG9mIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRTaWduYXR1cmUoKSB7IHJldHVybiB0aGlzLmZyYWdtZW50LmZvcm1hdCgpOyB9XG59XG4vKipcbiAqICBBbiAqKkV2ZW50TG9nKiogY29udGFpbnMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHBhcnNlZCBmcm9tIHRoZSBbW0xvZ11dLlxuICovXG5leHBvcnQgY2xhc3MgVW5kZWNvZGVkRXZlbnRMb2cgZXh0ZW5kcyBMb2cge1xuICAgIC8qKlxuICAgICAqICBUaGUgZXJyb3IgZW5jb3VudGVkIHdoZW4gdHJ5aW5nIHRvIGRlY29kZSB0aGUgbG9nLlxuICAgICAqL1xuICAgIGVycm9yO1xuICAgIC8qKlxuICAgICAqIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZywgZXJyb3IpIHtcbiAgICAgICAgc3VwZXIobG9nLCBsb2cucHJvdmlkZXIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgZXJyb3IgfSk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSAqKkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KiogaW5jbHVkZXMgdGhlIHBhcnNlZCBsb2dzIGZyb20gYVxuICogIFtbVHJhbnNhY3Rpb25SZWNlaXB0XV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCBleHRlbmRzIFRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgI2lmYWNlO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZmFjZSwgcHJvdmlkZXIsIHR4KSB7XG4gICAgICAgIHN1cGVyKHR4LCBwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2lmYWNlID0gaWZhY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcGFyc2VkIGxvZ3MgZm9yIGFueSBbW0xvZ11dIHdoaWNoIGhhcyBhIG1hdGNoaW5nIGV2ZW50IGluIHRoZVxuICAgICAqICBDb250cmFjdCBBQkkuXG4gICAgICovXG4gICAgZ2V0IGxvZ3MoKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5sb2dzLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGxvZy50b3BpY3MubGVuZ3RoID8gdGhpcy4jaWZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudExvZyhsb2csIHRoaXMuI2lmYWNlLCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVuZGVjb2RlZEV2ZW50TG9nKGxvZywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb2c7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UqKiB3aWxsIHJldHVybiBhXG4gKiAgW1tDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdF1dIHdoZW4gd2FpdGVkIG9uLlxuICovXG5leHBvcnQgY2xhc3MgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlIGV4dGVuZHMgVHJhbnNhY3Rpb25SZXNwb25zZSB7XG4gICAgI2lmYWNlO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZmFjZSwgcHJvdmlkZXIsIHR4KSB7XG4gICAgICAgIHN1cGVyKHR4LCBwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2lmYWNlID0gaWZhY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyBvbmNlIHRoaXMgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQgYW5kIGhhc1xuICAgICAqICAlJWNvbmZpcm1zJSUgYmxvY2tzIGluY2x1ZGluZyBpdCAoZGVmYXVsdDogYGAxYGApIHdpdGggYW5cbiAgICAgKiAgb3B0aW9uYWwgJSV0aW1lb3V0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gcmVzb2x2ZSB0byBgYG51bGxgYCBvbmx5IGlmICUlY29uZmlybXMlJSBpcyBgYDBgYFxuICAgICAqICBhbmQgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBtaW5lZCwgb3RoZXJ3aXNlIHRoaXMgd2lsbFxuICAgICAqICB3YWl0IHVudGlsIGVub3VnaCBjb25maXJtYXRpb25zIGhhdmUgY29tcGxldGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXQoY29uZmlybXMsIHRpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHN1cGVyLndhaXQoY29uZmlybXMsIHRpbWVvdXQpO1xuICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMuI2lmYWNlLCB0aGlzLnByb3ZpZGVyLCByZWNlaXB0KTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkKiogaXMgaW5jbHVkZWQgYXMgdGhlIGxhc3QgcGFyYW1ldGVyIHRvXG4gKiAgQ29udHJhY3QgRXZlbnRzIHdoZW4gdGhlIGV2ZW50IGRvZXMgbm90IG1hdGNoIGFueSBldmVudHMgaW4gdGhlIEFCSS5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCBleHRlbmRzIEV2ZW50UGF5bG9hZCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBsb2cgd2l0aCBubyBtYXRjaGluZyBldmVudHMuXG4gICAgICovXG4gICAgbG9nO1xuICAgIC8qKlxuICAgICAqICBAX2V2ZW50OlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyLCBsb2cpIHtcbiAgICAgICAgc3VwZXIoY29udHJhY3QsIGxpc3RlbmVyLCBmaWx0ZXIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsgbG9nIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGJsb2NrIHRoZSBldmVudCBvY2N1cmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEJsb2NrKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2cuZ2V0QmxvY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9nLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdCB0aGUgZXZlbnQgb2NjdXJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvZy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoKTtcbiAgICB9XG59XG4vKipcbiAqICBBICoqQ29udHJhY3RFdmVudFBheWxvYWQqKiBpcyBpbmNsdWRlZCBhcyB0aGUgbGFzdCBwYXJhbWV0ZXIgdG9cbiAqICBDb250cmFjdCBFdmVudHMgd2hlbiB0aGUgZXZlbnQgaXMga25vd24uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdEV2ZW50UGF5bG9hZCBleHRlbmRzIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCB7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyLCBmcmFnbWVudCwgX2xvZykge1xuICAgICAgICBzdXBlcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlciwgbmV3IEV2ZW50TG9nKF9sb2csIGNvbnRyYWN0LmludGVyZmFjZSwgZnJhZ21lbnQpKTtcbiAgICAgICAgY29uc3QgYXJncyA9IGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgdGhpcy5sb2cuZGF0YSwgdGhpcy5sb2cudG9waWNzKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7IGFyZ3MsIGZyYWdtZW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGV2ZW50IG5hbWUuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnQubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBldmVudCBzaWduYXR1cmUuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50U2lnbmF0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudC5mb3JtYXQoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13cmFwcGVycy5qcy5tYXAiXSwibmFtZXMiOlsiTG9nIiwiVHJhbnNhY3Rpb25SZWNlaXB0IiwiVHJhbnNhY3Rpb25SZXNwb25zZSIsImRlZmluZVByb3BlcnRpZXMiLCJFdmVudFBheWxvYWQiLCJFdmVudExvZyIsImNvbnN0cnVjdG9yIiwibG9nIiwiaWZhY2UiLCJmcmFnbWVudCIsInByb3ZpZGVyIiwiYXJncyIsImRlY29kZUV2ZW50TG9nIiwiZGF0YSIsInRvcGljcyIsImludGVyZmFjZSIsImV2ZW50TmFtZSIsIm5hbWUiLCJldmVudFNpZ25hdHVyZSIsImZvcm1hdCIsIlVuZGVjb2RlZEV2ZW50TG9nIiwiZXJyb3IiLCJDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCIsInR4IiwibG9ncyIsIm1hcCIsImxlbmd0aCIsImdldEV2ZW50IiwiQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlIiwid2FpdCIsImNvbmZpcm1zIiwidGltZW91dCIsInJlY2VpcHQiLCJDb250cmFjdFVua25vd25FdmVudFBheWxvYWQiLCJjb250cmFjdCIsImxpc3RlbmVyIiwiZmlsdGVyIiwiZ2V0QmxvY2siLCJnZXRUcmFuc2FjdGlvbiIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsIkNvbnRyYWN0RXZlbnRQYXlsb2FkIiwiX2xvZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/contract/wrappers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.esm/crypto/keccak.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/**\n *  Cryptographic hashing functions\n *\n *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]\n */ \n\nlet locked = false;\nconst _keccak256 = function(data) {\n    return (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256)(data);\n};\nlet __keccak256 = _keccak256;\n/**\n *  Compute the cryptographic KECCAK256 hash of %%data%%.\n *\n *  The %%data%% **must** be a data representation, to compute the\n *  hash of UTF-8 data use the [[id]] function.\n *\n *  @returns DataHexstring\n *  @example:\n *    keccak256(\"0x\")\n *    //_result:\n *\n *    keccak256(\"0x1337\")\n *    //_result:\n *\n *    keccak256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n *    // Strings are assumed to be DataHexString, otherwise it will\n *    // throw. To hash UTF-8 data, see the note above.\n *    keccak256(\"Hello World\")\n *    //_error:\n */ function keccak256(_data) {\n    const data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_data, \"data\");\n    return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(__keccak256(data));\n}\nkeccak256._ = _keccak256;\nkeccak256.lock = function() {\n    locked = true;\n};\nkeccak256.register = function(func) {\n    if (locked) {\n        throw new TypeError(\"keccak256 is locked\");\n    }\n    __keccak256 = func;\n};\nObject.freeze(keccak256); //# sourceMappingURL=keccak.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL2tlY2Nhay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7OztDQUlDLEdBQytDO0FBQ007QUFDdEQsSUFBSUcsU0FBUztBQUNiLE1BQU1DLGFBQWEsU0FBVUMsSUFBSTtJQUM3QixPQUFPTCw4REFBVUEsQ0FBQ0s7QUFDdEI7QUFDQSxJQUFJQyxjQUFjRjtBQUNsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJDLEdBQ00sU0FBU0csVUFBVUMsS0FBSztJQUMzQixNQUFNSCxPQUFPSix5REFBUUEsQ0FBQ08sT0FBTztJQUM3QixPQUFPTix3REFBT0EsQ0FBQ0ksWUFBWUQ7QUFDL0I7QUFDQUUsVUFBVUUsQ0FBQyxHQUFHTDtBQUNkRyxVQUFVRyxJQUFJLEdBQUc7SUFBY1AsU0FBUztBQUFNO0FBQzlDSSxVQUFVSSxRQUFRLEdBQUcsU0FBVUMsSUFBSTtJQUMvQixJQUFJVCxRQUFRO1FBQ1IsTUFBTSxJQUFJVSxVQUFVO0lBQ3hCO0lBQ0FQLGNBQWNNO0FBQ2xCO0FBQ0FFLE9BQU9DLE1BQU0sQ0FBQ1IsWUFDZCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95aWQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vY3J5cHRvL2tlY2Nhay5qcz8xMzgxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIENyeXB0b2dyYXBoaWMgaGFzaGluZyBmdW5jdGlvbnNcbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvY3J5cHRvOkhhc2ggRnVuY3Rpb25zIFthYm91dC1jcnlwdG8taGFzaGluZ11cbiAqL1xuaW1wb3J0IHsga2VjY2FrXzI1NiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTNcIjtcbmltcG9ydCB7IGdldEJ5dGVzLCBoZXhsaWZ5IH0gZnJvbSBcIi4uL3V0aWxzL2luZGV4LmpzXCI7XG5sZXQgbG9ja2VkID0gZmFsc2U7XG5jb25zdCBfa2VjY2FrMjU2ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4ga2VjY2FrXzI1NihkYXRhKTtcbn07XG5sZXQgX19rZWNjYWsyNTYgPSBfa2VjY2FrMjU2O1xuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBLRUNDQUsyNTYgaGFzaCBvZiAlJWRhdGElJS5cbiAqXG4gKiAgVGhlICUlZGF0YSUlICoqbXVzdCoqIGJlIGEgZGF0YSByZXByZXNlbnRhdGlvbiwgdG8gY29tcHV0ZSB0aGVcbiAqICBoYXNoIG9mIFVURi04IGRhdGEgdXNlIHRoZSBbW2lkXV0gZnVuY3Rpb24uXG4gKlxuICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAqICBAZXhhbXBsZTpcbiAqICAgIGtlY2NhazI1NihcIjB4XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAga2VjY2FrMjU2KFwiMHgxMzM3XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAga2VjY2FrMjU2KG5ldyBVaW50OEFycmF5KFsgMHgxMywgMHgzNyBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBTdHJpbmdzIGFyZSBhc3N1bWVkIHRvIGJlIERhdGFIZXhTdHJpbmcsIG90aGVyd2lzZSBpdCB3aWxsXG4gKiAgICAvLyB0aHJvdy4gVG8gaGFzaCBVVEYtOCBkYXRhLCBzZWUgdGhlIG5vdGUgYWJvdmUuXG4gKiAgICBrZWNjYWsyNTYoXCJIZWxsbyBXb3JsZFwiKVxuICogICAgLy9fZXJyb3I6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWsyNTYoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gZ2V0Qnl0ZXMoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICByZXR1cm4gaGV4bGlmeShfX2tlY2NhazI1NihkYXRhKSk7XG59XG5rZWNjYWsyNTYuXyA9IF9rZWNjYWsyNTY7XG5rZWNjYWsyNTYubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkID0gdHJ1ZTsgfTtcbmtlY2NhazI1Ni5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2VjY2FrMjU2IGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19rZWNjYWsyNTYgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUoa2VjY2FrMjU2KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtlY2Nhay5qcy5tYXAiXSwibmFtZXMiOlsia2VjY2FrXzI1NiIsImdldEJ5dGVzIiwiaGV4bGlmeSIsImxvY2tlZCIsIl9rZWNjYWsyNTYiLCJkYXRhIiwiX19rZWNjYWsyNTYiLCJrZWNjYWsyNTYiLCJfZGF0YSIsIl8iLCJsb2NrIiwicmVnaXN0ZXIiLCJmdW5jIiwiVHlwZUVycm9yIiwiT2JqZWN0IiwiZnJlZXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/hash/id.js":
/*!************************************************!*\
  !*** ./node_modules/ethers/lib.esm/hash/id.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   id: () => (/* binding */ id)\n/* harmony export */ });\n/* harmony import */ var _crypto_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypto/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/crypto/keccak.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n\n\n/**\n *  A simple hashing function which operates on UTF-8 strings to\n *  compute an 32-byte identifier.\n *\n *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes\n *  the [[keccak256]].\n *\n *  @example:\n *    id(\"hello world\")\n *    //_result:\n */ function id(value) {\n    return (0,_crypto_index_js__WEBPACK_IMPORTED_MODULE_0__.keccak256)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(value));\n} //# sourceMappingURL=id.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vaGFzaC9pZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFDQztBQUNoRDs7Ozs7Ozs7OztDQVVDLEdBQ00sU0FBU0UsR0FBR0MsS0FBSztJQUNwQixPQUFPSCwyREFBU0EsQ0FBQ0MsNERBQVdBLENBQUNFO0FBQ2pDLEVBQ0EsOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veWlkLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2hhc2gvaWQuanM/NTQ1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiLi4vY3J5cHRvL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcyB9IGZyb20gXCIuLi91dGlscy9pbmRleC5qc1wiO1xuLyoqXG4gKiAgQSBzaW1wbGUgaGFzaGluZyBmdW5jdGlvbiB3aGljaCBvcGVyYXRlcyBvbiBVVEYtOCBzdHJpbmdzIHRvXG4gKiAgY29tcHV0ZSBhbiAzMi1ieXRlIGlkZW50aWZpZXIuXG4gKlxuICogIFRoaXMgc2ltcGx5IGNvbXB1dGVzIHRoZSBbVVRGLTggYnl0ZXNdKHRvVXRmOEJ5dGVzKSBhbmQgY29tcHV0ZXNcbiAqICB0aGUgW1trZWNjYWsyNTZdXS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICBpZChcImhlbGxvIHdvcmxkXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZCh2YWx1ZSkge1xuICAgIHJldHVybiBrZWNjYWsyNTYodG9VdGY4Qnl0ZXModmFsdWUpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCJdLCJuYW1lcyI6WyJrZWNjYWsyNTYiLCJ0b1V0ZjhCeXRlcyIsImlkIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/hash/id.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/providers/provider.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/providers/provider.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Block: () => (/* binding */ Block),\n/* harmony export */   FeeData: () => (/* binding */ FeeData),\n/* harmony export */   Log: () => (/* binding */ Log),\n/* harmony export */   TransactionReceipt: () => (/* binding */ TransactionReceipt),\n/* harmony export */   TransactionResponse: () => (/* binding */ TransactionResponse),\n/* harmony export */   copyRequest: () => (/* binding */ copyRequest)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transaction/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\");\n//import { resolveAddress } from \"@ethersproject/address\";\n\n\nconst BN_0 = BigInt(0);\n// -----------------------\nfunction getValue(value) {\n    if (value == null) {\n        return null;\n    }\n    return value;\n}\nfunction toJson(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.toString();\n}\n// @TODO? <T extends FeeData = { }> implements Required<T>\n/**\n *  A **FeeData** wraps all the fee-related values associated with\n *  the network.\n */ class FeeData {\n    /**\n     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and\n     *  %%maxPriorityFeePerGas%%.\n     */ constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas){\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            gasPrice: getValue(gasPrice),\n            maxFeePerGas: getValue(maxFeePerGas),\n            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)\n        });\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */ toJSON() {\n        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;\n        return {\n            _type: \"FeeData\",\n            gasPrice: toJson(gasPrice),\n            maxFeePerGas: toJson(maxFeePerGas),\n            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)\n        };\n    }\n}\n;\n/**\n *  Returns a copy of %%req%% with all properties coerced to their strict\n *  types.\n */ function copyRequest(req) {\n    const result = {};\n    // These could be addresses, ENS names or Addressables\n    if (req.to) {\n        result.to = req.to;\n    }\n    if (req.from) {\n        result.from = req.from;\n    }\n    if (req.data) {\n        result.data = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(req.data);\n    }\n    const bigIntKeys = \"chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value\".split(/,/);\n    for (const key of bigIntKeys){\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getBigInt)(req[key], `request.${key}`);\n    }\n    const numberKeys = \"type,nonce\".split(/,/);\n    for (const key of numberKeys){\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.getNumber)(req[key], `request.${key}`);\n    }\n    if (req.accessList) {\n        result.accessList = (0,_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.accessListify)(req.accessList);\n    }\n    if (req.authorizationList) {\n        result.authorizationList = req.authorizationList.slice();\n    }\n    if (\"blockTag\" in req) {\n        result.blockTag = req.blockTag;\n    }\n    if (\"enableCcipRead\" in req) {\n        result.enableCcipRead = !!req.enableCcipRead;\n    }\n    if (\"customData\" in req) {\n        result.customData = req.customData;\n    }\n    if (\"blobVersionedHashes\" in req && req.blobVersionedHashes) {\n        result.blobVersionedHashes = req.blobVersionedHashes.slice();\n    }\n    if (\"kzg\" in req) {\n        result.kzg = req.kzg;\n    }\n    if (\"blobs\" in req && req.blobs) {\n        result.blobs = req.blobs.map((b)=>{\n            if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.isBytesLike)(b)) {\n                return (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)(b);\n            }\n            return Object.assign({}, b);\n        });\n    }\n    return result;\n}\n/**\n *  A **Block** represents the data associated with a full block on\n *  Ethereum.\n */ class Block {\n    #transactions;\n    /**\n     *  Create a new **Block** object.\n     *\n     *  This should generally not be necessary as the unless implementing a\n     *  low-level library.\n     */ constructor(block, provider){\n        this.#transactions = block.transactions.map((tx)=>{\n            if (typeof tx !== \"string\") {\n                return new TransactionResponse(tx, provider);\n            }\n            return tx;\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            provider,\n            hash: getValue(block.hash),\n            number: block.number,\n            timestamp: block.timestamp,\n            parentHash: block.parentHash,\n            parentBeaconBlockRoot: block.parentBeaconBlockRoot,\n            nonce: block.nonce,\n            difficulty: block.difficulty,\n            gasLimit: block.gasLimit,\n            gasUsed: block.gasUsed,\n            blobGasUsed: block.blobGasUsed,\n            excessBlobGas: block.excessBlobGas,\n            miner: block.miner,\n            prevRandao: getValue(block.prevRandao),\n            extraData: block.extraData,\n            baseFeePerGas: getValue(block.baseFeePerGas),\n            stateRoot: block.stateRoot,\n            receiptsRoot: block.receiptsRoot\n        });\n    }\n    /**\n     *  Returns the list of transaction hashes, in the order\n     *  they were executed within the block.\n     */ get transactions() {\n        return this.#transactions.map((tx)=>{\n            if (typeof tx === \"string\") {\n                return tx;\n            }\n            return tx.hash;\n        });\n    }\n    /**\n     *  Returns the complete transactions, in the order they\n     *  were executed within the block.\n     *\n     *  This is only available for blocks which prefetched\n     *  transactions, by passing ``true`` to %%prefetchTxs%%\n     *  into [[Provider-getBlock]].\n     */ get prefetchedTransactions() {\n        const txs = this.#transactions.slice();\n        // Doesn't matter...\n        if (txs.length === 0) {\n            return [];\n        }\n        // Make sure we prefetched the transactions\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(typeof txs[0] === \"object\", \"transactions were not prefetched with block request\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"transactionResponses()\"\n        });\n        return txs;\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */ toJSON() {\n        const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash, miner, prevRandao, nonce, number, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;\n        return {\n            _type: \"Block\",\n            baseFeePerGas: toJson(baseFeePerGas),\n            difficulty: toJson(difficulty),\n            extraData,\n            gasLimit: toJson(gasLimit),\n            gasUsed: toJson(gasUsed),\n            blobGasUsed: toJson(this.blobGasUsed),\n            excessBlobGas: toJson(this.excessBlobGas),\n            hash,\n            miner,\n            prevRandao,\n            nonce,\n            number,\n            parentHash,\n            timestamp,\n            parentBeaconBlockRoot,\n            stateRoot,\n            receiptsRoot,\n            transactions\n        };\n    }\n    [Symbol.iterator]() {\n        let index = 0;\n        const txs = this.transactions;\n        return {\n            next: ()=>{\n                if (index < this.length) {\n                    return {\n                        value: txs[index++],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The number of transactions in this block.\n     */ get length() {\n        return this.#transactions.length;\n    }\n    /**\n     *  The [[link-js-date]] this block was included at.\n     */ get date() {\n        if (this.timestamp == null) {\n            return null;\n        }\n        return new Date(this.timestamp * 1000);\n    }\n    /**\n     *  Get the transaction at %%indexe%% within this block.\n     */ async getTransaction(indexOrHash) {\n        // Find the internal value by its index or hash\n        let tx = undefined;\n        if (typeof indexOrHash === \"number\") {\n            tx = this.#transactions[indexOrHash];\n        } else {\n            const hash = indexOrHash.toLowerCase();\n            for (const v of this.#transactions){\n                if (typeof v === \"string\") {\n                    if (v !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                } else {\n                    if (v.hash !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                }\n            }\n        }\n        if (tx == null) {\n            throw new Error(\"no such tx\");\n        }\n        if (typeof tx === \"string\") {\n            return await this.provider.getTransaction(tx);\n        } else {\n            return tx;\n        }\n    }\n    /**\n     *  If a **Block** was fetched with a request to include the transactions\n     *  this will allow synchronous access to those transactions.\n     *\n     *  If the transactions were not prefetched, this will throw.\n     */ getPrefetchedTransaction(indexOrHash) {\n        const txs = this.prefetchedTransactions;\n        if (typeof indexOrHash === \"number\") {\n            return txs[indexOrHash];\n        }\n        indexOrHash = indexOrHash.toLowerCase();\n        for (const tx of txs){\n            if (tx.hash === indexOrHash) {\n                return tx;\n            }\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(false, \"no matching transaction\", \"indexOrHash\", indexOrHash);\n    }\n    /**\n     *  Returns true if this block been mined. This provides a type guard\n     *  for all properties on a [[MinedBlock]].\n     */ isMined() {\n        return !!this.hash;\n    }\n    /**\n     *  Returns true if this block is an [[link-eip-2930]] block.\n     */ isLondon() {\n        return !!this.baseFeePerGas;\n    }\n    /**\n     *  @_ignore:\n     */ orphanedEvent() {\n        if (!this.isMined()) {\n            throw new Error(\"\");\n        }\n        return createOrphanedBlockFilter(this);\n    }\n}\n//////////////////////\n// Log\n/**\n *  A **Log** in Ethereum represents an event that has been included in a\n *  transaction using the ``LOG*`` opcodes, which are most commonly used by\n *  Solidity's emit for announcing events.\n */ class Log {\n    /**\n     *  @_ignore:\n     */ constructor(log, provider){\n        this.provider = provider;\n        const topics = Object.freeze(log.topics.slice());\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            removed: log.removed,\n            address: log.address,\n            data: log.data,\n            topics,\n            index: log.index,\n            transactionIndex: log.transactionIndex\n        });\n    }\n    /**\n     *  Returns a JSON-compatible object.\n     */ toJSON() {\n        const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;\n        return {\n            _type: \"log\",\n            address,\n            blockHash,\n            blockNumber,\n            data,\n            index,\n            removed,\n            topics,\n            transactionHash,\n            transactionIndex\n        };\n    }\n    /**\n     *  Returns the block that this log occurred in.\n     */ async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!!block, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return block;\n    }\n    /**\n     *  Returns the transaction that this log occurred in.\n     */ async getTransaction() {\n        const tx = await this.provider.getTransaction(this.transactionHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!!tx, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return tx;\n    }\n    /**\n     *  Returns the transaction receipt fot the transaction that this\n     *  log occurred in.\n     */ async getTransactionReceipt() {\n        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!!receipt, \"failed to find transaction receipt\", \"UNKNOWN_ERROR\", {});\n        return receipt;\n    }\n    /**\n     *  @_ignore:\n     */ removedEvent() {\n        return createRemovedLogFilter(this);\n    }\n}\n//////////////////////\n// Transaction Receipt\n/*\nexport interface LegacyTransactionReceipt {\n    byzantium: false;\n    status: null;\n    root: string;\n}\n\nexport interface ByzantiumTransactionReceipt {\n    byzantium: true;\n    status: number;\n    root: null;\n}\n*/ /**\n *  A **TransactionReceipt** includes additional information about a\n *  transaction that is only available after it has been mined.\n */ class TransactionReceipt {\n    #logs;\n    /**\n     *  @_ignore:\n     */ constructor(tx, provider){\n        this.#logs = Object.freeze(tx.logs.map((log)=>{\n            return new Log(log, provider);\n        }));\n        let gasPrice = BN_0;\n        if (tx.effectiveGasPrice != null) {\n            gasPrice = tx.effectiveGasPrice;\n        } else if (tx.gasPrice != null) {\n            gasPrice = tx.gasPrice;\n        }\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            provider,\n            to: tx.to,\n            from: tx.from,\n            contractAddress: tx.contractAddress,\n            hash: tx.hash,\n            index: tx.index,\n            blockHash: tx.blockHash,\n            blockNumber: tx.blockNumber,\n            logsBloom: tx.logsBloom,\n            gasUsed: tx.gasUsed,\n            cumulativeGasUsed: tx.cumulativeGasUsed,\n            blobGasUsed: tx.blobGasUsed,\n            gasPrice,\n            blobGasPrice: tx.blobGasPrice,\n            type: tx.type,\n            //byzantium: tx.byzantium,\n            status: tx.status,\n            root: tx.root\n        });\n    }\n    /**\n     *  The logs for this transaction.\n     */ get logs() {\n        return this.#logs;\n    }\n    /**\n     *  Returns a JSON-compatible representation.\n     */ toJSON() {\n        const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, status, root } = this;\n        return {\n            _type: \"TransactionReceipt\",\n            blockHash,\n            blockNumber,\n            //byzantium, \n            contractAddress,\n            cumulativeGasUsed: toJson(this.cumulativeGasUsed),\n            from,\n            gasPrice: toJson(this.gasPrice),\n            blobGasUsed: toJson(this.blobGasUsed),\n            blobGasPrice: toJson(this.blobGasPrice),\n            gasUsed: toJson(this.gasUsed),\n            hash,\n            index,\n            logs,\n            logsBloom,\n            root,\n            status,\n            to\n        };\n    }\n    /**\n     *  @_ignore:\n     */ get length() {\n        return this.logs.length;\n    }\n    [Symbol.iterator]() {\n        let index = 0;\n        return {\n            next: ()=>{\n                if (index < this.length) {\n                    return {\n                        value: this.logs[index++],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The total fee for this transaction, in wei.\n     */ get fee() {\n        return this.gasUsed * this.gasPrice;\n    }\n    /**\n     *  Resolves to the block this transaction occurred in.\n     */ async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to the transaction this transaction occurred in.\n     */ async getTransaction() {\n        const tx = await this.provider.getTransaction(this.hash);\n        if (tx == null) {\n            throw new Error(\"TODO\");\n        }\n        return tx;\n    }\n    /**\n     *  Resolves to the return value of the execution of this transaction.\n     *\n     *  Support for this feature is limited, as it requires an archive node\n     *  with the ``debug_`` or ``trace_`` API enabled.\n     */ async getResult() {\n        return await this.provider.getTransactionResult(this.hash);\n    }\n    /**\n     *  Resolves to the number of confirmations this transaction has.\n     */ async confirmations() {\n        return await this.provider.getBlockNumber() - this.blockNumber + 1;\n    }\n    /**\n     *  @_ignore:\n     */ removedEvent() {\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  @_ignore:\n     */ reorderedEvent(other) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!other || other.isMined(), \"unmined 'other' transction cannot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"reorderedEvent(other)\"\n        });\n        return createReorderedTransactionFilter(this, other);\n    }\n}\n/**\n *  A **TransactionResponse** includes all properties about a transaction\n *  that was sent to the network, which may or may not be included in a\n *  block.\n *\n *  The [[TransactionResponse-isMined]] can be used to check if the\n *  transaction has been mined as well as type guard that the otherwise\n *  possibly ``null`` properties are defined.\n */ class TransactionResponse {\n    #startBlock;\n    /**\n     *  @_ignore:\n     */ constructor(tx, provider){\n        this.provider = provider;\n        this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;\n        this.blockHash = tx.blockHash != null ? tx.blockHash : null;\n        this.hash = tx.hash;\n        this.index = tx.index;\n        this.type = tx.type;\n        this.from = tx.from;\n        this.to = tx.to || null;\n        this.gasLimit = tx.gasLimit;\n        this.nonce = tx.nonce;\n        this.data = tx.data;\n        this.value = tx.value;\n        this.gasPrice = tx.gasPrice;\n        this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;\n        this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;\n        this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;\n        this.chainId = tx.chainId;\n        this.signature = tx.signature;\n        this.accessList = tx.accessList != null ? tx.accessList : null;\n        this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;\n        this.authorizationList = tx.authorizationList != null ? tx.authorizationList : null;\n        this.#startBlock = -1;\n    }\n    /**\n     *  Returns a JSON-compatible representation of this transaction.\n     */ toJSON() {\n        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;\n        return {\n            _type: \"TransactionResponse\",\n            accessList,\n            blockNumber,\n            blockHash,\n            blobVersionedHashes,\n            chainId: toJson(this.chainId),\n            data,\n            from,\n            gasLimit: toJson(this.gasLimit),\n            gasPrice: toJson(this.gasPrice),\n            hash,\n            maxFeePerGas: toJson(this.maxFeePerGas),\n            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),\n            maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),\n            nonce,\n            signature,\n            to,\n            index,\n            type,\n            value: toJson(this.value)\n        };\n    }\n    /**\n     *  Resolves to the Block that this transaction was included in.\n     *\n     *  This will return null if the transaction has not been included yet.\n     */ async getBlock() {\n        let blockNumber = this.blockNumber;\n        if (blockNumber == null) {\n            const tx = await this.getTransaction();\n            if (tx) {\n                blockNumber = tx.blockNumber;\n            }\n        }\n        if (blockNumber == null) {\n            return null;\n        }\n        const block = this.provider.getBlock(blockNumber);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to this transaction being re-requested from the\n     *  provider. This can be used if you have an unmined transaction\n     *  and wish to get an up-to-date populated instance.\n     */ async getTransaction() {\n        return this.provider.getTransaction(this.hash);\n    }\n    /**\n     *  Resolve to the number of confirmations this transaction has.\n     */ async confirmations() {\n        if (this.blockNumber == null) {\n            const { tx, blockNumber } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                tx: this.getTransaction(),\n                blockNumber: this.provider.getBlockNumber()\n            });\n            // Not mined yet...\n            if (tx == null || tx.blockNumber == null) {\n                return 0;\n            }\n            return blockNumber - tx.blockNumber + 1;\n        }\n        const blockNumber = await this.provider.getBlockNumber();\n        return blockNumber - this.blockNumber + 1;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */ async wait(_confirms, _timeout) {\n        const confirms = _confirms == null ? 1 : _confirms;\n        const timeout = _timeout == null ? 0 : _timeout;\n        let startBlock = this.#startBlock;\n        let nextScan = -1;\n        let stopScanning = startBlock === -1 ? true : false;\n        const checkReplacement = async ()=>{\n            // Get the current transaction count for this sender\n            if (stopScanning) {\n                return null;\n            }\n            const { blockNumber, nonce } = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.resolveProperties)({\n                blockNumber: this.provider.getBlockNumber(),\n                nonce: this.provider.getTransactionCount(this.from)\n            });\n            // No transaction or our nonce has not been mined yet; but we\n            // can start scanning later when we do start\n            if (nonce < this.nonce) {\n                startBlock = blockNumber;\n                return;\n            }\n            // We were mined; no replacement\n            if (stopScanning) {\n                return null;\n            }\n            const mined = await this.getTransaction();\n            if (mined && mined.blockNumber != null) {\n                return;\n            }\n            // We were replaced; start scanning for that transaction\n            // Starting to scan; look back a few extra blocks for safety\n            if (nextScan === -1) {\n                nextScan = startBlock - 3;\n                if (nextScan < this.#startBlock) {\n                    nextScan = this.#startBlock;\n                }\n            }\n            while(nextScan <= blockNumber){\n                // Get the next block to scan\n                if (stopScanning) {\n                    return null;\n                }\n                const block = await this.provider.getBlock(nextScan, true);\n                // This should not happen; but we'll try again shortly\n                if (block == null) {\n                    return;\n                }\n                // We were mined; no replacement\n                for (const hash of block){\n                    if (hash === this.hash) {\n                        return;\n                    }\n                }\n                // Search for the transaction that replaced us\n                for(let i = 0; i < block.length; i++){\n                    const tx = await block.getTransaction(i);\n                    if (tx.from === this.from && tx.nonce === this.nonce) {\n                        // Get the receipt\n                        if (stopScanning) {\n                            return null;\n                        }\n                        const receipt = await this.provider.getTransactionReceipt(tx.hash);\n                        // This should not happen; but we'll try again shortly\n                        if (receipt == null) {\n                            return;\n                        }\n                        // We will retry this on the next block (this case could be optimized)\n                        if (blockNumber - receipt.blockNumber + 1 < confirms) {\n                            return;\n                        }\n                        // The reason we were replaced\n                        let reason = \"replaced\";\n                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {\n                            reason = \"repriced\";\n                        } else if (tx.data === \"0x\" && tx.from === tx.to && tx.value === BN_0) {\n                            reason = \"cancelled\";\n                        }\n                        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(false, \"transaction was replaced\", \"TRANSACTION_REPLACED\", {\n                            cancelled: reason === \"replaced\" || reason === \"cancelled\",\n                            reason,\n                            replacement: tx.replaceableTransaction(startBlock),\n                            hash: tx.hash,\n                            receipt\n                        });\n                    }\n                }\n                nextScan++;\n            }\n            return;\n        };\n        const checkReceipt = (receipt)=>{\n            if (receipt == null || receipt.status !== 0) {\n                return receipt;\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(false, \"transaction execution reverted\", \"CALL_EXCEPTION\", {\n                action: \"sendTransaction\",\n                data: null,\n                reason: null,\n                invocation: null,\n                revert: null,\n                transaction: {\n                    to: receipt.to,\n                    from: receipt.from,\n                    data: \"\" // @TODO: in v7, split out sendTransaction properties\n                },\n                receipt\n            });\n        };\n        const receipt = await this.provider.getTransactionReceipt(this.hash);\n        if (confirms === 0) {\n            return checkReceipt(receipt);\n        }\n        if (receipt) {\n            if (confirms === 1 || await receipt.confirmations() >= confirms) {\n                return checkReceipt(receipt);\n            }\n        } else {\n            // Check for a replacement; throws if a replacement was found\n            await checkReplacement();\n            // Allow null only when the confirms is 0\n            if (confirms === 0) {\n                return null;\n            }\n        }\n        const waiter = new Promise((resolve, reject)=>{\n            // List of things to cancel when we have a result (one way or the other)\n            const cancellers = [];\n            const cancel = ()=>{\n                cancellers.forEach((c)=>c());\n            };\n            // On cancel, stop scanning for replacements\n            cancellers.push(()=>{\n                stopScanning = true;\n            });\n            // Set up any timeout requested\n            if (timeout > 0) {\n                const timer = setTimeout(()=>{\n                    cancel();\n                    reject((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.makeError)(\"wait for transaction timeout\", \"TIMEOUT\"));\n                }, timeout);\n                cancellers.push(()=>{\n                    clearTimeout(timer);\n                });\n            }\n            const txListener = async (receipt)=>{\n                // Done; return it!\n                if (await receipt.confirmations() >= confirms) {\n                    cancel();\n                    try {\n                        resolve(checkReceipt(receipt));\n                    } catch (error) {\n                        reject(error);\n                    }\n                }\n            };\n            cancellers.push(()=>{\n                this.provider.off(this.hash, txListener);\n            });\n            this.provider.on(this.hash, txListener);\n            // We support replacement detection; start checking\n            if (startBlock >= 0) {\n                const replaceListener = async ()=>{\n                    try {\n                        // Check for a replacement; this throws only if one is found\n                        await checkReplacement();\n                    } catch (error) {\n                        // We were replaced (with enough confirms); re-throw the error\n                        if ((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.isError)(error, \"TRANSACTION_REPLACED\")) {\n                            cancel();\n                            reject(error);\n                            return;\n                        }\n                    }\n                    // Rescheudle a check on the next block\n                    if (!stopScanning) {\n                        this.provider.once(\"block\", replaceListener);\n                    }\n                };\n                cancellers.push(()=>{\n                    this.provider.off(\"block\", replaceListener);\n                });\n                this.provider.once(\"block\", replaceListener);\n            }\n        });\n        return await waiter;\n    }\n    /**\n     *  Returns ``true`` if this transaction has been included.\n     *\n     *  This is effective only as of the time the TransactionResponse\n     *  was instantiated. To get up-to-date information, use\n     *  [[getTransaction]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  non-null property values for properties that are null for\n     *  unmined transactions.\n     */ isMined() {\n        return this.blockHash != null;\n    }\n    /**\n     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)\n     *  transaction.\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isLegacy() {\n        return this.type === 0;\n    }\n    /**\n     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)\n     *  transaction. See [[link-eip-2070]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isBerlin() {\n        return this.type === 1;\n    }\n    /**\n     *  Returns true if the transaction is a London (i.e. ``type == 2``)\n     *  transaction. See [[link-eip-1559]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isLondon() {\n        return this.type === 2;\n    }\n    /**\n     *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)\n     *  transaction. See [[link-eip-4844]].\n     */ isCancun() {\n        return this.type === 3;\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that evict this transaction.\n     */ removedEvent() {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that re-order this event against %%other%%.\n     */ reorderedEvent(other) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!other || other.isMined(), \"unmined 'other' transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        return createReorderedTransactionFilter(this, other);\n    }\n    /**\n     *  Returns a new TransactionResponse instance which has the ability to\n     *  detect (and throw an error) if the transaction is replaced, which\n     *  will begin scanning at %%startBlock%%.\n     *\n     *  This should generally not be used by developers and is intended\n     *  primarily for internal use. Setting an incorrect %%startBlock%% can\n     *  have devastating performance consequences if used incorrectly.\n     */ replaceableTransaction(startBlock) {\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_4__.assertArgument)(Number.isInteger(startBlock) && startBlock >= 0, \"invalid startBlock\", \"startBlock\", startBlock);\n        const tx = new TransactionResponse(this, this.provider);\n        tx.#startBlock = startBlock;\n        return tx;\n    }\n}\nfunction createOrphanedBlockFilter(block) {\n    return {\n        orphan: \"drop-block\",\n        hash: block.hash,\n        number: block.number\n    };\n}\nfunction createReorderedTransactionFilter(tx, other) {\n    return {\n        orphan: \"reorder-transaction\",\n        tx,\n        other\n    };\n}\nfunction createRemovedTransactionFilter(tx) {\n    return {\n        orphan: \"drop-transaction\",\n        tx\n    };\n}\nfunction createRemovedLogFilter(log) {\n    return {\n        orphan: \"drop-log\",\n        log: {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            address: log.address,\n            data: log.data,\n            topics: Object.freeze(log.topics.slice()),\n            index: log.index\n        }\n    };\n} //# sourceMappingURL=provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMERBQTBEO0FBQ3NHO0FBQ3hHO0FBQ3hELE1BQU1XLE9BQU9DLE9BQU87QUFDcEIsMEJBQTBCO0FBQzFCLFNBQVNDLFNBQVNDLEtBQUs7SUFDbkIsSUFBSUEsU0FBUyxNQUFNO1FBQ2YsT0FBTztJQUNYO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVNDLE9BQU9ELEtBQUs7SUFDakIsSUFBSUEsU0FBUyxNQUFNO1FBQ2YsT0FBTztJQUNYO0lBQ0EsT0FBT0EsTUFBTUUsUUFBUTtBQUN6QjtBQUNBLDBEQUEwRDtBQUMxRDs7O0NBR0MsR0FDTSxNQUFNQztJQTRCVDs7O0tBR0MsR0FDREMsWUFBWUMsUUFBUSxFQUFFQyxZQUFZLEVBQUVDLG9CQUFvQixDQUFFO1FBQ3REckIsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUNuQm1CLFVBQVVOLFNBQVNNO1lBQ25CQyxjQUFjUCxTQUFTTztZQUN2QkMsc0JBQXNCUixTQUFTUTtRQUNuQztJQUNKO0lBQ0E7O0tBRUMsR0FDREMsU0FBUztRQUNMLE1BQU0sRUFBRUgsUUFBUSxFQUFFQyxZQUFZLEVBQUVDLG9CQUFvQixFQUFFLEdBQUcsSUFBSTtRQUM3RCxPQUFPO1lBQ0hFLE9BQU87WUFDUEosVUFBVUosT0FBT0k7WUFDakJDLGNBQWNMLE9BQU9LO1lBQ3JCQyxzQkFBc0JOLE9BQU9NO1FBQ2pDO0lBQ0o7QUFDSjs7QUFFQTs7O0NBR0MsR0FDTSxTQUFTRyxZQUFZQyxHQUFHO0lBQzNCLE1BQU1DLFNBQVMsQ0FBQztJQUNoQixzREFBc0Q7SUFDdEQsSUFBSUQsSUFBSUUsRUFBRSxFQUFFO1FBQ1JELE9BQU9DLEVBQUUsR0FBR0YsSUFBSUUsRUFBRTtJQUN0QjtJQUNBLElBQUlGLElBQUlHLElBQUksRUFBRTtRQUNWRixPQUFPRSxJQUFJLEdBQUdILElBQUlHLElBQUk7SUFDMUI7SUFDQSxJQUFJSCxJQUFJSSxJQUFJLEVBQUU7UUFDVkgsT0FBT0csSUFBSSxHQUFHMUIsd0RBQU9BLENBQUNzQixJQUFJSSxJQUFJO0lBQ2xDO0lBQ0EsTUFBTUMsYUFBYSxxRkFBcUZDLEtBQUssQ0FBQztJQUM5RyxLQUFLLE1BQU1DLE9BQU9GLFdBQVk7UUFDMUIsSUFBSSxDQUFFRSxDQUFBQSxPQUFPUCxHQUFFLEtBQU1BLEdBQUcsQ0FBQ08sSUFBSSxJQUFJLE1BQU07WUFDbkM7UUFDSjtRQUNBTixNQUFNLENBQUNNLElBQUksR0FBRy9CLDBEQUFTQSxDQUFDd0IsR0FBRyxDQUFDTyxJQUFJLEVBQUUsQ0FBQyxRQUFRLEVBQUVBLElBQUksQ0FBQztJQUN0RDtJQUNBLE1BQU1DLGFBQWEsYUFBYUYsS0FBSyxDQUFDO0lBQ3RDLEtBQUssTUFBTUMsT0FBT0MsV0FBWTtRQUMxQixJQUFJLENBQUVELENBQUFBLE9BQU9QLEdBQUUsS0FBTUEsR0FBRyxDQUFDTyxJQUFJLElBQUksTUFBTTtZQUNuQztRQUNKO1FBQ0FOLE1BQU0sQ0FBQ00sSUFBSSxHQUFHOUIsMERBQVNBLENBQUN1QixHQUFHLENBQUNPLElBQUksRUFBRSxDQUFDLFFBQVEsRUFBRUEsSUFBSSxDQUFDO0lBQ3REO0lBQ0EsSUFBSVAsSUFBSVMsVUFBVSxFQUFFO1FBQ2hCUixPQUFPUSxVQUFVLEdBQUd4QixvRUFBYUEsQ0FBQ2UsSUFBSVMsVUFBVTtJQUNwRDtJQUNBLElBQUlULElBQUlVLGlCQUFpQixFQUFFO1FBQ3ZCVCxPQUFPUyxpQkFBaUIsR0FBR1YsSUFBSVUsaUJBQWlCLENBQUNDLEtBQUs7SUFDMUQ7SUFDQSxJQUFJLGNBQWNYLEtBQUs7UUFDbkJDLE9BQU9XLFFBQVEsR0FBR1osSUFBSVksUUFBUTtJQUNsQztJQUNBLElBQUksb0JBQW9CWixLQUFLO1FBQ3pCQyxPQUFPWSxjQUFjLEdBQUcsQ0FBQyxDQUFDYixJQUFJYSxjQUFjO0lBQ2hEO0lBQ0EsSUFBSSxnQkFBZ0JiLEtBQUs7UUFDckJDLE9BQU9hLFVBQVUsR0FBR2QsSUFBSWMsVUFBVTtJQUN0QztJQUNBLElBQUkseUJBQXlCZCxPQUFPQSxJQUFJZSxtQkFBbUIsRUFBRTtRQUN6RGQsT0FBT2MsbUJBQW1CLEdBQUdmLElBQUllLG1CQUFtQixDQUFDSixLQUFLO0lBQzlEO0lBQ0EsSUFBSSxTQUFTWCxLQUFLO1FBQ2RDLE9BQU9lLEdBQUcsR0FBR2hCLElBQUlnQixHQUFHO0lBQ3hCO0lBQ0EsSUFBSSxXQUFXaEIsT0FBT0EsSUFBSWlCLEtBQUssRUFBRTtRQUM3QmhCLE9BQU9nQixLQUFLLEdBQUdqQixJQUFJaUIsS0FBSyxDQUFDQyxHQUFHLENBQUMsQ0FBQ0M7WUFDMUIsSUFBSXhDLDREQUFXQSxDQUFDd0MsSUFBSTtnQkFDaEIsT0FBT3pDLHdEQUFPQSxDQUFDeUM7WUFDbkI7WUFDQSxPQUFPQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHRjtRQUM3QjtJQUNKO0lBQ0EsT0FBT2xCO0FBQ1g7QUFDQTs7O0NBR0MsR0FDTSxNQUFNcUI7SUFrR1QsQ0FBQ0MsWUFBWSxDQUFDO0lBQ2Q7Ozs7O0tBS0MsR0FDRDlCLFlBQVkrQixLQUFLLEVBQUVDLFFBQVEsQ0FBRTtRQUN6QixJQUFJLENBQUMsQ0FBQ0YsWUFBWSxHQUFHQyxNQUFNRCxZQUFZLENBQUNMLEdBQUcsQ0FBQyxDQUFDUTtZQUN6QyxJQUFJLE9BQVFBLE9BQVEsVUFBVTtnQkFDMUIsT0FBTyxJQUFJQyxvQkFBb0JELElBQUlEO1lBQ3ZDO1lBQ0EsT0FBT0M7UUFDWDtRQUNBbkQsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUNuQmtEO1lBQ0FHLE1BQU14QyxTQUFTb0MsTUFBTUksSUFBSTtZQUN6QkMsUUFBUUwsTUFBTUssTUFBTTtZQUNwQkMsV0FBV04sTUFBTU0sU0FBUztZQUMxQkMsWUFBWVAsTUFBTU8sVUFBVTtZQUM1QkMsdUJBQXVCUixNQUFNUSxxQkFBcUI7WUFDbERDLE9BQU9ULE1BQU1TLEtBQUs7WUFDbEJDLFlBQVlWLE1BQU1VLFVBQVU7WUFDNUJDLFVBQVVYLE1BQU1XLFFBQVE7WUFDeEJDLFNBQVNaLE1BQU1ZLE9BQU87WUFDdEJDLGFBQWFiLE1BQU1hLFdBQVc7WUFDOUJDLGVBQWVkLE1BQU1jLGFBQWE7WUFDbENDLE9BQU9mLE1BQU1lLEtBQUs7WUFDbEJDLFlBQVlwRCxTQUFTb0MsTUFBTWdCLFVBQVU7WUFDckNDLFdBQVdqQixNQUFNaUIsU0FBUztZQUMxQkMsZUFBZXRELFNBQVNvQyxNQUFNa0IsYUFBYTtZQUMzQ0MsV0FBV25CLE1BQU1tQixTQUFTO1lBQzFCQyxjQUFjcEIsTUFBTW9CLFlBQVk7UUFDcEM7SUFDSjtJQUNBOzs7S0FHQyxHQUNELElBQUlyQixlQUFlO1FBQ2YsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsWUFBWSxDQUFDTCxHQUFHLENBQUMsQ0FBQ1E7WUFDM0IsSUFBSSxPQUFRQSxPQUFRLFVBQVU7Z0JBQzFCLE9BQU9BO1lBQ1g7WUFDQSxPQUFPQSxHQUFHRSxJQUFJO1FBQ2xCO0lBQ0o7SUFDQTs7Ozs7OztLQU9DLEdBQ0QsSUFBSWlCLHlCQUF5QjtRQUN6QixNQUFNQyxNQUFNLElBQUksQ0FBQyxDQUFDdkIsWUFBWSxDQUFDWixLQUFLO1FBQ3BDLG9CQUFvQjtRQUNwQixJQUFJbUMsSUFBSUMsTUFBTSxLQUFLLEdBQUc7WUFDbEIsT0FBTyxFQUFFO1FBQ2I7UUFDQSwyQ0FBMkM7UUFDM0NsRSx1REFBTUEsQ0FBQyxPQUFRaUUsR0FBRyxDQUFDLEVBQUUsS0FBTSxVQUFVLHVEQUF1RCx5QkFBeUI7WUFDakhFLFdBQVc7UUFDZjtRQUNBLE9BQU9GO0lBQ1g7SUFDQTs7S0FFQyxHQUNEakQsU0FBUztRQUNMLE1BQU0sRUFBRTZDLGFBQWEsRUFBRVIsVUFBVSxFQUFFTyxTQUFTLEVBQUVOLFFBQVEsRUFBRUMsT0FBTyxFQUFFUixJQUFJLEVBQUVXLEtBQUssRUFBRUMsVUFBVSxFQUFFUCxLQUFLLEVBQUVKLE1BQU0sRUFBRUUsVUFBVSxFQUFFQyxxQkFBcUIsRUFBRVcsU0FBUyxFQUFFQyxZQUFZLEVBQUVkLFNBQVMsRUFBRVAsWUFBWSxFQUFFLEdBQUcsSUFBSTtRQUNyTSxPQUFPO1lBQ0h6QixPQUFPO1lBQ1A0QyxlQUFlcEQsT0FBT29EO1lBQ3RCUixZQUFZNUMsT0FBTzRDO1lBQ25CTztZQUNBTixVQUFVN0MsT0FBTzZDO1lBQ2pCQyxTQUFTOUMsT0FBTzhDO1lBQ2hCQyxhQUFhL0MsT0FBTyxJQUFJLENBQUMrQyxXQUFXO1lBQ3BDQyxlQUFlaEQsT0FBTyxJQUFJLENBQUNnRCxhQUFhO1lBQ3hDVjtZQUFNVztZQUFPQztZQUFZUDtZQUFPSjtZQUFRRTtZQUFZRDtZQUNwREU7WUFBdUJXO1lBQVdDO1lBQ2xDckI7UUFDSjtJQUNKO0lBQ0EsQ0FBQzBCLE9BQU9DLFFBQVEsQ0FBQyxHQUFHO1FBQ2hCLElBQUlDLFFBQVE7UUFDWixNQUFNTCxNQUFNLElBQUksQ0FBQ3ZCLFlBQVk7UUFDN0IsT0FBTztZQUNINkIsTUFBTTtnQkFDRixJQUFJRCxRQUFRLElBQUksQ0FBQ0osTUFBTSxFQUFFO29CQUNyQixPQUFPO3dCQUNIMUQsT0FBT3lELEdBQUcsQ0FBQ0ssUUFBUTt3QkFBRUUsTUFBTTtvQkFDL0I7Z0JBQ0o7Z0JBQ0EsT0FBTztvQkFBRWhFLE9BQU9pRTtvQkFBV0QsTUFBTTtnQkFBSztZQUMxQztRQUNKO0lBQ0o7SUFDQTs7S0FFQyxHQUNELElBQUlOLFNBQVM7UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDeEIsWUFBWSxDQUFDd0IsTUFBTTtJQUFFO0lBQ2pEOztLQUVDLEdBQ0QsSUFBSVEsT0FBTztRQUNQLElBQUksSUFBSSxDQUFDekIsU0FBUyxJQUFJLE1BQU07WUFDeEIsT0FBTztRQUNYO1FBQ0EsT0FBTyxJQUFJMEIsS0FBSyxJQUFJLENBQUMxQixTQUFTLEdBQUc7SUFDckM7SUFDQTs7S0FFQyxHQUNELE1BQU0yQixlQUFlQyxXQUFXLEVBQUU7UUFDOUIsK0NBQStDO1FBQy9DLElBQUloQyxLQUFLNEI7UUFDVCxJQUFJLE9BQVFJLGdCQUFpQixVQUFVO1lBQ25DaEMsS0FBSyxJQUFJLENBQUMsQ0FBQ0gsWUFBWSxDQUFDbUMsWUFBWTtRQUN4QyxPQUNLO1lBQ0QsTUFBTTlCLE9BQU84QixZQUFZQyxXQUFXO1lBQ3BDLEtBQUssTUFBTUMsS0FBSyxJQUFJLENBQUMsQ0FBQ3JDLFlBQVksQ0FBRTtnQkFDaEMsSUFBSSxPQUFRcUMsTUFBTyxVQUFVO29CQUN6QixJQUFJQSxNQUFNaEMsTUFBTTt3QkFDWjtvQkFDSjtvQkFDQUYsS0FBS2tDO29CQUNMO2dCQUNKLE9BQ0s7b0JBQ0QsSUFBSUEsRUFBRWhDLElBQUksS0FBS0EsTUFBTTt3QkFDakI7b0JBQ0o7b0JBQ0FGLEtBQUtrQztvQkFDTDtnQkFDSjtZQUNKO1FBQ0o7UUFDQSxJQUFJbEMsTUFBTSxNQUFNO1lBQ1osTUFBTSxJQUFJbUMsTUFBTTtRQUNwQjtRQUNBLElBQUksT0FBUW5DLE9BQVEsVUFBVTtZQUMxQixPQUFRLE1BQU0sSUFBSSxDQUFDRCxRQUFRLENBQUNnQyxjQUFjLENBQUMvQjtRQUMvQyxPQUNLO1lBQ0QsT0FBT0E7UUFDWDtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDRG9DLHlCQUF5QkosV0FBVyxFQUFFO1FBQ2xDLE1BQU1aLE1BQU0sSUFBSSxDQUFDRCxzQkFBc0I7UUFDdkMsSUFBSSxPQUFRYSxnQkFBaUIsVUFBVTtZQUNuQyxPQUFPWixHQUFHLENBQUNZLFlBQVk7UUFDM0I7UUFDQUEsY0FBY0EsWUFBWUMsV0FBVztRQUNyQyxLQUFLLE1BQU1qQyxNQUFNb0IsSUFBSztZQUNsQixJQUFJcEIsR0FBR0UsSUFBSSxLQUFLOEIsYUFBYTtnQkFDekIsT0FBT2hDO1lBQ1g7UUFDSjtRQUNBNUMsK0RBQWNBLENBQUMsT0FBTywyQkFBMkIsZUFBZTRFO0lBQ3BFO0lBQ0E7OztLQUdDLEdBQ0RLLFVBQVU7UUFBRSxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUNuQyxJQUFJO0lBQUU7SUFDaEM7O0tBRUMsR0FDRG9DLFdBQVc7UUFDUCxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUN0QixhQUFhO0lBQy9CO0lBQ0E7O0tBRUMsR0FDRHVCLGdCQUFnQjtRQUNaLElBQUksQ0FBQyxJQUFJLENBQUNGLE9BQU8sSUFBSTtZQUNqQixNQUFNLElBQUlGLE1BQU07UUFDcEI7UUFDQSxPQUFPSywwQkFBMEIsSUFBSTtJQUN6QztBQUNKO0FBQ0Esc0JBQXNCO0FBQ3RCLE1BQU07QUFDTjs7OztDQUlDLEdBQ00sTUFBTUM7SUF1RFQ7O0tBRUMsR0FDRDFFLFlBQVkyRSxHQUFHLEVBQUUzQyxRQUFRLENBQUU7UUFDdkIsSUFBSSxDQUFDQSxRQUFRLEdBQUdBO1FBQ2hCLE1BQU00QyxTQUFTakQsT0FBT2tELE1BQU0sQ0FBQ0YsSUFBSUMsTUFBTSxDQUFDMUQsS0FBSztRQUM3Q3BDLGlFQUFnQkEsQ0FBQyxJQUFJLEVBQUU7WUFDbkJnRyxpQkFBaUJILElBQUlHLGVBQWU7WUFDcENDLFdBQVdKLElBQUlJLFNBQVM7WUFDeEJDLGFBQWFMLElBQUlLLFdBQVc7WUFDNUJDLFNBQVNOLElBQUlNLE9BQU87WUFDcEJDLFNBQVNQLElBQUlPLE9BQU87WUFDcEJ2RSxNQUFNZ0UsSUFBSWhFLElBQUk7WUFDZGlFO1lBQ0FsQixPQUFPaUIsSUFBSWpCLEtBQUs7WUFDaEJ5QixrQkFBa0JSLElBQUlRLGdCQUFnQjtRQUMxQztJQUNKO0lBQ0E7O0tBRUMsR0FDRC9FLFNBQVM7UUFDTCxNQUFNLEVBQUU4RSxPQUFPLEVBQUVILFNBQVMsRUFBRUMsV0FBVyxFQUFFckUsSUFBSSxFQUFFK0MsS0FBSyxFQUFFdUIsT0FBTyxFQUFFTCxNQUFNLEVBQUVFLGVBQWUsRUFBRUssZ0JBQWdCLEVBQUUsR0FBRyxJQUFJO1FBQ2pILE9BQU87WUFDSDlFLE9BQU87WUFDUDZFO1lBQVNIO1lBQVdDO1lBQWFyRTtZQUFNK0M7WUFDdkN1QjtZQUFTTDtZQUFRRTtZQUFpQks7UUFDdEM7SUFDSjtJQUNBOztLQUVDLEdBQ0QsTUFBTUMsV0FBVztRQUNiLE1BQU1yRCxRQUFRLE1BQU0sSUFBSSxDQUFDQyxRQUFRLENBQUNvRCxRQUFRLENBQUMsSUFBSSxDQUFDTCxTQUFTO1FBQ3pEM0YsdURBQU1BLENBQUMsQ0FBQyxDQUFDMkMsT0FBTyw4QkFBOEIsaUJBQWlCLENBQUM7UUFDaEUsT0FBT0E7SUFDWDtJQUNBOztLQUVDLEdBQ0QsTUFBTWlDLGlCQUFpQjtRQUNuQixNQUFNL0IsS0FBSyxNQUFNLElBQUksQ0FBQ0QsUUFBUSxDQUFDZ0MsY0FBYyxDQUFDLElBQUksQ0FBQ2MsZUFBZTtRQUNsRTFGLHVEQUFNQSxDQUFDLENBQUMsQ0FBQzZDLElBQUksOEJBQThCLGlCQUFpQixDQUFDO1FBQzdELE9BQU9BO0lBQ1g7SUFDQTs7O0tBR0MsR0FDRCxNQUFNb0Qsd0JBQXdCO1FBQzFCLE1BQU1DLFVBQVUsTUFBTSxJQUFJLENBQUN0RCxRQUFRLENBQUNxRCxxQkFBcUIsQ0FBQyxJQUFJLENBQUNQLGVBQWU7UUFDOUUxRix1REFBTUEsQ0FBQyxDQUFDLENBQUNrRyxTQUFTLHNDQUFzQyxpQkFBaUIsQ0FBQztRQUMxRSxPQUFPQTtJQUNYO0lBQ0E7O0tBRUMsR0FDREMsZUFBZTtRQUNYLE9BQU9DLHVCQUF1QixJQUFJO0lBQ3RDO0FBQ0o7QUFDQSxzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCOzs7Ozs7Ozs7Ozs7QUFZQSxHQUNBOzs7Q0FHQyxHQUNNLE1BQU1DO0lBZ0dULENBQUNDLElBQUksQ0FBQztJQUNOOztLQUVDLEdBQ0QxRixZQUFZaUMsRUFBRSxFQUFFRCxRQUFRLENBQUU7UUFDdEIsSUFBSSxDQUFDLENBQUMwRCxJQUFJLEdBQUcvRCxPQUFPa0QsTUFBTSxDQUFDNUMsR0FBR3lELElBQUksQ0FBQ2pFLEdBQUcsQ0FBQyxDQUFDa0Q7WUFDcEMsT0FBTyxJQUFJRCxJQUFJQyxLQUFLM0M7UUFDeEI7UUFDQSxJQUFJL0IsV0FBV1I7UUFDZixJQUFJd0MsR0FBRzBELGlCQUFpQixJQUFJLE1BQU07WUFDOUIxRixXQUFXZ0MsR0FBRzBELGlCQUFpQjtRQUNuQyxPQUNLLElBQUkxRCxHQUFHaEMsUUFBUSxJQUFJLE1BQU07WUFDMUJBLFdBQVdnQyxHQUFHaEMsUUFBUTtRQUMxQjtRQUNBbkIsaUVBQWdCQSxDQUFDLElBQUksRUFBRTtZQUNuQmtEO1lBQ0F2QixJQUFJd0IsR0FBR3hCLEVBQUU7WUFDVEMsTUFBTXVCLEdBQUd2QixJQUFJO1lBQ2JrRixpQkFBaUIzRCxHQUFHMkQsZUFBZTtZQUNuQ3pELE1BQU1GLEdBQUdFLElBQUk7WUFDYnVCLE9BQU96QixHQUFHeUIsS0FBSztZQUNmcUIsV0FBVzlDLEdBQUc4QyxTQUFTO1lBQ3ZCQyxhQUFhL0MsR0FBRytDLFdBQVc7WUFDM0JhLFdBQVc1RCxHQUFHNEQsU0FBUztZQUN2QmxELFNBQVNWLEdBQUdVLE9BQU87WUFDbkJtRCxtQkFBbUI3RCxHQUFHNkQsaUJBQWlCO1lBQ3ZDbEQsYUFBYVgsR0FBR1csV0FBVztZQUMzQjNDO1lBQ0E4RixjQUFjOUQsR0FBRzhELFlBQVk7WUFDN0JDLE1BQU0vRCxHQUFHK0QsSUFBSTtZQUNiLDBCQUEwQjtZQUMxQkMsUUFBUWhFLEdBQUdnRSxNQUFNO1lBQ2pCQyxNQUFNakUsR0FBR2lFLElBQUk7UUFDakI7SUFDSjtJQUNBOztLQUVDLEdBQ0QsSUFBSVIsT0FBTztRQUFFLE9BQU8sSUFBSSxDQUFDLENBQUNBLElBQUk7SUFBRTtJQUNoQzs7S0FFQyxHQUNEdEYsU0FBUztRQUNMLE1BQU0sRUFBRUssRUFBRSxFQUFFQyxJQUFJLEVBQUVrRixlQUFlLEVBQUV6RCxJQUFJLEVBQUV1QixLQUFLLEVBQUVxQixTQUFTLEVBQUVDLFdBQVcsRUFBRWEsU0FBUyxFQUFFSCxJQUFJLEVBQ3ZGTyxNQUFNLEVBQUVDLElBQUksRUFBRSxHQUFHLElBQUk7UUFDckIsT0FBTztZQUNIN0YsT0FBTztZQUNQMEU7WUFBV0M7WUFDWCxhQUFhO1lBQ2JZO1lBQ0FFLG1CQUFtQmpHLE9BQU8sSUFBSSxDQUFDaUcsaUJBQWlCO1lBQ2hEcEY7WUFDQVQsVUFBVUosT0FBTyxJQUFJLENBQUNJLFFBQVE7WUFDOUIyQyxhQUFhL0MsT0FBTyxJQUFJLENBQUMrQyxXQUFXO1lBQ3BDbUQsY0FBY2xHLE9BQU8sSUFBSSxDQUFDa0csWUFBWTtZQUN0Q3BELFNBQVM5QyxPQUFPLElBQUksQ0FBQzhDLE9BQU87WUFDNUJSO1lBQU11QjtZQUFPZ0M7WUFBTUc7WUFBV0s7WUFBTUQ7WUFBUXhGO1FBQ2hEO0lBQ0o7SUFDQTs7S0FFQyxHQUNELElBQUk2QyxTQUFTO1FBQUUsT0FBTyxJQUFJLENBQUNvQyxJQUFJLENBQUNwQyxNQUFNO0lBQUU7SUFDeEMsQ0FBQ0UsT0FBT0MsUUFBUSxDQUFDLEdBQUc7UUFDaEIsSUFBSUMsUUFBUTtRQUNaLE9BQU87WUFDSEMsTUFBTTtnQkFDRixJQUFJRCxRQUFRLElBQUksQ0FBQ0osTUFBTSxFQUFFO29CQUNyQixPQUFPO3dCQUFFMUQsT0FBTyxJQUFJLENBQUM4RixJQUFJLENBQUNoQyxRQUFRO3dCQUFFRSxNQUFNO29CQUFNO2dCQUNwRDtnQkFDQSxPQUFPO29CQUFFaEUsT0FBT2lFO29CQUFXRCxNQUFNO2dCQUFLO1lBQzFDO1FBQ0o7SUFDSjtJQUNBOztLQUVDLEdBQ0QsSUFBSXVDLE1BQU07UUFDTixPQUFPLElBQUksQ0FBQ3hELE9BQU8sR0FBRyxJQUFJLENBQUMxQyxRQUFRO0lBQ3ZDO0lBQ0E7O0tBRUMsR0FDRCxNQUFNbUYsV0FBVztRQUNiLE1BQU1yRCxRQUFRLE1BQU0sSUFBSSxDQUFDQyxRQUFRLENBQUNvRCxRQUFRLENBQUMsSUFBSSxDQUFDTCxTQUFTO1FBQ3pELElBQUloRCxTQUFTLE1BQU07WUFDZixNQUFNLElBQUlxQyxNQUFNO1FBQ3BCO1FBQ0EsT0FBT3JDO0lBQ1g7SUFDQTs7S0FFQyxHQUNELE1BQU1pQyxpQkFBaUI7UUFDbkIsTUFBTS9CLEtBQUssTUFBTSxJQUFJLENBQUNELFFBQVEsQ0FBQ2dDLGNBQWMsQ0FBQyxJQUFJLENBQUM3QixJQUFJO1FBQ3ZELElBQUlGLE1BQU0sTUFBTTtZQUNaLE1BQU0sSUFBSW1DLE1BQU07UUFDcEI7UUFDQSxPQUFPbkM7SUFDWDtJQUNBOzs7OztLQUtDLEdBQ0QsTUFBTW1FLFlBQVk7UUFDZCxPQUFRLE1BQU0sSUFBSSxDQUFDcEUsUUFBUSxDQUFDcUUsb0JBQW9CLENBQUMsSUFBSSxDQUFDbEUsSUFBSTtJQUM5RDtJQUNBOztLQUVDLEdBQ0QsTUFBTW1FLGdCQUFnQjtRQUNsQixPQUFPLE1BQU8sSUFBSSxDQUFDdEUsUUFBUSxDQUFDdUUsY0FBYyxLQUFNLElBQUksQ0FBQ3ZCLFdBQVcsR0FBRztJQUN2RTtJQUNBOztLQUVDLEdBQ0RPLGVBQWU7UUFDWCxPQUFPaUIsK0JBQStCLElBQUk7SUFDOUM7SUFDQTs7S0FFQyxHQUNEQyxlQUFlQyxLQUFLLEVBQUU7UUFDbEJ0SCx1REFBTUEsQ0FBQyxDQUFDc0gsU0FBU0EsTUFBTXBDLE9BQU8sSUFBSSxpREFBaUQseUJBQXlCO1lBQUVmLFdBQVc7UUFBd0I7UUFDakosT0FBT29ELGlDQUFpQyxJQUFJLEVBQUVEO0lBQ2xEO0FBQ0o7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNNLE1BQU14RTtJQXVIVCxDQUFDMEUsVUFBVSxDQUFDO0lBQ1o7O0tBRUMsR0FDRDVHLFlBQVlpQyxFQUFFLEVBQUVELFFBQVEsQ0FBRTtRQUN0QixJQUFJLENBQUNBLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDZ0QsV0FBVyxHQUFHLEdBQUlBLFdBQVcsSUFBSSxPQUFRL0MsR0FBRytDLFdBQVcsR0FBRztRQUMvRCxJQUFJLENBQUNELFNBQVMsR0FBRyxHQUFJQSxTQUFTLElBQUksT0FBUTlDLEdBQUc4QyxTQUFTLEdBQUc7UUFDekQsSUFBSSxDQUFDNUMsSUFBSSxHQUFHRixHQUFHRSxJQUFJO1FBQ25CLElBQUksQ0FBQ3VCLEtBQUssR0FBR3pCLEdBQUd5QixLQUFLO1FBQ3JCLElBQUksQ0FBQ3NDLElBQUksR0FBRy9ELEdBQUcrRCxJQUFJO1FBQ25CLElBQUksQ0FBQ3RGLElBQUksR0FBR3VCLEdBQUd2QixJQUFJO1FBQ25CLElBQUksQ0FBQ0QsRUFBRSxHQUFHd0IsR0FBR3hCLEVBQUUsSUFBSTtRQUNuQixJQUFJLENBQUNpQyxRQUFRLEdBQUdULEdBQUdTLFFBQVE7UUFDM0IsSUFBSSxDQUFDRixLQUFLLEdBQUdQLEdBQUdPLEtBQUs7UUFDckIsSUFBSSxDQUFDN0IsSUFBSSxHQUFHc0IsR0FBR3RCLElBQUk7UUFDbkIsSUFBSSxDQUFDZixLQUFLLEdBQUdxQyxHQUFHckMsS0FBSztRQUNyQixJQUFJLENBQUNLLFFBQVEsR0FBR2dDLEdBQUdoQyxRQUFRO1FBQzNCLElBQUksQ0FBQ0Usb0JBQW9CLEdBQUcsR0FBSUEsb0JBQW9CLElBQUksT0FBUThCLEdBQUc5QixvQkFBb0IsR0FBRztRQUMxRixJQUFJLENBQUNELFlBQVksR0FBRyxHQUFJQSxZQUFZLElBQUksT0FBUStCLEdBQUcvQixZQUFZLEdBQUc7UUFDbEUsSUFBSSxDQUFDMkcsZ0JBQWdCLEdBQUcsR0FBSUEsZ0JBQWdCLElBQUksT0FBUTVFLEdBQUc0RSxnQkFBZ0IsR0FBRztRQUM5RSxJQUFJLENBQUNDLE9BQU8sR0FBRzdFLEdBQUc2RSxPQUFPO1FBQ3pCLElBQUksQ0FBQ0MsU0FBUyxHQUFHOUUsR0FBRzhFLFNBQVM7UUFDN0IsSUFBSSxDQUFDL0YsVUFBVSxHQUFHLEdBQUlBLFVBQVUsSUFBSSxPQUFRaUIsR0FBR2pCLFVBQVUsR0FBRztRQUM1RCxJQUFJLENBQUNNLG1CQUFtQixHQUFHLEdBQUlBLG1CQUFtQixJQUFJLE9BQVFXLEdBQUdYLG1CQUFtQixHQUFHO1FBQ3ZGLElBQUksQ0FBQ0wsaUJBQWlCLEdBQUcsR0FBSUEsaUJBQWlCLElBQUksT0FBUWdCLEdBQUdoQixpQkFBaUIsR0FBRztRQUNqRixJQUFJLENBQUMsQ0FBQzJGLFVBQVUsR0FBRyxDQUFDO0lBQ3hCO0lBQ0E7O0tBRUMsR0FDRHhHLFNBQVM7UUFDTCxNQUFNLEVBQUU0RSxXQUFXLEVBQUVELFNBQVMsRUFBRXJCLEtBQUssRUFBRXZCLElBQUksRUFBRTZELElBQUksRUFBRXZGLEVBQUUsRUFBRUMsSUFBSSxFQUFFOEIsS0FBSyxFQUFFN0IsSUFBSSxFQUFFb0csU0FBUyxFQUFFL0YsVUFBVSxFQUFFTSxtQkFBbUIsRUFBRSxHQUFHLElBQUk7UUFDN0gsT0FBTztZQUNIakIsT0FBTztZQUNQVztZQUFZZ0U7WUFBYUQ7WUFDekJ6RDtZQUNBd0YsU0FBU2pILE9BQU8sSUFBSSxDQUFDaUgsT0FBTztZQUM1Qm5HO1lBQU1EO1lBQ05nQyxVQUFVN0MsT0FBTyxJQUFJLENBQUM2QyxRQUFRO1lBQzlCekMsVUFBVUosT0FBTyxJQUFJLENBQUNJLFFBQVE7WUFDOUJrQztZQUNBakMsY0FBY0wsT0FBTyxJQUFJLENBQUNLLFlBQVk7WUFDdENDLHNCQUFzQk4sT0FBTyxJQUFJLENBQUNNLG9CQUFvQjtZQUN0RDBHLGtCQUFrQmhILE9BQU8sSUFBSSxDQUFDZ0gsZ0JBQWdCO1lBQzlDckU7WUFBT3VFO1lBQVd0RztZQUFJaUQ7WUFBT3NDO1lBQzdCcEcsT0FBT0MsT0FBTyxJQUFJLENBQUNELEtBQUs7UUFDNUI7SUFDSjtJQUNBOzs7O0tBSUMsR0FDRCxNQUFNd0YsV0FBVztRQUNiLElBQUlKLGNBQWMsSUFBSSxDQUFDQSxXQUFXO1FBQ2xDLElBQUlBLGVBQWUsTUFBTTtZQUNyQixNQUFNL0MsS0FBSyxNQUFNLElBQUksQ0FBQytCLGNBQWM7WUFDcEMsSUFBSS9CLElBQUk7Z0JBQ0orQyxjQUFjL0MsR0FBRytDLFdBQVc7WUFDaEM7UUFDSjtRQUNBLElBQUlBLGVBQWUsTUFBTTtZQUNyQixPQUFPO1FBQ1g7UUFDQSxNQUFNakQsUUFBUSxJQUFJLENBQUNDLFFBQVEsQ0FBQ29ELFFBQVEsQ0FBQ0o7UUFDckMsSUFBSWpELFNBQVMsTUFBTTtZQUNmLE1BQU0sSUFBSXFDLE1BQU07UUFDcEI7UUFDQSxPQUFPckM7SUFDWDtJQUNBOzs7O0tBSUMsR0FDRCxNQUFNaUMsaUJBQWlCO1FBQ25CLE9BQU8sSUFBSSxDQUFDaEMsUUFBUSxDQUFDZ0MsY0FBYyxDQUFDLElBQUksQ0FBQzdCLElBQUk7SUFDakQ7SUFDQTs7S0FFQyxHQUNELE1BQU1tRSxnQkFBZ0I7UUFDbEIsSUFBSSxJQUFJLENBQUN0QixXQUFXLElBQUksTUFBTTtZQUMxQixNQUFNLEVBQUUvQyxFQUFFLEVBQUUrQyxXQUFXLEVBQUUsR0FBRyxNQUFNN0Ysa0VBQWlCQSxDQUFDO2dCQUNoRDhDLElBQUksSUFBSSxDQUFDK0IsY0FBYztnQkFDdkJnQixhQUFhLElBQUksQ0FBQ2hELFFBQVEsQ0FBQ3VFLGNBQWM7WUFDN0M7WUFDQSxtQkFBbUI7WUFDbkIsSUFBSXRFLE1BQU0sUUFBUUEsR0FBRytDLFdBQVcsSUFBSSxNQUFNO2dCQUN0QyxPQUFPO1lBQ1g7WUFDQSxPQUFPQSxjQUFjL0MsR0FBRytDLFdBQVcsR0FBRztRQUMxQztRQUNBLE1BQU1BLGNBQWMsTUFBTSxJQUFJLENBQUNoRCxRQUFRLENBQUN1RSxjQUFjO1FBQ3RELE9BQU92QixjQUFjLElBQUksQ0FBQ0EsV0FBVyxHQUFHO0lBQzVDO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDRCxNQUFNZ0MsS0FBS0MsU0FBUyxFQUFFQyxRQUFRLEVBQUU7UUFDNUIsTUFBTUMsV0FBVyxhQUFjLE9BQVEsSUFBSUY7UUFDM0MsTUFBTUcsVUFBVSxZQUFhLE9BQVEsSUFBSUY7UUFDekMsSUFBSU4sYUFBYSxJQUFJLENBQUMsQ0FBQ0EsVUFBVTtRQUNqQyxJQUFJUyxXQUFXLENBQUM7UUFDaEIsSUFBSUMsZUFBZSxlQUFnQixDQUFDLElBQUssT0FBTztRQUNoRCxNQUFNQyxtQkFBbUI7WUFDckIsb0RBQW9EO1lBQ3BELElBQUlELGNBQWM7Z0JBQ2QsT0FBTztZQUNYO1lBQ0EsTUFBTSxFQUFFdEMsV0FBVyxFQUFFeEMsS0FBSyxFQUFFLEdBQUcsTUFBTXJELGtFQUFpQkEsQ0FBQztnQkFDbkQ2RixhQUFhLElBQUksQ0FBQ2hELFFBQVEsQ0FBQ3VFLGNBQWM7Z0JBQ3pDL0QsT0FBTyxJQUFJLENBQUNSLFFBQVEsQ0FBQ3dGLG1CQUFtQixDQUFDLElBQUksQ0FBQzlHLElBQUk7WUFDdEQ7WUFDQSw2REFBNkQ7WUFDN0QsNENBQTRDO1lBQzVDLElBQUk4QixRQUFRLElBQUksQ0FBQ0EsS0FBSyxFQUFFO2dCQUNwQm9FLGFBQWE1QjtnQkFDYjtZQUNKO1lBQ0EsZ0NBQWdDO1lBQ2hDLElBQUlzQyxjQUFjO2dCQUNkLE9BQU87WUFDWDtZQUNBLE1BQU1HLFFBQVEsTUFBTSxJQUFJLENBQUN6RCxjQUFjO1lBQ3ZDLElBQUl5RCxTQUFTQSxNQUFNekMsV0FBVyxJQUFJLE1BQU07Z0JBQ3BDO1lBQ0o7WUFDQSx3REFBd0Q7WUFDeEQsNERBQTREO1lBQzVELElBQUlxQyxhQUFhLENBQUMsR0FBRztnQkFDakJBLFdBQVdULGFBQWE7Z0JBQ3hCLElBQUlTLFdBQVcsSUFBSSxDQUFDLENBQUNULFVBQVUsRUFBRTtvQkFDN0JTLFdBQVcsSUFBSSxDQUFDLENBQUNULFVBQVU7Z0JBQy9CO1lBQ0o7WUFDQSxNQUFPUyxZQUFZckMsWUFBYTtnQkFDNUIsNkJBQTZCO2dCQUM3QixJQUFJc0MsY0FBYztvQkFDZCxPQUFPO2dCQUNYO2dCQUNBLE1BQU12RixRQUFRLE1BQU0sSUFBSSxDQUFDQyxRQUFRLENBQUNvRCxRQUFRLENBQUNpQyxVQUFVO2dCQUNyRCxzREFBc0Q7Z0JBQ3RELElBQUl0RixTQUFTLE1BQU07b0JBQ2Y7Z0JBQ0o7Z0JBQ0EsZ0NBQWdDO2dCQUNoQyxLQUFLLE1BQU1JLFFBQVFKLE1BQU87b0JBQ3RCLElBQUlJLFNBQVMsSUFBSSxDQUFDQSxJQUFJLEVBQUU7d0JBQ3BCO29CQUNKO2dCQUNKO2dCQUNBLDhDQUE4QztnQkFDOUMsSUFBSyxJQUFJdUYsSUFBSSxHQUFHQSxJQUFJM0YsTUFBTXVCLE1BQU0sRUFBRW9FLElBQUs7b0JBQ25DLE1BQU16RixLQUFLLE1BQU1GLE1BQU1pQyxjQUFjLENBQUMwRDtvQkFDdEMsSUFBSXpGLEdBQUd2QixJQUFJLEtBQUssSUFBSSxDQUFDQSxJQUFJLElBQUl1QixHQUFHTyxLQUFLLEtBQUssSUFBSSxDQUFDQSxLQUFLLEVBQUU7d0JBQ2xELGtCQUFrQjt3QkFDbEIsSUFBSThFLGNBQWM7NEJBQ2QsT0FBTzt3QkFDWDt3QkFDQSxNQUFNaEMsVUFBVSxNQUFNLElBQUksQ0FBQ3RELFFBQVEsQ0FBQ3FELHFCQUFxQixDQUFDcEQsR0FBR0UsSUFBSTt3QkFDakUsc0RBQXNEO3dCQUN0RCxJQUFJbUQsV0FBVyxNQUFNOzRCQUNqQjt3QkFDSjt3QkFDQSxzRUFBc0U7d0JBQ3RFLElBQUksY0FBZUEsUUFBUU4sV0FBVyxHQUFHLElBQUttQyxVQUFVOzRCQUNwRDt3QkFDSjt3QkFDQSw4QkFBOEI7d0JBQzlCLElBQUlRLFNBQVM7d0JBQ2IsSUFBSTFGLEdBQUd0QixJQUFJLEtBQUssSUFBSSxDQUFDQSxJQUFJLElBQUlzQixHQUFHeEIsRUFBRSxLQUFLLElBQUksQ0FBQ0EsRUFBRSxJQUFJd0IsR0FBR3JDLEtBQUssS0FBSyxJQUFJLENBQUNBLEtBQUssRUFBRTs0QkFDdkUrSCxTQUFTO3dCQUNiLE9BQ0ssSUFBSTFGLEdBQUd0QixJQUFJLEtBQUssUUFBUXNCLEdBQUd2QixJQUFJLEtBQUt1QixHQUFHeEIsRUFBRSxJQUFJd0IsR0FBR3JDLEtBQUssS0FBS0gsTUFBTTs0QkFDakVrSSxTQUFTO3dCQUNiO3dCQUNBdkksdURBQU1BLENBQUMsT0FBTyw0QkFBNEIsd0JBQXdCOzRCQUM5RHdJLFdBQVlELFdBQVcsY0FBY0EsV0FBVzs0QkFDaERBOzRCQUNBRSxhQUFhNUYsR0FBRzZGLHNCQUFzQixDQUFDbEI7NEJBQ3ZDekUsTUFBTUYsR0FBR0UsSUFBSTs0QkFDYm1EO3dCQUNKO29CQUNKO2dCQUNKO2dCQUNBK0I7WUFDSjtZQUNBO1FBQ0o7UUFDQSxNQUFNVSxlQUFlLENBQUN6QztZQUNsQixJQUFJQSxXQUFXLFFBQVFBLFFBQVFXLE1BQU0sS0FBSyxHQUFHO2dCQUN6QyxPQUFPWDtZQUNYO1lBQ0FsRyx1REFBTUEsQ0FBQyxPQUFPLGtDQUFrQyxrQkFBa0I7Z0JBQzlENEksUUFBUTtnQkFDUnJILE1BQU07Z0JBQU1nSCxRQUFRO2dCQUFNTSxZQUFZO2dCQUFNQyxRQUFRO2dCQUNwREMsYUFBYTtvQkFDVDFILElBQUk2RSxRQUFRN0UsRUFBRTtvQkFDZEMsTUFBTTRFLFFBQVE1RSxJQUFJO29CQUNsQkMsTUFBTSxHQUFHLHFEQUFxRDtnQkFDbEU7Z0JBQUcyRTtZQUNQO1FBQ0o7UUFDQSxNQUFNQSxVQUFVLE1BQU0sSUFBSSxDQUFDdEQsUUFBUSxDQUFDcUQscUJBQXFCLENBQUMsSUFBSSxDQUFDbEQsSUFBSTtRQUNuRSxJQUFJZ0YsYUFBYSxHQUFHO1lBQ2hCLE9BQU9ZLGFBQWF6QztRQUN4QjtRQUNBLElBQUlBLFNBQVM7WUFDVCxJQUFJNkIsYUFBYSxLQUFLLE1BQU83QixRQUFRZ0IsYUFBYSxNQUFPYSxVQUFVO2dCQUMvRCxPQUFPWSxhQUFhekM7WUFDeEI7UUFDSixPQUNLO1lBQ0QsNkRBQTZEO1lBQzdELE1BQU1pQztZQUNOLHlDQUF5QztZQUN6QyxJQUFJSixhQUFhLEdBQUc7Z0JBQ2hCLE9BQU87WUFDWDtRQUNKO1FBQ0EsTUFBTWlCLFNBQVMsSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztZQUNqQyx3RUFBd0U7WUFDeEUsTUFBTUMsYUFBYSxFQUFFO1lBQ3JCLE1BQU1DLFNBQVM7Z0JBQVFELFdBQVdFLE9BQU8sQ0FBQyxDQUFDQyxJQUFNQTtZQUFNO1lBQ3ZELDRDQUE0QztZQUM1Q0gsV0FBV0ksSUFBSSxDQUFDO2dCQUFRdEIsZUFBZTtZQUFNO1lBQzdDLCtCQUErQjtZQUMvQixJQUFJRixVQUFVLEdBQUc7Z0JBQ2IsTUFBTXlCLFFBQVFDLFdBQVc7b0JBQ3JCTDtvQkFDQUYsT0FBT2hKLDBEQUFTQSxDQUFDLGdDQUFnQztnQkFDckQsR0FBRzZIO2dCQUNIb0IsV0FBV0ksSUFBSSxDQUFDO29CQUFRRyxhQUFhRjtnQkFBUTtZQUNqRDtZQUNBLE1BQU1HLGFBQWEsT0FBTzFEO2dCQUN0QixtQkFBbUI7Z0JBQ25CLElBQUksTUFBT0EsUUFBUWdCLGFBQWEsTUFBT2EsVUFBVTtvQkFDN0NzQjtvQkFDQSxJQUFJO3dCQUNBSCxRQUFRUCxhQUFhekM7b0JBQ3pCLEVBQ0EsT0FBTzJELE9BQU87d0JBQ1ZWLE9BQU9VO29CQUNYO2dCQUNKO1lBQ0o7WUFDQVQsV0FBV0ksSUFBSSxDQUFDO2dCQUFRLElBQUksQ0FBQzVHLFFBQVEsQ0FBQ2tILEdBQUcsQ0FBQyxJQUFJLENBQUMvRyxJQUFJLEVBQUU2RztZQUFhO1lBQ2xFLElBQUksQ0FBQ2hILFFBQVEsQ0FBQ21ILEVBQUUsQ0FBQyxJQUFJLENBQUNoSCxJQUFJLEVBQUU2RztZQUM1QixtREFBbUQ7WUFDbkQsSUFBSXBDLGNBQWMsR0FBRztnQkFDakIsTUFBTXdDLGtCQUFrQjtvQkFDcEIsSUFBSTt3QkFDQSw0REFBNEQ7d0JBQzVELE1BQU03QjtvQkFDVixFQUNBLE9BQU8wQixPQUFPO3dCQUNWLDhEQUE4RDt3QkFDOUQsSUFBSTNKLHdEQUFPQSxDQUFDMkosT0FBTyx5QkFBeUI7NEJBQ3hDUjs0QkFDQUYsT0FBT1U7NEJBQ1A7d0JBQ0o7b0JBQ0o7b0JBQ0EsdUNBQXVDO29CQUN2QyxJQUFJLENBQUMzQixjQUFjO3dCQUNmLElBQUksQ0FBQ3RGLFFBQVEsQ0FBQ3FILElBQUksQ0FBQyxTQUFTRDtvQkFDaEM7Z0JBQ0o7Z0JBQ0FaLFdBQVdJLElBQUksQ0FBQztvQkFBUSxJQUFJLENBQUM1RyxRQUFRLENBQUNrSCxHQUFHLENBQUMsU0FBU0U7Z0JBQWtCO2dCQUNyRSxJQUFJLENBQUNwSCxRQUFRLENBQUNxSCxJQUFJLENBQUMsU0FBU0Q7WUFDaEM7UUFDSjtRQUNBLE9BQU8sTUFBTWhCO0lBQ2pCO0lBQ0E7Ozs7Ozs7Ozs7S0FVQyxHQUNEOUQsVUFBVTtRQUNOLE9BQVEsSUFBSSxDQUFDUyxTQUFTLElBQUk7SUFDOUI7SUFDQTs7Ozs7O0tBTUMsR0FDRHVFLFdBQVc7UUFDUCxPQUFRLElBQUksQ0FBQ3RELElBQUksS0FBSztJQUMxQjtJQUNBOzs7Ozs7S0FNQyxHQUNEdUQsV0FBVztRQUNQLE9BQVEsSUFBSSxDQUFDdkQsSUFBSSxLQUFLO0lBQzFCO0lBQ0E7Ozs7OztLQU1DLEdBQ0R6QixXQUFXO1FBQ1AsT0FBUSxJQUFJLENBQUN5QixJQUFJLEtBQUs7SUFDMUI7SUFDQTs7O0tBR0MsR0FDRHdELFdBQVc7UUFDUCxPQUFRLElBQUksQ0FBQ3hELElBQUksS0FBSztJQUMxQjtJQUNBOzs7S0FHQyxHQUNEVCxlQUFlO1FBQ1huRyx1REFBTUEsQ0FBQyxJQUFJLENBQUNrRixPQUFPLElBQUkseUNBQXlDLHlCQUF5QjtZQUFFZixXQUFXO1FBQWdCO1FBQ3RILE9BQU9pRCwrQkFBK0IsSUFBSTtJQUM5QztJQUNBOzs7S0FHQyxHQUNEQyxlQUFlQyxLQUFLLEVBQUU7UUFDbEJ0SCx1REFBTUEsQ0FBQyxJQUFJLENBQUNrRixPQUFPLElBQUkseUNBQXlDLHlCQUF5QjtZQUFFZixXQUFXO1FBQWdCO1FBQ3RIbkUsdURBQU1BLENBQUMsQ0FBQ3NILFNBQVNBLE1BQU1wQyxPQUFPLElBQUksaURBQWlELHlCQUF5QjtZQUFFZixXQUFXO1FBQWdCO1FBQ3pJLE9BQU9vRCxpQ0FBaUMsSUFBSSxFQUFFRDtJQUNsRDtJQUNBOzs7Ozs7OztLQVFDLEdBQ0RvQix1QkFBdUJsQixVQUFVLEVBQUU7UUFDL0J2SCwrREFBY0EsQ0FBQ29LLE9BQU9DLFNBQVMsQ0FBQzlDLGVBQWVBLGNBQWMsR0FBRyxzQkFBc0IsY0FBY0E7UUFDcEcsTUFBTTNFLEtBQUssSUFBSUMsb0JBQW9CLElBQUksRUFBRSxJQUFJLENBQUNGLFFBQVE7UUFDdERDLEdBQUcsQ0FBQzJFLFVBQVUsR0FBR0E7UUFDakIsT0FBTzNFO0lBQ1g7QUFDSjtBQUNBLFNBQVN3QywwQkFBMEIxQyxLQUFLO0lBQ3BDLE9BQU87UUFBRTRILFFBQVE7UUFBY3hILE1BQU1KLE1BQU1JLElBQUk7UUFBRUMsUUFBUUwsTUFBTUssTUFBTTtJQUFDO0FBQzFFO0FBQ0EsU0FBU3VFLGlDQUFpQzFFLEVBQUUsRUFBRXlFLEtBQUs7SUFDL0MsT0FBTztRQUFFaUQsUUFBUTtRQUF1QjFIO1FBQUl5RTtJQUFNO0FBQ3REO0FBQ0EsU0FBU0YsK0JBQStCdkUsRUFBRTtJQUN0QyxPQUFPO1FBQUUwSCxRQUFRO1FBQW9CMUg7SUFBRztBQUM1QztBQUNBLFNBQVN1RCx1QkFBdUJiLEdBQUc7SUFDL0IsT0FBTztRQUFFZ0YsUUFBUTtRQUFZaEYsS0FBSztZQUMxQkcsaUJBQWlCSCxJQUFJRyxlQUFlO1lBQ3BDQyxXQUFXSixJQUFJSSxTQUFTO1lBQ3hCQyxhQUFhTCxJQUFJSyxXQUFXO1lBQzVCRSxTQUFTUCxJQUFJTyxPQUFPO1lBQ3BCdkUsTUFBTWdFLElBQUloRSxJQUFJO1lBQ2RpRSxRQUFRakQsT0FBT2tELE1BQU0sQ0FBQ0YsSUFBSUMsTUFBTSxDQUFDMUQsS0FBSztZQUN0Q3dDLE9BQU9pQixJQUFJakIsS0FBSztRQUNwQjtJQUFFO0FBQ1YsRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95aWQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vcHJvdmlkZXJzL3Byb3ZpZGVyLmpzPzY4YTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy9pbXBvcnQgeyByZXNvbHZlQWRkcmVzcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hZGRyZXNzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzLCBnZXRCaWdJbnQsIGdldE51bWJlciwgaGV4bGlmeSwgaXNCeXRlc0xpa2UsIHJlc29sdmVQcm9wZXJ0aWVzLCBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBpc0Vycm9yLCBtYWtlRXJyb3IgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gZ2V0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gdG9Kc29uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xufVxuLy8gQFRPRE8/IDxUIGV4dGVuZHMgRmVlRGF0YSA9IHsgfT4gaW1wbGVtZW50cyBSZXF1aXJlZDxUPlxuLyoqXG4gKiAgQSAqKkZlZURhdGEqKiB3cmFwcyBhbGwgdGhlIGZlZS1yZWxhdGVkIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGhcbiAqICB0aGUgbmV0d29yay5cbiAqL1xuZXhwb3J0IGNsYXNzIEZlZURhdGEge1xuICAgIC8qKlxuICAgICAqICBUaGUgZ2FzIHByaWNlIGZvciBsZWdhY3kgbmV0d29ya3MuXG4gICAgICovXG4gICAgZ2FzUHJpY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIGZlZSB0byBwYXkgcGVyIGdhcy5cbiAgICAgKlxuICAgICAqICBUaGUgYmFzZSBmZWUgcGVyIGdhcyBpcyBkZWZpbmVkIGJ5IHRoZSBuZXR3b3JrIGFuZCBiYXNlZCBvblxuICAgICAqICBjb25nZXN0aW9uLCBpbmNyZWFzaW5nIHRoZSBjb3N0IGR1cmluZyB0aW1lcyBvZiBoZWF2eSBsb2FkXG4gICAgICogIGFuZCBsb3dlcmluZyB3aGVuIGxlc3MgYnVzeS5cbiAgICAgKlxuICAgICAqICBUaGUgYWN0dWFsIGZlZSBwZXIgZ2FzIHdpbGwgYmUgdGhlIGJhc2UgZmVlIGZvciB0aGUgYmxvY2tcbiAgICAgKiAgYW5kIHRoZSBwcmlvcml0eSBmZWUsIHVwIHRvIHRoZSBtYXggZmVlIHBlciBnYXMuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIGJlIGBgbnVsbGBgIG9uIGxlZ2FjeSBuZXR3b3JrcyAoaS5lLiBbcHJlLUVJUC0xNTU5XShsaW5rLWVpcC0xNTU5KSlcbiAgICAgKi9cbiAgICBtYXhGZWVQZXJHYXM7XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRpdGlvbmFsIGFtb3V0IHRvIHBheSBwZXIgZ2FzIHRvIGVuY291cmFnZSBhIHZhbGlkYXRvclxuICAgICAqICB0byBpbmNsdWRlIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGUgcHVycG9zZSBvZiB0aGlzIGlzIHRvIGNvbXBlbnNhdGUgdGhlIHZhbGlkYXRvciBmb3IgdGhlXG4gICAgICogIGFkanVzdGVkIHJpc2sgZm9yIGluY2x1ZGluZyBhIGdpdmVuIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCBiZSBgYG51bGxgYCBvbiBsZWdhY3kgbmV0d29ya3MgKGkuZS4gW3ByZS1FSVAtMTU1OV0obGluay1laXAtMTU1OSkpXG4gICAgICovXG4gICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgRmVlRGF0YSBmb3IgJSVnYXNQcmljZSUlLCAlJW1heEZlZVBlckdhcyUlIGFuZFxuICAgICAqICAlJW1heFByaW9yaXR5RmVlUGVyR2FzJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBnYXNQcmljZTogZ2V0VmFsdWUoZ2FzUHJpY2UpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBnZXRWYWx1ZShtYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGdldFZhbHVlKG1heFByaW9yaXR5RmVlUGVyR2FzKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWZyaWVuZGx5IHZhbHVlLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcIkZlZURhdGFcIixcbiAgICAgICAgICAgIGdhc1ByaWNlOiB0b0pzb24oZ2FzUHJpY2UpLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0b0pzb24obWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0b0pzb24obWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbjtcbi8qKlxuICogIFJldHVybnMgYSBjb3B5IG9mICUlcmVxJSUgd2l0aCBhbGwgcHJvcGVydGllcyBjb2VyY2VkIHRvIHRoZWlyIHN0cmljdFxuICogIHR5cGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weVJlcXVlc3QocmVxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgLy8gVGhlc2UgY291bGQgYmUgYWRkcmVzc2VzLCBFTlMgbmFtZXMgb3IgQWRkcmVzc2FibGVzXG4gICAgaWYgKHJlcS50bykge1xuICAgICAgICByZXN1bHQudG8gPSByZXEudG87XG4gICAgfVxuICAgIGlmIChyZXEuZnJvbSkge1xuICAgICAgICByZXN1bHQuZnJvbSA9IHJlcS5mcm9tO1xuICAgIH1cbiAgICBpZiAocmVxLmRhdGEpIHtcbiAgICAgICAgcmVzdWx0LmRhdGEgPSBoZXhsaWZ5KHJlcS5kYXRhKTtcbiAgICB9XG4gICAgY29uc3QgYmlnSW50S2V5cyA9IFwiY2hhaW5JZCxnYXNMaW1pdCxnYXNQcmljZSxtYXhGZWVQZXJCbG9iR2FzLG1heEZlZVBlckdhcyxtYXhQcmlvcml0eUZlZVBlckdhcyx2YWx1ZVwiLnNwbGl0KC8sLyk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgYmlnSW50S2V5cykge1xuICAgICAgICBpZiAoIShrZXkgaW4gcmVxKSB8fCByZXFba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRba2V5XSA9IGdldEJpZ0ludChyZXFba2V5XSwgYHJlcXVlc3QuJHtrZXl9YCk7XG4gICAgfVxuICAgIGNvbnN0IG51bWJlcktleXMgPSBcInR5cGUsbm9uY2VcIi5zcGxpdCgvLC8pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIG51bWJlcktleXMpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHJlcSkgfHwgcmVxW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2tleV0gPSBnZXROdW1iZXIocmVxW2tleV0sIGByZXF1ZXN0LiR7a2V5fWApO1xuICAgIH1cbiAgICBpZiAocmVxLmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgcmVzdWx0LmFjY2Vzc0xpc3QgPSBhY2Nlc3NMaXN0aWZ5KHJlcS5hY2Nlc3NMaXN0KTtcbiAgICB9XG4gICAgaWYgKHJlcS5hdXRob3JpemF0aW9uTGlzdCkge1xuICAgICAgICByZXN1bHQuYXV0aG9yaXphdGlvbkxpc3QgPSByZXEuYXV0aG9yaXphdGlvbkxpc3Quc2xpY2UoKTtcbiAgICB9XG4gICAgaWYgKFwiYmxvY2tUYWdcIiBpbiByZXEpIHtcbiAgICAgICAgcmVzdWx0LmJsb2NrVGFnID0gcmVxLmJsb2NrVGFnO1xuICAgIH1cbiAgICBpZiAoXCJlbmFibGVDY2lwUmVhZFwiIGluIHJlcSkge1xuICAgICAgICByZXN1bHQuZW5hYmxlQ2NpcFJlYWQgPSAhIXJlcS5lbmFibGVDY2lwUmVhZDtcbiAgICB9XG4gICAgaWYgKFwiY3VzdG9tRGF0YVwiIGluIHJlcSkge1xuICAgICAgICByZXN1bHQuY3VzdG9tRGF0YSA9IHJlcS5jdXN0b21EYXRhO1xuICAgIH1cbiAgICBpZiAoXCJibG9iVmVyc2lvbmVkSGFzaGVzXCIgaW4gcmVxICYmIHJlcS5ibG9iVmVyc2lvbmVkSGFzaGVzKSB7XG4gICAgICAgIHJlc3VsdC5ibG9iVmVyc2lvbmVkSGFzaGVzID0gcmVxLmJsb2JWZXJzaW9uZWRIYXNoZXMuc2xpY2UoKTtcbiAgICB9XG4gICAgaWYgKFwia3pnXCIgaW4gcmVxKSB7XG4gICAgICAgIHJlc3VsdC5remcgPSByZXEua3pnO1xuICAgIH1cbiAgICBpZiAoXCJibG9ic1wiIGluIHJlcSAmJiByZXEuYmxvYnMpIHtcbiAgICAgICAgcmVzdWx0LmJsb2JzID0gcmVxLmJsb2JzLm1hcCgoYikgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQnl0ZXNMaWtlKGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgQSAqKkJsb2NrKiogcmVwcmVzZW50cyB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggYSBmdWxsIGJsb2NrIG9uXG4gKiAgRXRoZXJldW0uXG4gKi9cbmV4cG9ydCBjbGFzcyBCbG9jayB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciBjb25uZWN0ZWQgdG8gdGhlIGJsb2NrIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXG4gICAgICogIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciwgc29tZXRpbWVzIGNhbGxlZCB0aGUgYmxvY2sgaGVpZ2h0LiBUaGlzIGlzIGFcbiAgICAgKiAgc2VxdWVudGlhbCBudW1iZXIgdGhhdCBpcyBvbmUgaGlnaGVyIHRoYW4gdGhlIHBhcmVudCBibG9jay5cbiAgICAgKi9cbiAgICBudW1iZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoLlxuICAgICAqXG4gICAgICogIFRoaXMgaGFzaCBpbmNsdWRlcyBhbGwgcHJvcGVydGllcywgc28gY2FuIGJlIHNhZmVseSB1c2VkIHRvIGlkZW50aWZ5XG4gICAgICogIGFuIGV4YWN0IHNldCBvZiBibG9jayBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSB0aW1lc3RhbXAgZm9yIHRoaXMgYmxvY2ssIHdoaWNoIGlzIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZVxuICAgICAqICBlcG9jaCB0aGF0IHRoaXMgYmxvY2sgd2FzIGluY2x1ZGVkLlxuICAgICAqL1xuICAgIHRpbWVzdGFtcDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2ggb2YgdGhlIHBhcmVudCBibG9jay5cbiAgICAgKi9cbiAgICBwYXJlbnRIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgaGFzaCB0cmVlIHJvb3Qgb2YgdGhlIHBhcmVudCBiZWFjb24gYmxvY2sgZm9yIHRoZSBnaXZlblxuICAgICAqICBleGVjdXRpb24gYmxvY2suIFNlZSBbW2xpbmstZWlwLTQ3ODhdXS5cbiAgICAgKi9cbiAgICBwYXJlbnRCZWFjb25CbG9ja1Jvb3Q7XG4gICAgLyoqXG4gICAgICogIFRoZSBub25jZS5cbiAgICAgKlxuICAgICAqICBPbiBsZWdhY3kgbmV0d29ya3MsIHRoaXMgaXMgdGhlIHJhbmRvbSBudW1iZXIgaW5zZXJ0ZWQgd2hpY2hcbiAgICAgKiAgcGVybWl0dGVkIHRoZSBkaWZmaWN1bHR5IHRhcmdldCB0byBiZSByZWFjaGVkLlxuICAgICAqL1xuICAgIG5vbmNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGlmZmljdWx0eSB0YXJnZXQuXG4gICAgICpcbiAgICAgKiAgT24gbGVnYWN5IG5ldHdvcmtzLCB0aGlzIGlzIHRoZSBwcm9vZi1vZi13b3JrIHRhcmdldCByZXF1aXJlZFxuICAgICAqICBmb3IgYSBibG9jayB0byBtZWV0IHRoZSBwcm90b2NvbCBydWxlcyB0byBiZSBpbmNsdWRlZC5cbiAgICAgKlxuICAgICAqICBPbiBtb2Rlcm4gbmV0d29ya3MsIHRoaXMgaXMgYSByYW5kb20gbnVtYmVyIGFycml2ZWQgYXQgdXNpbmdcbiAgICAgKiAgcmFuZGFvLiAgQFRPRE86IEZpbmQgbGlua3M/XG4gICAgICovXG4gICAgZGlmZmljdWx0eTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRvdGFsIGdhcyBsaW1pdCBmb3IgdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBnYXNMaW1pdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRvdGFsIGdhcyB1c2VkIGluIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgZ2FzVXNlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJvb3QgaGFzaCBmb3IgdGhlIGdsb2JhbCBzdGF0ZSBhZnRlciBhcHBseWluZyBjaGFuZ2VzXG4gICAgICogIGluIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgc3RhdGVSb290O1xuICAgIC8qKlxuICAgICAqICBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdHMgdHJpZS5cbiAgICAgKi9cbiAgICByZWNlaXB0c1Jvb3Q7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBhbW91bnQgb2YgYmxvYiBnYXMgY29uc3VtZWQgYnkgdGhlIHRyYW5zYWN0aW9uc1xuICAgICAqICB3aXRoaW4gdGhlIGJsb2NrLiBTZWUgW1tsaW5rLWVpcC00ODQ0XV0uXG4gICAgICovXG4gICAgYmxvYkdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBydW5uaW5nIHRvdGFsIG9mIGJsb2IgZ2FzIGNvbnN1bWVkIGluIGV4Y2VzcyBvZiB0aGVcbiAgICAgKiAgdGFyZ2V0LCBwcmlvciB0byB0aGUgYmxvY2suIFNlZSBbW2xpbmstZWlwLTQ4NDRdXS5cbiAgICAgKi9cbiAgICBleGNlc3NCbG9iR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWluZXIgY29pbmJhc2UgYWRkcmVzcywgd2loY2ggcmVjZWl2ZXMgYW55IHN1YnNpZGllcyBmb3JcbiAgICAgKiAgaW5jbHVkaW5nIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgbWluZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBsYXRlc3QgUkFOREFPIG1peCBvZiB0aGUgcG9zdCBiZWFjb24gc3RhdGUgb2ZcbiAgICAgKiAgdGhlIHByZXZpb3VzIGJsb2NrLlxuICAgICAqL1xuICAgIHByZXZSYW5kYW87XG4gICAgLyoqXG4gICAgICogIEFueSBleHRyYSBkYXRhIHRoZSB2YWxpZGF0b3Igd2lzaGVkIHRvIGluY2x1ZGUuXG4gICAgICovXG4gICAgZXh0cmFEYXRhO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmFzZSBmZWUgcGVyIGdhcyB0aGF0IGFsbCB0cmFuc2FjdGlvbnMgaW4gdGhpcyBibG9jayB3ZXJlXG4gICAgICogIGNoYXJnZWQuXG4gICAgICpcbiAgICAgKiAgVGhpcyBhZGp1c3RzIGFmdGVyIGVhY2ggYmxvY2ssIGRlcGVuZGluZyBvbiBob3cgY29uZ2VzdGVkIHRoZSBuZXR3b3JrXG4gICAgICogIGlzLlxuICAgICAqL1xuICAgIGJhc2VGZWVQZXJHYXM7XG4gICAgI3RyYW5zYWN0aW9ucztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqQmxvY2sqKiBvYmplY3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgZ2VuZXJhbGx5IG5vdCBiZSBuZWNlc3NhcnkgYXMgdGhlIHVubGVzcyBpbXBsZW1lbnRpbmcgYVxuICAgICAqICBsb3ctbGV2ZWwgbGlicmFyeS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihibG9jaywgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jdHJhbnNhY3Rpb25zID0gYmxvY2sudHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHR4KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSh0eCwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgIGhhc2g6IGdldFZhbHVlKGJsb2NrLmhhc2gpLFxuICAgICAgICAgICAgbnVtYmVyOiBibG9jay5udW1iZXIsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGJsb2NrLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIHBhcmVudEhhc2g6IGJsb2NrLnBhcmVudEhhc2gsXG4gICAgICAgICAgICBwYXJlbnRCZWFjb25CbG9ja1Jvb3Q6IGJsb2NrLnBhcmVudEJlYWNvbkJsb2NrUm9vdCxcbiAgICAgICAgICAgIG5vbmNlOiBibG9jay5ub25jZSxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IGJsb2NrLmRpZmZpY3VsdHksXG4gICAgICAgICAgICBnYXNMaW1pdDogYmxvY2suZ2FzTGltaXQsXG4gICAgICAgICAgICBnYXNVc2VkOiBibG9jay5nYXNVc2VkLFxuICAgICAgICAgICAgYmxvYkdhc1VzZWQ6IGJsb2NrLmJsb2JHYXNVc2VkLFxuICAgICAgICAgICAgZXhjZXNzQmxvYkdhczogYmxvY2suZXhjZXNzQmxvYkdhcyxcbiAgICAgICAgICAgIG1pbmVyOiBibG9jay5taW5lcixcbiAgICAgICAgICAgIHByZXZSYW5kYW86IGdldFZhbHVlKGJsb2NrLnByZXZSYW5kYW8pLFxuICAgICAgICAgICAgZXh0cmFEYXRhOiBibG9jay5leHRyYURhdGEsXG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiBnZXRWYWx1ZShibG9jay5iYXNlRmVlUGVyR2FzKSxcbiAgICAgICAgICAgIHN0YXRlUm9vdDogYmxvY2suc3RhdGVSb290LFxuICAgICAgICAgICAgcmVjZWlwdHNSb290OiBibG9jay5yZWNlaXB0c1Jvb3QsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgbGlzdCBvZiB0cmFuc2FjdGlvbiBoYXNoZXMsIGluIHRoZSBvcmRlclxuICAgICAqICB0aGV5IHdlcmUgZXhlY3V0ZWQgd2l0aGluIHRoZSBibG9jay5cbiAgICAgKi9cbiAgICBnZXQgdHJhbnNhY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eC5oYXNoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGNvbXBsZXRlIHRyYW5zYWN0aW9ucywgaW4gdGhlIG9yZGVyIHRoZXlcbiAgICAgKiAgd2VyZSBleGVjdXRlZCB3aXRoaW4gdGhlIGJsb2NrLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgb25seSBhdmFpbGFibGUgZm9yIGJsb2NrcyB3aGljaCBwcmVmZXRjaGVkXG4gICAgICogIHRyYW5zYWN0aW9ucywgYnkgcGFzc2luZyBgYHRydWVgYCB0byAlJXByZWZldGNoVHhzJSVcbiAgICAgKiAgaW50byBbW1Byb3ZpZGVyLWdldEJsb2NrXV0uXG4gICAgICovXG4gICAgZ2V0IHByZWZldGNoZWRUcmFuc2FjdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHR4cyA9IHRoaXMuI3RyYW5zYWN0aW9ucy5zbGljZSgpO1xuICAgICAgICAvLyBEb2Vzbid0IG1hdHRlci4uLlxuICAgICAgICBpZiAodHhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBwcmVmZXRjaGVkIHRoZSB0cmFuc2FjdGlvbnNcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiAodHhzWzBdKSA9PT0gXCJvYmplY3RcIiwgXCJ0cmFuc2FjdGlvbnMgd2VyZSBub3QgcHJlZmV0Y2hlZCB3aXRoIGJsb2NrIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRyYW5zYWN0aW9uUmVzcG9uc2VzKClcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR4cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWZyaWVuZGx5IHZhbHVlLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBiYXNlRmVlUGVyR2FzLCBkaWZmaWN1bHR5LCBleHRyYURhdGEsIGdhc0xpbWl0LCBnYXNVc2VkLCBoYXNoLCBtaW5lciwgcHJldlJhbmRhbywgbm9uY2UsIG51bWJlciwgcGFyZW50SGFzaCwgcGFyZW50QmVhY29uQmxvY2tSb290LCBzdGF0ZVJvb3QsIHJlY2VpcHRzUm9vdCwgdGltZXN0YW1wLCB0cmFuc2FjdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJCbG9ja1wiLFxuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogdG9Kc29uKGJhc2VGZWVQZXJHYXMpLFxuICAgICAgICAgICAgZGlmZmljdWx0eTogdG9Kc29uKGRpZmZpY3VsdHkpLFxuICAgICAgICAgICAgZXh0cmFEYXRhLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IHRvSnNvbihnYXNMaW1pdCksXG4gICAgICAgICAgICBnYXNVc2VkOiB0b0pzb24oZ2FzVXNlZCksXG4gICAgICAgICAgICBibG9iR2FzVXNlZDogdG9Kc29uKHRoaXMuYmxvYkdhc1VzZWQpLFxuICAgICAgICAgICAgZXhjZXNzQmxvYkdhczogdG9Kc29uKHRoaXMuZXhjZXNzQmxvYkdhcyksXG4gICAgICAgICAgICBoYXNoLCBtaW5lciwgcHJldlJhbmRhbywgbm9uY2UsIG51bWJlciwgcGFyZW50SGFzaCwgdGltZXN0YW1wLFxuICAgICAgICAgICAgcGFyZW50QmVhY29uQmxvY2tSb290LCBzdGF0ZVJvb3QsIHJlY2VpcHRzUm9vdCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IHR4cyA9IHRoaXMudHJhbnNhY3Rpb25zO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHhzW2luZGV4KytdLCBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbnVtYmVyIG9mIHRyYW5zYWN0aW9ucyBpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLiN0cmFuc2FjdGlvbnMubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstanMtZGF0ZV1dIHRoaXMgYmxvY2sgd2FzIGluY2x1ZGVkIGF0LlxuICAgICAqL1xuICAgIGdldCBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lc3RhbXAgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudGltZXN0YW1wICogMTAwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIHRyYW5zYWN0aW9uIGF0ICUlaW5kZXhlJSUgd2l0aGluIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oaW5kZXhPckhhc2gpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgaW50ZXJuYWwgdmFsdWUgYnkgaXRzIGluZGV4IG9yIGhhc2hcbiAgICAgICAgbGV0IHR4ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHlwZW9mIChpbmRleE9ySGFzaCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHR4ID0gdGhpcy4jdHJhbnNhY3Rpb25zW2luZGV4T3JIYXNoXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBpbmRleE9ySGFzaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHRoaXMuI3RyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHYpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSBoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0eCA9IHY7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYuaGFzaCAhPT0gaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHggPSB2O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHN1Y2ggdHhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodHgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24odHgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgYSAqKkJsb2NrKiogd2FzIGZldGNoZWQgd2l0aCBhIHJlcXVlc3QgdG8gaW5jbHVkZSB0aGUgdHJhbnNhY3Rpb25zXG4gICAgICogIHRoaXMgd2lsbCBhbGxvdyBzeW5jaHJvbm91cyBhY2Nlc3MgdG8gdGhvc2UgdHJhbnNhY3Rpb25zLlxuICAgICAqXG4gICAgICogIElmIHRoZSB0cmFuc2FjdGlvbnMgd2VyZSBub3QgcHJlZmV0Y2hlZCwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqL1xuICAgIGdldFByZWZldGNoZWRUcmFuc2FjdGlvbihpbmRleE9ySGFzaCkge1xuICAgICAgICBjb25zdCB0eHMgPSB0aGlzLnByZWZldGNoZWRUcmFuc2FjdGlvbnM7XG4gICAgICAgIGlmICh0eXBlb2YgKGluZGV4T3JIYXNoKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHR4c1tpbmRleE9ySGFzaF07XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXhPckhhc2ggPSBpbmRleE9ySGFzaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IHR4IG9mIHR4cykge1xuICAgICAgICAgICAgaWYgKHR4Lmhhc2ggPT09IGluZGV4T3JIYXNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcIm5vIG1hdGNoaW5nIHRyYW5zYWN0aW9uXCIsIFwiaW5kZXhPckhhc2hcIiwgaW5kZXhPckhhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgYmxvY2sgYmVlbiBtaW5lZC4gVGhpcyBwcm92aWRlcyBhIHR5cGUgZ3VhcmRcbiAgICAgKiAgZm9yIGFsbCBwcm9wZXJ0aWVzIG9uIGEgW1tNaW5lZEJsb2NrXV0uXG4gICAgICovXG4gICAgaXNNaW5lZCgpIHsgcmV0dXJuICEhdGhpcy5oYXNoOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGJsb2NrIGlzIGFuIFtbbGluay1laXAtMjkzMF1dIGJsb2NrLlxuICAgICAqL1xuICAgIGlzTG9uZG9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmJhc2VGZWVQZXJHYXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBvcnBoYW5lZEV2ZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNNaW5lZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9ycGhhbmVkQmxvY2tGaWx0ZXIodGhpcyk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTG9nXG4vKipcbiAqICBBICoqTG9nKiogaW4gRXRoZXJldW0gcmVwcmVzZW50cyBhbiBldmVudCB0aGF0IGhhcyBiZWVuIGluY2x1ZGVkIGluIGFcbiAqICB0cmFuc2FjdGlvbiB1c2luZyB0aGUgYGBMT0cqYGAgb3Bjb2Rlcywgd2hpY2ggYXJlIG1vc3QgY29tbW9ubHkgdXNlZCBieVxuICogIFNvbGlkaXR5J3MgZW1pdCBmb3IgYW5ub3VuY2luZyBldmVudHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2cge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgY29ubmVjdGVkIHRvIHRoZSBsb2cgdXNlZCB0byBmZXRjaCBhZGRpdGlvbmFsIGRldGFpbHNcbiAgICAgKiAgaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gdGhpcyBsb2cgb2NjdXJyZWQgaW4uIFVzZSB0aGVcbiAgICAgKiAgW1tMb2ctZ2V0VHJhbnNhY3Rpb25dXSB0byBnZXQgdGhlIFtbVHJhbnNhY3Rpb25SZXNwb25zZV1dLlxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9uSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2ggb2YgdGhlIGJsb2NrIHRoaXMgbG9nIG9jY3VycmVkIGluLiBVc2UgdGhlXG4gICAgICogIFtbTG9nLWdldEJsb2NrXV0gdG8gZ2V0IHRoZSBbW0Jsb2NrXV0uXG4gICAgICovXG4gICAgYmxvY2tIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBibG9jayB0aGlzIGxvZyBvY2N1cnJlZCBpbi4gSXQgaXMgcHJlZmVycmVkXG4gICAgICogIHRvIHVzZSB0aGUgW1tCbG9jay1oYXNoXV0gd2hlbiBmZXRjaGluZyB0aGUgcmVsYXRlZCBbW0Jsb2NrXV0sXG4gICAgICogIHNpbmNlIGluIHRoZSBjYXNlIG9mIGFuIG9ycGhhbmVkIGJsb2NrLCB0aGUgYmxvY2sgYXQgdGhhdCBoZWlnaHQgbWF5XG4gICAgICogIGhhdmUgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlICoqTG9nKiogcmVwcmVzZW50cyBhIGJsb2NrIHRoYXQgd2FzIHJlbW92ZWQgZHVlIHRvIGFuIG9ycGhhbmVkXG4gICAgICogIGJsb2NrLCB0aGlzIHdpbGwgYmUgdHJ1ZS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiBvbmx5IGhhcHBlbiB3aXRoaW4gYW4gb3JwaGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuICAgIHJlbW92ZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRyZXNzIG9mIHRoZSBjb250cmFjdCB0aGF0IGVtaXR0ZWQgdGhpcyBsb2cuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhpcyBsb2cgd2hlbiBpdCB3YXMgZW1pdHRlZC5cbiAgICAgKi9cbiAgICBkYXRhO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXhlZCB0b3BpY3MgaW5jbHVkZWQgaW4gdGhpcyBsb2cgd2hlbiBpdCB3YXMgZW1pdHRlZC5cbiAgICAgKlxuICAgICAqICBBbGwgdG9waWNzIGFyZSBpbmNsdWRlZCBpbiB0aGUgYmxvb20gZmlsdGVycywgc28gdGhleSBjYW4gYmVcbiAgICAgKiAgZWZmaWNpZW50bHkgZmlsdGVyZWQgdXNpbmcgdGhlIFtbUHJvdmlkZXItZ2V0TG9nc11dIG1ldGhvZC5cbiAgICAgKi9cbiAgICB0b3BpY3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleCB3aXRoaW4gdGhlIGJsb2NrIHRoaXMgbG9nIG9jY3VycmVkIGF0LiBUaGlzIGlzIGdlbmVyYWxseVxuICAgICAqICBub3QgdXNlZnVsIHRvIGRldmVsb3BlcnMsIGJ1dCBjYW4gYmUgdXNlZCB3aXRoIHRoZSB2YXJpb3VzIHJvb3RzXG4gICAgICogIHRvIHByb29mIGluY2x1c2lvbiB3aXRoaW4gYSBibG9jay5cbiAgICAgKi9cbiAgICBpbmRleDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24gb2YgdGhpcyBsb2cuXG4gICAgICovXG4gICAgdHJhbnNhY3Rpb25JbmRleDtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9nLCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IE9iamVjdC5mcmVlemUobG9nLnRvcGljcy5zbGljZSgpKTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGxvZy50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICBibG9ja0hhc2g6IGxvZy5ibG9ja0hhc2gsXG4gICAgICAgICAgICBibG9ja051bWJlcjogbG9nLmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgcmVtb3ZlZDogbG9nLnJlbW92ZWQsXG4gICAgICAgICAgICBhZGRyZXNzOiBsb2cuYWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGE6IGxvZy5kYXRhLFxuICAgICAgICAgICAgdG9waWNzLFxuICAgICAgICAgICAgaW5kZXg6IGxvZy5pbmRleCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IGxvZy50cmFuc2FjdGlvbkluZGV4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0LlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBhZGRyZXNzLCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBkYXRhLCBpbmRleCwgcmVtb3ZlZCwgdG9waWNzLCB0cmFuc2FjdGlvbkhhc2gsIHRyYW5zYWN0aW9uSW5kZXggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJsb2dcIixcbiAgICAgICAgICAgIGFkZHJlc3MsIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsIGRhdGEsIGluZGV4LFxuICAgICAgICAgICAgcmVtb3ZlZCwgdG9waWNzLCB0cmFuc2FjdGlvbkhhc2gsIHRyYW5zYWN0aW9uSW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGJsb2NrIHRoYXQgdGhpcyBsb2cgb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9jayh0aGlzLmJsb2NrSGFzaCk7XG4gICAgICAgIGFzc2VydCghIWJsb2NrLCBcImZhaWxlZCB0byBmaW5kIHRyYW5zYWN0aW9uXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7fSk7XG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIHRoYXQgdGhpcyBsb2cgb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgIGFzc2VydCghIXR4LCBcImZhaWxlZCB0byBmaW5kIHRyYW5zYWN0aW9uXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7fSk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHQgZm90IHRoZSB0cmFuc2FjdGlvbiB0aGF0IHRoaXNcbiAgICAgKiAgbG9nIG9jY3VycmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCgpIHtcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgYXNzZXJ0KCEhcmVjZWlwdCwgXCJmYWlsZWQgdG8gZmluZCB0cmFuc2FjdGlvbiByZWNlaXB0XCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7fSk7XG4gICAgICAgIHJldHVybiByZWNlaXB0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgcmVtb3ZlZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVtb3ZlZExvZ0ZpbHRlcih0aGlzKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBUcmFuc2FjdGlvbiBSZWNlaXB0XG4vKlxuZXhwb3J0IGludGVyZmFjZSBMZWdhY3lUcmFuc2FjdGlvblJlY2VpcHQge1xuICAgIGJ5emFudGl1bTogZmFsc2U7XG4gICAgc3RhdHVzOiBudWxsO1xuICAgIHJvb3Q6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCeXphbnRpdW1UcmFuc2FjdGlvblJlY2VpcHQge1xuICAgIGJ5emFudGl1bTogdHJ1ZTtcbiAgICBzdGF0dXM6IG51bWJlcjtcbiAgICByb290OiBudWxsO1xufVxuKi9cbi8qKlxuICogIEEgKipUcmFuc2FjdGlvblJlY2VpcHQqKiBpbmNsdWRlcyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IGFcbiAqICB0cmFuc2FjdGlvbiB0aGF0IGlzIG9ubHkgYXZhaWxhYmxlIGFmdGVyIGl0IGhhcyBiZWVuIG1pbmVkLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIGNvbm5lY3RlZCB0byB0aGUgbG9nIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXG4gICAgICogIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZHJlc3MgdGhlIHRyYW5zYWN0aW9uIHdhcyBzZW50IHRvLlxuICAgICAqL1xuICAgIHRvO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VuZGVyIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBmcm9tO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgaWYgdGhlIHRyYW5zYWN0aW9uIHdhcyBkaXJlY3RseVxuICAgICAqICByZXNwb25zaWJsZSBmb3IgZGVwbG95aW5nIG9uZS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vbi1udWxsICoqb25seSoqIGlmIHRoZSBgYHRvYGAgaXMgZW1wdHkgYW5kIHRoZSBgYGRhdGFgYFxuICAgICAqICB3YXMgc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkIGFzIGluaXRjb2RlLlxuICAgICAqL1xuICAgIGNvbnRyYWN0QWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IG9mIHRoaXMgdHJhbnNhY3Rpb24gd2l0aGluIHRoZSBibG9jayB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoIG9mIHRoZSBbW0Jsb2NrXV0gdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICovXG4gICAgYmxvY2tIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBbW0Jsb2NrXV0gdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9vbSBmaWx0ZXIgYnl0ZXMgdGhhdCByZXByZXNlbnQgYWxsIGxvZ3MgdGhhdCBvY2N1cnJlZCB3aXRoaW5cbiAgICAgKiAgdGhpcyB0cmFuc2FjdGlvbi4gVGhpcyBpcyBnZW5lcmFsbHkgbm90IHVzZWZ1bCBmb3IgbW9zdCBkZXZlbG9wZXJzLFxuICAgICAqICBidXQgY2FuIGJlIHVzZWQgdG8gdmFsaWRhdGUgdGhlIGluY2x1ZGVkIGxvZ3MuXG4gICAgICovXG4gICAgbG9nc0Jsb29tO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWN0dWFsIGFtb3VudCBvZiBnYXMgdXNlZCBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFdoZW4gY3JlYXRpbmcgYSB0cmFuc2FjdGlvbiwgdGhlIGFtb3VudCBvZiBnYXMgdGhhdCB3aWxsIGJlIHVzZWQgY2FuXG4gICAgICogIG9ubHkgYmUgYXBwcm94aW1hdGVkLCBidXQgdGhlIHNlbmRlciBtdXN0IHBheSB0aGUgZ2FzIGZlZSBmb3IgdGhlXG4gICAgICogIGVudGlyZSBnYXMgbGltaXQuIEFmdGVyIHRoZSB0cmFuc2FjdGlvbiwgdGhlIGRpZmZlcmVuY2UgaXMgcmVmdW5kZWQuXG4gICAgICovXG4gICAgZ2FzVXNlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyB1c2VkIGZvciBCTE9icy4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGJsb2JHYXNVc2VkO1xuICAgIC8qKlxuICAgICAqICBUaGUgYW1vdW50IG9mIGdhcyB1c2VkIGJ5IGFsbCB0cmFuc2FjdGlvbnMgd2l0aGluIHRoZSBibG9jayBmb3IgdGhpc1xuICAgICAqICBhbmQgYWxsIHRyYW5zYWN0aW9ucyB3aXRoIGEgbG93ZXIgYGBpbmRleGBgLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgZm9yIGRldmVsb3BlcnMgYnV0IGNhbiBiZSB1c2VkIHRvXG4gICAgICogIHZhbGlkYXRlIGNlcnRhaW4gYXNwZWN0cyBvZiBleGVjdXRpb24uXG4gICAgICovXG4gICAgY3VtdWxhdGl2ZUdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBhY3R1YWwgZ2FzIHByaWNlIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbi5cbiAgICAgKlxuICAgICAqICBEdWUgdG8gdGhlIGNvbXBsZXhpdHkgb2YgW1tsaW5rLWVpcC0xNTU5XV0gdGhpcyB2YWx1ZSBjYW4gb25seVxuICAgICAqICBiZSBjYWx1Y2xhdGVkIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCwgc25jZSB0aGUgYmFzZVxuICAgICAqICBmZWUgaXMgcHJvdG9jb2wtZW5mb3JjZWQuXG4gICAgICovXG4gICAgZ2FzUHJpY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcmljZSBwYWlkIHBlciBCTE9CIGluIGdhcy4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGJsb2JHYXNQcmljZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjcxOF1dIHRyYW5zYWN0aW9uIHR5cGUuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvL3JlYWRvbmx5IGJ5emFudGl1bSE6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogIFRoZSBzdGF0dXMgb2YgdGhpcyB0cmFuc2FjdGlvbiwgaW5kaWNhdGluZyBzdWNjZXNzIChpLmUuIGBgMWBgKSBvclxuICAgICAqICBhIHJldmVydCAoaS5lLiBgYDBgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBhdmFpbGFibGUgaW4gcG9zdC1ieXphbnRpdW0gYmxvY2tzLCBidXQgc29tZSBiYWNrZW5kcyBtYXlcbiAgICAgKiAgYmFja2ZpbGwgdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBzdGF0dXM7XG4gICAgLyoqXG4gICAgICogIFRoZSByb290IGhhc2ggb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vIHByZXNlbnQgYW5kIHdhcyBvbmx5IGluY2x1ZGVkIGluIHByZS1ieXphbnRpdW0gYmxvY2tzLCBidXRcbiAgICAgKiAgY291bGQgYmUgdXNlZCB0byB2YWxpZGF0ZSBjZXJ0YWluIHBhcnRzIG9mIHRoZSByZWNlaXB0LlxuICAgICAqL1xuICAgIHJvb3Q7XG4gICAgI2xvZ3M7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR4LCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNsb2dzID0gT2JqZWN0LmZyZWV6ZSh0eC5sb2dzLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZyhsb2csIHByb3ZpZGVyKTtcbiAgICAgICAgfSkpO1xuICAgICAgICBsZXQgZ2FzUHJpY2UgPSBCTl8wO1xuICAgICAgICBpZiAodHguZWZmZWN0aXZlR2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2FzUHJpY2UgPSB0eC5lZmZlY3RpdmVHYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eC5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBnYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICB0bzogdHgudG8sXG4gICAgICAgICAgICBmcm9tOiB0eC5mcm9tLFxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiB0eC5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICBoYXNoOiB0eC5oYXNoLFxuICAgICAgICAgICAgaW5kZXg6IHR4LmluZGV4LFxuICAgICAgICAgICAgYmxvY2tIYXNoOiB0eC5ibG9ja0hhc2gsXG4gICAgICAgICAgICBibG9ja051bWJlcjogdHguYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICBsb2dzQmxvb206IHR4LmxvZ3NCbG9vbSxcbiAgICAgICAgICAgIGdhc1VzZWQ6IHR4Lmdhc1VzZWQsXG4gICAgICAgICAgICBjdW11bGF0aXZlR2FzVXNlZDogdHguY3VtdWxhdGl2ZUdhc1VzZWQsXG4gICAgICAgICAgICBibG9iR2FzVXNlZDogdHguYmxvYkdhc1VzZWQsXG4gICAgICAgICAgICBnYXNQcmljZSxcbiAgICAgICAgICAgIGJsb2JHYXNQcmljZTogdHguYmxvYkdhc1ByaWNlLFxuICAgICAgICAgICAgdHlwZTogdHgudHlwZSxcbiAgICAgICAgICAgIC8vYnl6YW50aXVtOiB0eC5ieXphbnRpdW0sXG4gICAgICAgICAgICBzdGF0dXM6IHR4LnN0YXR1cyxcbiAgICAgICAgICAgIHJvb3Q6IHR4LnJvb3RcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbG9ncyBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgbG9ncygpIHsgcmV0dXJuIHRoaXMuI2xvZ3M7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHsgdG8sIGZyb20sIGNvbnRyYWN0QWRkcmVzcywgaGFzaCwgaW5kZXgsIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsIGxvZ3NCbG9vbSwgbG9ncywgLy9ieXphbnRpdW0sIFxuICAgICAgICBzdGF0dXMsIHJvb3QgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJUcmFuc2FjdGlvblJlY2VpcHRcIixcbiAgICAgICAgICAgIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICAvL2J5emFudGl1bSwgXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICBjdW11bGF0aXZlR2FzVXNlZDogdG9Kc29uKHRoaXMuY3VtdWxhdGl2ZUdhc1VzZWQpLFxuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiB0b0pzb24odGhpcy5nYXNQcmljZSksXG4gICAgICAgICAgICBibG9iR2FzVXNlZDogdG9Kc29uKHRoaXMuYmxvYkdhc1VzZWQpLFxuICAgICAgICAgICAgYmxvYkdhc1ByaWNlOiB0b0pzb24odGhpcy5ibG9iR2FzUHJpY2UpLFxuICAgICAgICAgICAgZ2FzVXNlZDogdG9Kc29uKHRoaXMuZ2FzVXNlZCksXG4gICAgICAgICAgICBoYXNoLCBpbmRleCwgbG9ncywgbG9nc0Jsb29tLCByb290LCBzdGF0dXMsIHRvXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5sb2dzLmxlbmd0aDsgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB0aGlzLmxvZ3NbaW5kZXgrK10sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBmZWUgZm9yIHRoaXMgdHJhbnNhY3Rpb24sIGluIHdlaS5cbiAgICAgKi9cbiAgICBnZXQgZmVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nYXNVc2VkICogdGhpcy5nYXNQcmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBibG9jayB0aGlzIHRyYW5zYWN0aW9uIG9jY3VycmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEJsb2NrKCkge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2sodGhpcy5ibG9ja0hhc2gpO1xuICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgdHJhbnNhY3Rpb24gdGhpcyB0cmFuc2FjdGlvbiBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHRoaXMuaGFzaCk7XG4gICAgICAgIGlmICh0eCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGV4ZWN1dGlvbiBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFN1cHBvcnQgZm9yIHRoaXMgZmVhdHVyZSBpcyBsaW1pdGVkLCBhcyBpdCByZXF1aXJlcyBhbiBhcmNoaXZlIG5vZGVcbiAgICAgKiAgd2l0aCB0aGUgYGBkZWJ1Z19gYCBvciBgYHRyYWNlX2BgIEFQSSBlbmFibGVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFJlc3VsdCgpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVzdWx0KHRoaXMuaGFzaCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIG51bWJlciBvZiBjb25maXJtYXRpb25zIHRoaXMgdHJhbnNhY3Rpb24gaGFzLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbmZpcm1hdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpKSAtIHRoaXMuYmxvY2tOdW1iZXIgKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgcmVtb3ZlZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVtb3ZlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgcmVvcmRlcmVkRXZlbnQob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0KCFvdGhlciB8fCBvdGhlci5pc01pbmVkKCksIFwidW5taW5lZCAnb3RoZXInIHRyYW5zY3Rpb24gY2Fubm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlb3JkZXJlZEV2ZW50KG90aGVyKVwiIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVvcmRlcmVkVHJhbnNhY3Rpb25GaWx0ZXIodGhpcywgb3RoZXIpO1xuICAgIH1cbn1cbi8qKlxuICogIEEgKipUcmFuc2FjdGlvblJlc3BvbnNlKiogaW5jbHVkZXMgYWxsIHByb3BlcnRpZXMgYWJvdXQgYSB0cmFuc2FjdGlvblxuICogIHRoYXQgd2FzIHNlbnQgdG8gdGhlIG5ldHdvcmssIHdoaWNoIG1heSBvciBtYXkgbm90IGJlIGluY2x1ZGVkIGluIGFcbiAqICBibG9jay5cbiAqXG4gKiAgVGhlIFtbVHJhbnNhY3Rpb25SZXNwb25zZS1pc01pbmVkXV0gY2FuIGJlIHVzZWQgdG8gY2hlY2sgaWYgdGhlXG4gKiAgdHJhbnNhY3Rpb24gaGFzIGJlZW4gbWluZWQgYXMgd2VsbCBhcyB0eXBlIGd1YXJkIHRoYXQgdGhlIG90aGVyd2lzZVxuICogIHBvc3NpYmx5IGBgbnVsbGBgIHByb3BlcnRpZXMgYXJlIGRlZmluZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvblJlc3BvbnNlIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIHRoaXMgaXMgY29ubmVjdGVkIHRvLCB3aGljaCB3aWxsIGluZmx1ZW5jZSBob3cgaXRzXG4gICAgICogIG1ldGhvZHMgd2lsbCByZXNvbHZlIGl0cyBhc3luYyBpbnNwZWN0aW9uIG1ldGhvZHMuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgb2YgdGhlIGJsb2NrIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBgYG51bGxgYCBmb3IgcGVuZGluZyB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9ja0hhc2ggb2YgdGhlIGJsb2NrIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBgYG51bGxgYCBmb3IgcGVuZGluZyB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgYmxvY2tIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggd2l0aGluIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gcmVzaWRlcyBhdC5cbiAgICAgKi9cbiAgICBpbmRleDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjcxOF1dIHRyYW5zYWN0aW9uIGVudmVsb3BlIHR5cGUuIFRoaXMgaXNcbiAgICAgKiAgYGAwYGAgZm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMgdHlwZXMuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJlY2VpdmVyIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgSWYgYGBudWxsYGAsIHRoZW4gdGhlIHRyYW5zYWN0aW9uIGlzIGFuIGluaXRjb2RlIHRyYW5zYWN0aW9uLlxuICAgICAqICBUaGlzIG1lYW5zIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIHRoZSBbW2RhdGFdXSB3aWxsIGJlIGRlcGxveWVkXG4gICAgICogIGFzIGEgbmV3IGNvbnRyYWN0IG9uIGNoYWluIChhc3N1bWluZyBpdCBkb2VzIG5vdCByZXZlcnQpIGFuZCB0aGVcbiAgICAgKiAgYWRkcmVzcyBtYXkgYmUgY29tcHV0ZWQgdXNpbmcgW1tnZXRDcmVhdGVBZGRyZXNzXV0uXG4gICAgICovXG4gICAgdG87XG4gICAgLyoqXG4gICAgICogIFRoZSBzZW5kZXIgb2YgdGhpcyB0cmFuc2FjdGlvbi4gSXQgaXMgaW1wbGljaXRseSBjb21wdXRlZFxuICAgICAqICBmcm9tIHRoZSB0cmFuc2FjdGlvbiBwcmUtaW1hZ2UgaGFzaCAoYXMgdGhlIGRpZ2VzdCkgYW5kIHRoZVxuICAgICAqICBbW3NpZ25hdHVyZV1dIHVzaW5nIGVjcmVjb3Zlci5cbiAgICAgKi9cbiAgICBmcm9tO1xuICAgIC8qKlxuICAgICAqICBUaGUgbm9uY2UsIHdoaWNoIGlzIHVzZWQgdG8gcHJldmVudCByZXBsYXkgYXR0YWNrcyBhbmQgb2ZmZXJcbiAgICAgKiAgYSBtZXRob2QgdG8gZW5zdXJlIHRyYW5zYWN0aW9ucyBmcm9tIGEgZ2l2ZW4gc2VuZGVyIGFyZSBleHBsaWNpdGx5XG4gICAgICogIG9yZGVyZWQuXG4gICAgICpcbiAgICAgKiAgV2hlbiBzZW5kaW5nIGEgdHJhbnNhY3Rpb24sIHRoaXMgbXVzdCBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICogIHRyYW5zYWN0aW9ucyBldmVyIHNlbnQgYnkgW1tmcm9tXV0uXG4gICAgICovXG4gICAgbm9uY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIHVuaXRzIG9mIGdhcyB0aGlzIHRyYW5zYWN0aW9uIGNhbiBjb25zdW1lLiBJZiBleGVjdXRpb25cbiAgICAgKiAgZXhjZWVkcyB0aGlzLCB0aGUgZW50cmllcyB0cmFuc2FjdGlvbiBpcyByZXZlcnRlZCBhbmQgdGhlIHNlbmRlclxuICAgICAqICBpcyBjaGFyZ2VkIGZvciB0aGUgZnVsbCBhbW91bnQsIGRlc3BpdGUgbm90IHN0YXRlIGNoYW5nZXMgYmVpbmcgbWFkZS5cbiAgICAgKi9cbiAgICBnYXNMaW1pdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBwcmljZSBjYW4gaGF2ZSB2YXJpb3VzIHZhbHVlcywgZGVwZW5kaW5nIG9uIHRoZSBuZXR3b3JrLlxuICAgICAqXG4gICAgICogIEluIG1vZGVybiBuZXR3b3JrcywgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBpbmNsdWRlZCB0aGlzIGlzXG4gICAgICogIHRoZSAvL2VmZmVjdGl2ZSBnYXMgcHJpY2UvLyAodGhlIGZlZSBwZXIgZ2FzIHRoYXQgd2FzIGFjdHVhbGx5XG4gICAgICogIGNoYXJnZWQpLCB3aGlsZSBmb3IgdHJhbnNhY3Rpb25zIHRoYXQgaGF2ZSBub3QgYmVlbiBpbmNsdWRlZCB5ZXRcbiAgICAgKiAgaXMgdGhlIFtbbWF4RmVlUGVyR2FzXV0uXG4gICAgICpcbiAgICAgKiAgRm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMsIG9yIHRyYW5zYWN0aW9ucyBvbiBsZWdhY3kgbmV0d29ya3MsIHRoaXNcbiAgICAgKiAgaXMgdGhlIGZlZSB0aGF0IHdpbGwgYmUgY2hhcmdlZCBwZXIgdW5pdCBvZiBnYXMgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogIGNvbnN1bWVzLlxuICAgICAqL1xuICAgIGdhc1ByaWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBwcmlvcml0eSBmZWUgKHBlciB1bml0IG9mIGdhcykgdG8gYWxsb3cgYVxuICAgICAqICB2YWxpZGF0b3IgdG8gY2hhcmdlIHRoZSBzZW5kZXIuIFRoaXMgaXMgaW5jbHVzaXZlIG9mIHRoZVxuICAgICAqICBbW21heEZlZUZlZVBlckdhc11dLlxuICAgICAqL1xuICAgIG1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBmZWUgKHBlciB1bml0IG9mIGdhcykgdG8gYWxsb3cgdGhpcyB0cmFuc2FjdGlvblxuICAgICAqICB0byBjaGFyZ2UgdGhlIHNlbmRlci5cbiAgICAgKi9cbiAgICBtYXhGZWVQZXJHYXM7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTQ4NDRdXSBtYXggZmVlIHBlciBCTE9iIGdhcy5cbiAgICAgKi9cbiAgICBtYXhGZWVQZXJCbG9iR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGF0YS5cbiAgICAgKi9cbiAgICBkYXRhO1xuICAgIC8qKlxuICAgICAqICBUaGUgdmFsdWUsIGluIHdlaS4gVXNlIFtbZm9ybWF0RXRoZXJdXSB0byBmb3JtYXQgdGhpcyB2YWx1ZVxuICAgICAqICBhcyBldGhlci5cbiAgICAgKi9cbiAgICB2YWx1ZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluIElELlxuICAgICAqL1xuICAgIGNoYWluSWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgW1tsaW5rLWVpcC0yOTMwXV0gYWNjZXNzIGxpc3QgZm9yIHRyYW5zYWN0aW9uIHR5cGVzIHRoYXRcbiAgICAgKiAgc3VwcG9ydCBpdCwgb3RoZXJ3aXNlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGFjY2Vzc0xpc3Q7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTQ4NDRdXSBCTE9iIHZlcnNpb25lZCBoYXNoZXMuXG4gICAgICovXG4gICAgYmxvYlZlcnNpb25lZEhhc2hlcztcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtNzcwMl1dIGF1dGhvcml6YXRpb25zIChpZiBhbnkpLlxuICAgICAqL1xuICAgIGF1dGhvcml6YXRpb25MaXN0O1xuICAgICNzdGFydEJsb2NrO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eCwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLmJsb2NrTnVtYmVyID0gKHR4LmJsb2NrTnVtYmVyICE9IG51bGwpID8gdHguYmxvY2tOdW1iZXIgOiBudWxsO1xuICAgICAgICB0aGlzLmJsb2NrSGFzaCA9ICh0eC5ibG9ja0hhc2ggIT0gbnVsbCkgPyB0eC5ibG9ja0hhc2ggOiBudWxsO1xuICAgICAgICB0aGlzLmhhc2ggPSB0eC5oYXNoO1xuICAgICAgICB0aGlzLmluZGV4ID0gdHguaW5kZXg7XG4gICAgICAgIHRoaXMudHlwZSA9IHR4LnR5cGU7XG4gICAgICAgIHRoaXMuZnJvbSA9IHR4LmZyb207XG4gICAgICAgIHRoaXMudG8gPSB0eC50byB8fCBudWxsO1xuICAgICAgICB0aGlzLmdhc0xpbWl0ID0gdHguZ2FzTGltaXQ7XG4gICAgICAgIHRoaXMubm9uY2UgPSB0eC5ub25jZTtcbiAgICAgICAgdGhpcy5kYXRhID0gdHguZGF0YTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHR4LnZhbHVlO1xuICAgICAgICB0aGlzLmdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XG4gICAgICAgIHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkgPyB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA6IG51bGw7XG4gICAgICAgIHRoaXMubWF4RmVlUGVyR2FzID0gKHR4Lm1heEZlZVBlckdhcyAhPSBudWxsKSA/IHR4Lm1heEZlZVBlckdhcyA6IG51bGw7XG4gICAgICAgIHRoaXMubWF4RmVlUGVyQmxvYkdhcyA9ICh0eC5tYXhGZWVQZXJCbG9iR2FzICE9IG51bGwpID8gdHgubWF4RmVlUGVyQmxvYkdhcyA6IG51bGw7XG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IHR4LmNoYWluSWQ7XG4gICAgICAgIHRoaXMuc2lnbmF0dXJlID0gdHguc2lnbmF0dXJlO1xuICAgICAgICB0aGlzLmFjY2Vzc0xpc3QgPSAodHguYWNjZXNzTGlzdCAhPSBudWxsKSA/IHR4LmFjY2Vzc0xpc3QgOiBudWxsO1xuICAgICAgICB0aGlzLmJsb2JWZXJzaW9uZWRIYXNoZXMgPSAodHguYmxvYlZlcnNpb25lZEhhc2hlcyAhPSBudWxsKSA/IHR4LmJsb2JWZXJzaW9uZWRIYXNoZXMgOiBudWxsO1xuICAgICAgICB0aGlzLmF1dGhvcml6YXRpb25MaXN0ID0gKHR4LmF1dGhvcml6YXRpb25MaXN0ICE9IG51bGwpID8gdHguYXV0aG9yaXphdGlvbkxpc3QgOiBudWxsO1xuICAgICAgICB0aGlzLiNzdGFydEJsb2NrID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IGJsb2NrTnVtYmVyLCBibG9ja0hhc2gsIGluZGV4LCBoYXNoLCB0eXBlLCB0bywgZnJvbSwgbm9uY2UsIGRhdGEsIHNpZ25hdHVyZSwgYWNjZXNzTGlzdCwgYmxvYlZlcnNpb25lZEhhc2hlcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcIlRyYW5zYWN0aW9uUmVzcG9uc2VcIixcbiAgICAgICAgICAgIGFjY2Vzc0xpc3QsIGJsb2NrTnVtYmVyLCBibG9ja0hhc2gsXG4gICAgICAgICAgICBibG9iVmVyc2lvbmVkSGFzaGVzLFxuICAgICAgICAgICAgY2hhaW5JZDogdG9Kc29uKHRoaXMuY2hhaW5JZCksXG4gICAgICAgICAgICBkYXRhLCBmcm9tLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IHRvSnNvbih0aGlzLmdhc0xpbWl0KSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiB0b0pzb24odGhpcy5nYXNQcmljZSksXG4gICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0b0pzb24odGhpcy5tYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRvSnNvbih0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heEZlZVBlckJsb2JHYXM6IHRvSnNvbih0aGlzLm1heEZlZVBlckJsb2JHYXMpLFxuICAgICAgICAgICAgbm9uY2UsIHNpZ25hdHVyZSwgdG8sIGluZGV4LCB0eXBlLFxuICAgICAgICAgICAgdmFsdWU6IHRvSnNvbih0aGlzLnZhbHVlKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBCbG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIGluY2x1ZGVkIHlldC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgbGV0IGJsb2NrTnVtYmVyID0gdGhpcy5ibG9ja051bWJlcjtcbiAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHR4KSB7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSB0eC5ibG9ja051bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKGJsb2NrTnVtYmVyKTtcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhpcyB0cmFuc2FjdGlvbiBiZWluZyByZS1yZXF1ZXN0ZWQgZnJvbSB0aGVcbiAgICAgKiAgcHJvdmlkZXIuIFRoaXMgY2FuIGJlIHVzZWQgaWYgeW91IGhhdmUgYW4gdW5taW5lZCB0cmFuc2FjdGlvblxuICAgICAqICBhbmQgd2lzaCB0byBnZXQgYW4gdXAtdG8tZGF0ZSBwb3B1bGF0ZWQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHRoaXMuaGFzaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlIHRvIHRoZSBudW1iZXIgb2YgY29uZmlybWF0aW9ucyB0aGlzIHRyYW5zYWN0aW9uIGhhcy5cbiAgICAgKi9cbiAgICBhc3luYyBjb25maXJtYXRpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5ibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB7IHR4LCBibG9ja051bWJlciB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIHR4OiB0aGlzLmdldFRyYW5zYWN0aW9uKCksXG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBOb3QgbWluZWQgeWV0Li4uXG4gICAgICAgICAgICBpZiAodHggPT0gbnVsbCB8fCB0eC5ibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXIgLSB0eC5ibG9ja051bWJlciArIDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XG4gICAgICAgIHJldHVybiBibG9ja051bWJlciAtIHRoaXMuYmxvY2tOdW1iZXIgKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgb25jZSB0aGlzIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkIGFuZCBoYXNcbiAgICAgKiAgJSVjb25maXJtcyUlIGJsb2NrcyBpbmNsdWRpbmcgaXQgKGRlZmF1bHQ6IGBgMWBgKSB3aXRoIGFuXG4gICAgICogIG9wdGlvbmFsICUldGltZW91dCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIHJlc29sdmUgdG8gYGBudWxsYGAgb25seSBpZiAlJWNvbmZpcm1zJSUgaXMgYGAwYGBcbiAgICAgKiAgYW5kIHRoZSB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gbWluZWQsIG90aGVyd2lzZSB0aGlzIHdpbGxcbiAgICAgKiAgd2FpdCB1bnRpbCBlbm91Z2ggY29uZmlybWF0aW9ucyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0KF9jb25maXJtcywgX3RpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgY29uZmlybXMgPSAoX2NvbmZpcm1zID09IG51bGwpID8gMSA6IF9jb25maXJtcztcbiAgICAgICAgY29uc3QgdGltZW91dCA9IChfdGltZW91dCA9PSBudWxsKSA/IDAgOiBfdGltZW91dDtcbiAgICAgICAgbGV0IHN0YXJ0QmxvY2sgPSB0aGlzLiNzdGFydEJsb2NrO1xuICAgICAgICBsZXQgbmV4dFNjYW4gPSAtMTtcbiAgICAgICAgbGV0IHN0b3BTY2FubmluZyA9IChzdGFydEJsb2NrID09PSAtMSkgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIGNvbnN0IGNoZWNrUmVwbGFjZW1lbnQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24gY291bnQgZm9yIHRoaXMgc2VuZGVyXG4gICAgICAgICAgICBpZiAoc3RvcFNjYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGJsb2NrTnVtYmVyLCBub25jZSB9ID0gYXdhaXQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCksXG4gICAgICAgICAgICAgICAgbm9uY2U6IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLmZyb20pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE5vIHRyYW5zYWN0aW9uIG9yIG91ciBub25jZSBoYXMgbm90IGJlZW4gbWluZWQgeWV0OyBidXQgd2VcbiAgICAgICAgICAgIC8vIGNhbiBzdGFydCBzY2FubmluZyBsYXRlciB3aGVuIHdlIGRvIHN0YXJ0XG4gICAgICAgICAgICBpZiAobm9uY2UgPCB0aGlzLm5vbmNlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRCbG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHdlcmUgbWluZWQ7IG5vIHJlcGxhY2VtZW50XG4gICAgICAgICAgICBpZiAoc3RvcFNjYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtaW5lZCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChtaW5lZCAmJiBtaW5lZC5ibG9ja051bWJlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2Ugd2VyZSByZXBsYWNlZDsgc3RhcnQgc2Nhbm5pbmcgZm9yIHRoYXQgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIC8vIFN0YXJ0aW5nIHRvIHNjYW47IGxvb2sgYmFjayBhIGZldyBleHRyYSBibG9ja3MgZm9yIHNhZmV0eVxuICAgICAgICAgICAgaWYgKG5leHRTY2FuID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG5leHRTY2FuID0gc3RhcnRCbG9jayAtIDM7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRTY2FuIDwgdGhpcy4jc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0U2NhbiA9IHRoaXMuI3N0YXJ0QmxvY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKG5leHRTY2FuIDw9IGJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBuZXh0IGJsb2NrIHRvIHNjYW5cbiAgICAgICAgICAgICAgICBpZiAoc3RvcFNjYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2sobmV4dFNjYW4sIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW47IGJ1dCB3ZSdsbCB0cnkgYWdhaW4gc2hvcnRseVxuICAgICAgICAgICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSBtaW5lZDsgbm8gcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGhhc2ggb2YgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc2ggPT09IHRoaXMuaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRoYXQgcmVwbGFjZWQgdXNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgYmxvY2suZ2V0VHJhbnNhY3Rpb24oaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eC5mcm9tID09PSB0aGlzLmZyb20gJiYgdHgubm9uY2UgPT09IHRoaXMubm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcmVjZWlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4Lmhhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbjsgYnV0IHdlJ2xsIHRyeSBhZ2FpbiBzaG9ydGx5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2lsbCByZXRyeSB0aGlzIG9uIHRoZSBuZXh0IGJsb2NrICh0aGlzIGNhc2UgY291bGQgYmUgb3B0aW1pemVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChibG9ja051bWJlciAtIHJlY2VpcHQuYmxvY2tOdW1iZXIgKyAxKSA8IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlYXNvbiB3ZSB3ZXJlIHJlcGxhY2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVhc29uID0gXCJyZXBsYWNlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmRhdGEgPT09IHRoaXMuZGF0YSAmJiB0eC50byA9PT0gdGhpcy50byAmJiB0eC52YWx1ZSA9PT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwicmVwcmljZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LmRhdGEgPT09IFwiMHhcIiAmJiB0eC5mcm9tID09PSB0eC50byAmJiB0eC52YWx1ZSA9PT0gQk5fMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwiY2FuY2VsbGVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwidHJhbnNhY3Rpb24gd2FzIHJlcGxhY2VkXCIsIFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZDogKHJlYXNvbiA9PT0gXCJyZXBsYWNlZFwiIHx8IHJlYXNvbiA9PT0gXCJjYW5jZWxsZWRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50OiB0eC5yZXBsYWNlYWJsZVRyYW5zYWN0aW9uKHN0YXJ0QmxvY2spLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IHR4Lmhhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dFNjYW4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2hlY2tSZWNlaXB0ID0gKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwgfHwgcmVjZWlwdC5zdGF0dXMgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJ0cmFuc2FjdGlvbiBleGVjdXRpb24gcmV2ZXJ0ZWRcIiwgXCJDQUxMX0VYQ0VQVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsIHJlYXNvbjogbnVsbCwgaW52b2NhdGlvbjogbnVsbCwgcmV2ZXJ0OiBudWxsLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHRvOiByZWNlaXB0LnRvLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiByZWNlaXB0LmZyb20sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IFwiXCIgLy8gQFRPRE86IGluIHY3LCBzcGxpdCBvdXQgc2VuZFRyYW5zYWN0aW9uIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICB9LCByZWNlaXB0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMuaGFzaCk7XG4gICAgICAgIGlmIChjb25maXJtcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrUmVjZWlwdChyZWNlaXB0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjZWlwdCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpcm1zID09PSAxIHx8IChhd2FpdCByZWNlaXB0LmNvbmZpcm1hdGlvbnMoKSkgPj0gY29uZmlybXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tSZWNlaXB0KHJlY2VpcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGEgcmVwbGFjZW1lbnQ7IHRocm93cyBpZiBhIHJlcGxhY2VtZW50IHdhcyBmb3VuZFxuICAgICAgICAgICAgYXdhaXQgY2hlY2tSZXBsYWNlbWVudCgpO1xuICAgICAgICAgICAgLy8gQWxsb3cgbnVsbCBvbmx5IHdoZW4gdGhlIGNvbmZpcm1zIGlzIDBcbiAgICAgICAgICAgIGlmIChjb25maXJtcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhaXRlciA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIExpc3Qgb2YgdGhpbmdzIHRvIGNhbmNlbCB3aGVuIHdlIGhhdmUgYSByZXN1bHQgKG9uZSB3YXkgb3IgdGhlIG90aGVyKVxuICAgICAgICAgICAgY29uc3QgY2FuY2VsbGVycyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsID0gKCkgPT4geyBjYW5jZWxsZXJzLmZvckVhY2goKGMpID0+IGMoKSk7IH07XG4gICAgICAgICAgICAvLyBPbiBjYW5jZWwsIHN0b3Agc2Nhbm5pbmcgZm9yIHJlcGxhY2VtZW50c1xuICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgc3RvcFNjYW5uaW5nID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgICAvLyBTZXQgdXAgYW55IHRpbWVvdXQgcmVxdWVzdGVkXG4gICAgICAgICAgICBpZiAodGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG1ha2VFcnJvcihcIndhaXQgZm9yIHRyYW5zYWN0aW9uIHRpbWVvdXRcIiwgXCJUSU1FT1VUXCIpKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBjYW5jZWxsZXJzLnB1c2goKCkgPT4geyBjbGVhclRpbWVvdXQodGltZXIpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR4TGlzdGVuZXIgPSBhc3luYyAocmVjZWlwdCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIERvbmU7IHJldHVybiBpdCFcbiAgICAgICAgICAgICAgICBpZiAoKGF3YWl0IHJlY2VpcHQuY29uZmlybWF0aW9ucygpKSA+PSBjb25maXJtcykge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY2hlY2tSZWNlaXB0KHJlY2VpcHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgdGhpcy5wcm92aWRlci5vZmYodGhpcy5oYXNoLCB0eExpc3RlbmVyKTsgfSk7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uKHRoaXMuaGFzaCwgdHhMaXN0ZW5lcik7XG4gICAgICAgICAgICAvLyBXZSBzdXBwb3J0IHJlcGxhY2VtZW50IGRldGVjdGlvbjsgc3RhcnQgY2hlY2tpbmdcbiAgICAgICAgICAgIGlmIChzdGFydEJsb2NrID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlTGlzdGVuZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgYSByZXBsYWNlbWVudDsgdGhpcyB0aHJvd3Mgb25seSBpZiBvbmUgaXMgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNoZWNrUmVwbGFjZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHdlcmUgcmVwbGFjZWQgKHdpdGggZW5vdWdoIGNvbmZpcm1zKTsgcmUtdGhyb3cgdGhlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlcnJvciwgXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2NoZXVkbGUgYSBjaGVjayBvbiB0aGUgbmV4dCBibG9ja1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgdGhpcy5wcm92aWRlci5vZmYoXCJibG9ja1wiLCByZXBsYWNlTGlzdGVuZXIpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uY2UoXCJibG9ja1wiLCByZXBsYWNlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHdhaXRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgaWYgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBpbmNsdWRlZC5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGVmZmVjdGl2ZSBvbmx5IGFzIG9mIHRoZSB0aW1lIHRoZSBUcmFuc2FjdGlvblJlc3BvbnNlXG4gICAgICogIHdhcyBpbnN0YW50aWF0ZWQuIFRvIGdldCB1cC10by1kYXRlIGluZm9ybWF0aW9uLCB1c2VcbiAgICAgKiAgW1tnZXRUcmFuc2FjdGlvbl1dLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGhhdmVcbiAgICAgKiAgbm9uLW51bGwgcHJvcGVydHkgdmFsdWVzIGZvciBwcm9wZXJ0aWVzIHRoYXQgYXJlIG51bGwgZm9yXG4gICAgICogIHVubWluZWQgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGlzTWluZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5ibG9ja0hhc2ggIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGEgbGVnYWN5IChpLmUuIGBgdHlwZSA9PSAwYGApXG4gICAgICogIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGhhdmVcbiAgICAgKiAgdGhlIGBgbnVsbGBgLW5lc3MgZm9yIGhhcmRmb3JrLXNwZWNpZmljIHByb3BlcnRpZXMgc2V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpc0xlZ2FjeSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIEJlcmxpbiAoaS5lLiBgYHR5cGUgPT0gMWBgKVxuICAgICAqICB0cmFuc2FjdGlvbi4gU2VlIFtbbGluay1laXAtMjA3MF1dLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGhhdmVcbiAgICAgKiAgdGhlIGBgbnVsbGBgLW5lc3MgZm9yIGhhcmRmb3JrLXNwZWNpZmljIHByb3BlcnRpZXMgc2V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpc0JlcmxpbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIExvbmRvbiAoaS5lLiBgYHR5cGUgPT0gMmBgKVxuICAgICAqICB0cmFuc2FjdGlvbi4gU2VlIFtbbGluay1laXAtMTU1OV1dLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGhhdmVcbiAgICAgKiAgdGhlIGBgbnVsbGBgLW5lc3MgZm9yIGhhcmRmb3JrLXNwZWNpZmljIHByb3BlcnRpZXMgc2V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpc0xvbmRvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIGh0ZSB0cmFuc2FjdGlvbiBpcyBhIENhbmN1biAoaS5lLiBgYHR5cGUgPT0gM2BgKVxuICAgICAqICB0cmFuc2FjdGlvbi4gU2VlIFtbbGluay1laXAtNDg0NF1dLlxuICAgICAqL1xuICAgIGlzQ2FuY3VuKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgZmlsdGVyIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGxpc3RlbiBmb3Igb3JwaGFuIGV2ZW50c1xuICAgICAqICB0aGF0IGV2aWN0IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgcmVtb3ZlZEV2ZW50KCkge1xuICAgICAgICBhc3NlcnQodGhpcy5pc01pbmVkKCksIFwidW5taW5lZCB0cmFuc2FjdGlvbiBjYW5vdCBiZSBvcnBoYW5lZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZW1vdmVFdmVudCgpXCIgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW1vdmVkVHJhbnNhY3Rpb25GaWx0ZXIodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgZmlsdGVyIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGxpc3RlbiBmb3Igb3JwaGFuIGV2ZW50c1xuICAgICAqICB0aGF0IHJlLW9yZGVyIHRoaXMgZXZlbnQgYWdhaW5zdCAlJW90aGVyJSUuXG4gICAgICovXG4gICAgcmVvcmRlcmVkRXZlbnQob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0KHRoaXMuaXNNaW5lZCgpLCBcInVubWluZWQgdHJhbnNhY3Rpb24gY2Fub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVtb3ZlRXZlbnQoKVwiIH0pO1xuICAgICAgICBhc3NlcnQoIW90aGVyIHx8IG90aGVyLmlzTWluZWQoKSwgXCJ1bm1pbmVkICdvdGhlcicgdHJhbnNhY3Rpb24gY2Fub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVtb3ZlRXZlbnQoKVwiIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVvcmRlcmVkVHJhbnNhY3Rpb25GaWx0ZXIodGhpcywgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlIGluc3RhbmNlIHdoaWNoIGhhcyB0aGUgYWJpbGl0eSB0b1xuICAgICAqICBkZXRlY3QgKGFuZCB0aHJvdyBhbiBlcnJvcikgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIHJlcGxhY2VkLCB3aGljaFxuICAgICAqICB3aWxsIGJlZ2luIHNjYW5uaW5nIGF0ICUlc3RhcnRCbG9jayUlLlxuICAgICAqXG4gICAgICogIFRoaXMgc2hvdWxkIGdlbmVyYWxseSBub3QgYmUgdXNlZCBieSBkZXZlbG9wZXJzIGFuZCBpcyBpbnRlbmRlZFxuICAgICAqICBwcmltYXJpbHkgZm9yIGludGVybmFsIHVzZS4gU2V0dGluZyBhbiBpbmNvcnJlY3QgJSVzdGFydEJsb2NrJSUgY2FuXG4gICAgICogIGhhdmUgZGV2YXN0YXRpbmcgcGVyZm9ybWFuY2UgY29uc2VxdWVuY2VzIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG4gICAgICovXG4gICAgcmVwbGFjZWFibGVUcmFuc2FjdGlvbihzdGFydEJsb2NrKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIoc3RhcnRCbG9jaykgJiYgc3RhcnRCbG9jayA+PSAwLCBcImludmFsaWQgc3RhcnRCbG9ja1wiLCBcInN0YXJ0QmxvY2tcIiwgc3RhcnRCbG9jayk7XG4gICAgICAgIGNvbnN0IHR4ID0gbmV3IFRyYW5zYWN0aW9uUmVzcG9uc2UodGhpcywgdGhpcy5wcm92aWRlcik7XG4gICAgICAgIHR4LiNzdGFydEJsb2NrID0gc3RhcnRCbG9jaztcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZU9ycGhhbmVkQmxvY2tGaWx0ZXIoYmxvY2spIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC1ibG9ja1wiLCBoYXNoOiBibG9jay5oYXNoLCBudW1iZXI6IGJsb2NrLm51bWJlciB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVvcmRlcmVkVHJhbnNhY3Rpb25GaWx0ZXIodHgsIG90aGVyKSB7XG4gICAgcmV0dXJuIHsgb3JwaGFuOiBcInJlb3JkZXItdHJhbnNhY3Rpb25cIiwgdHgsIG90aGVyIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZW1vdmVkVHJhbnNhY3Rpb25GaWx0ZXIodHgpIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC10cmFuc2FjdGlvblwiLCB0eCB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVtb3ZlZExvZ0ZpbHRlcihsb2cpIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC1sb2dcIiwgbG9nOiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGxvZy50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICBibG9ja0hhc2g6IGxvZy5ibG9ja0hhc2gsXG4gICAgICAgICAgICBibG9ja051bWJlcjogbG9nLmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgYWRkcmVzczogbG9nLmFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgIHRvcGljczogT2JqZWN0LmZyZWV6ZShsb2cudG9waWNzLnNsaWNlKCkpLFxuICAgICAgICAgICAgaW5kZXg6IGxvZy5pbmRleFxuICAgICAgICB9IH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydGllcyIsImdldEJpZ0ludCIsImdldE51bWJlciIsImhleGxpZnkiLCJpc0J5dGVzTGlrZSIsInJlc29sdmVQcm9wZXJ0aWVzIiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJpc0Vycm9yIiwibWFrZUVycm9yIiwiYWNjZXNzTGlzdGlmeSIsIkJOXzAiLCJCaWdJbnQiLCJnZXRWYWx1ZSIsInZhbHVlIiwidG9Kc29uIiwidG9TdHJpbmciLCJGZWVEYXRhIiwiY29uc3RydWN0b3IiLCJnYXNQcmljZSIsIm1heEZlZVBlckdhcyIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwidG9KU09OIiwiX3R5cGUiLCJjb3B5UmVxdWVzdCIsInJlcSIsInJlc3VsdCIsInRvIiwiZnJvbSIsImRhdGEiLCJiaWdJbnRLZXlzIiwic3BsaXQiLCJrZXkiLCJudW1iZXJLZXlzIiwiYWNjZXNzTGlzdCIsImF1dGhvcml6YXRpb25MaXN0Iiwic2xpY2UiLCJibG9ja1RhZyIsImVuYWJsZUNjaXBSZWFkIiwiY3VzdG9tRGF0YSIsImJsb2JWZXJzaW9uZWRIYXNoZXMiLCJremciLCJibG9icyIsIm1hcCIsImIiLCJPYmplY3QiLCJhc3NpZ24iLCJCbG9jayIsInRyYW5zYWN0aW9ucyIsImJsb2NrIiwicHJvdmlkZXIiLCJ0eCIsIlRyYW5zYWN0aW9uUmVzcG9uc2UiLCJoYXNoIiwibnVtYmVyIiwidGltZXN0YW1wIiwicGFyZW50SGFzaCIsInBhcmVudEJlYWNvbkJsb2NrUm9vdCIsIm5vbmNlIiwiZGlmZmljdWx0eSIsImdhc0xpbWl0IiwiZ2FzVXNlZCIsImJsb2JHYXNVc2VkIiwiZXhjZXNzQmxvYkdhcyIsIm1pbmVyIiwicHJldlJhbmRhbyIsImV4dHJhRGF0YSIsImJhc2VGZWVQZXJHYXMiLCJzdGF0ZVJvb3QiLCJyZWNlaXB0c1Jvb3QiLCJwcmVmZXRjaGVkVHJhbnNhY3Rpb25zIiwidHhzIiwibGVuZ3RoIiwib3BlcmF0aW9uIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJpbmRleCIsIm5leHQiLCJkb25lIiwidW5kZWZpbmVkIiwiZGF0ZSIsIkRhdGUiLCJnZXRUcmFuc2FjdGlvbiIsImluZGV4T3JIYXNoIiwidG9Mb3dlckNhc2UiLCJ2IiwiRXJyb3IiLCJnZXRQcmVmZXRjaGVkVHJhbnNhY3Rpb24iLCJpc01pbmVkIiwiaXNMb25kb24iLCJvcnBoYW5lZEV2ZW50IiwiY3JlYXRlT3JwaGFuZWRCbG9ja0ZpbHRlciIsIkxvZyIsImxvZyIsInRvcGljcyIsImZyZWV6ZSIsInRyYW5zYWN0aW9uSGFzaCIsImJsb2NrSGFzaCIsImJsb2NrTnVtYmVyIiwicmVtb3ZlZCIsImFkZHJlc3MiLCJ0cmFuc2FjdGlvbkluZGV4IiwiZ2V0QmxvY2siLCJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLCJyZWNlaXB0IiwicmVtb3ZlZEV2ZW50IiwiY3JlYXRlUmVtb3ZlZExvZ0ZpbHRlciIsIlRyYW5zYWN0aW9uUmVjZWlwdCIsImxvZ3MiLCJlZmZlY3RpdmVHYXNQcmljZSIsImNvbnRyYWN0QWRkcmVzcyIsImxvZ3NCbG9vbSIsImN1bXVsYXRpdmVHYXNVc2VkIiwiYmxvYkdhc1ByaWNlIiwidHlwZSIsInN0YXR1cyIsInJvb3QiLCJmZWUiLCJnZXRSZXN1bHQiLCJnZXRUcmFuc2FjdGlvblJlc3VsdCIsImNvbmZpcm1hdGlvbnMiLCJnZXRCbG9ja051bWJlciIsImNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlciIsInJlb3JkZXJlZEV2ZW50Iiwib3RoZXIiLCJjcmVhdGVSZW9yZGVyZWRUcmFuc2FjdGlvbkZpbHRlciIsInN0YXJ0QmxvY2siLCJtYXhGZWVQZXJCbG9iR2FzIiwiY2hhaW5JZCIsInNpZ25hdHVyZSIsIndhaXQiLCJfY29uZmlybXMiLCJfdGltZW91dCIsImNvbmZpcm1zIiwidGltZW91dCIsIm5leHRTY2FuIiwic3RvcFNjYW5uaW5nIiwiY2hlY2tSZXBsYWNlbWVudCIsImdldFRyYW5zYWN0aW9uQ291bnQiLCJtaW5lZCIsImkiLCJyZWFzb24iLCJjYW5jZWxsZWQiLCJyZXBsYWNlbWVudCIsInJlcGxhY2VhYmxlVHJhbnNhY3Rpb24iLCJjaGVja1JlY2VpcHQiLCJhY3Rpb24iLCJpbnZvY2F0aW9uIiwicmV2ZXJ0IiwidHJhbnNhY3Rpb24iLCJ3YWl0ZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNhbmNlbGxlcnMiLCJjYW5jZWwiLCJmb3JFYWNoIiwiYyIsInB1c2giLCJ0aW1lciIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJ0eExpc3RlbmVyIiwiZXJyb3IiLCJvZmYiLCJvbiIsInJlcGxhY2VMaXN0ZW5lciIsIm9uY2UiLCJpc0xlZ2FjeSIsImlzQmVybGluIiwiaXNDYW5jdW4iLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJvcnBoYW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/providers/provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.esm/transaction/accesslist.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   accessListify: () => (/* binding */ accessListify)\n/* harmony export */ });\n/* harmony import */ var _address_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../address/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/address/address.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/index.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n\n\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: (0,_address_index_js__WEBPACK_IMPORTED_MODULE_0__.getAddress)(addr),\n        storageKeys: storageKeys.map((storageKey, index)=>{\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)((0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.isHexString)(storageKey, 32), \"invalid slot\", `storageKeys[${index}]`, storageKey);\n            return storageKey.toLowerCase();\n        })\n    };\n}\n/**\n *  Returns a [[AccessList]] from any ethers-supported access-list structure.\n */ function accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index)=>{\n            if (Array.isArray(set)) {\n                (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(set.length === 2, \"invalid slot set\", `value[${index}]`, set);\n                return accessSetify(set[0], set[1]);\n            }\n            (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(set != null && typeof set === \"object\", \"invalid address-slot set\", \"value\", value);\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.assertArgument)(value != null && typeof value === \"object\", \"invalid access list\", \"value\", value);\n    const result = Object.keys(value).map((addr)=>{\n        const storageKeys = value[addr].reduce((accum, storageKey)=>{\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b)=>a.address.localeCompare(b.address));\n    return result;\n} //# sourceMappingURL=accesslist.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdHJhbnNhY3Rpb24vYWNjZXNzbGlzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlEO0FBQ2U7QUFDaEUsU0FBU0csYUFBYUMsSUFBSSxFQUFFQyxXQUFXO0lBQ25DLE9BQU87UUFDSEMsU0FBU04sNkRBQVVBLENBQUNJO1FBQ3BCQyxhQUFhQSxZQUFZRSxHQUFHLENBQUMsQ0FBQ0MsWUFBWUM7WUFDdENSLCtEQUFjQSxDQUFDQyw0REFBV0EsQ0FBQ00sWUFBWSxLQUFLLGdCQUFnQixDQUFDLFlBQVksRUFBRUMsTUFBTSxDQUFDLENBQUMsRUFBRUQ7WUFDckYsT0FBT0EsV0FBV0UsV0FBVztRQUNqQztJQUNKO0FBQ0o7QUFDQTs7Q0FFQyxHQUNNLFNBQVNDLGNBQWNDLEtBQUs7SUFDL0IsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixRQUFRO1FBQ3RCLE9BQU9BLE1BQU1MLEdBQUcsQ0FBQyxDQUFDUSxLQUFLTjtZQUNuQixJQUFJSSxNQUFNQyxPQUFPLENBQUNDLE1BQU07Z0JBQ3BCZCwrREFBY0EsQ0FBQ2MsSUFBSUMsTUFBTSxLQUFLLEdBQUcsb0JBQW9CLENBQUMsTUFBTSxFQUFFUCxNQUFNLENBQUMsQ0FBQyxFQUFFTTtnQkFDeEUsT0FBT1osYUFBYVksR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUU7WUFDdEM7WUFDQWQsK0RBQWNBLENBQUNjLE9BQU8sUUFBUSxPQUFRQSxRQUFTLFVBQVUsNEJBQTRCLFNBQVNIO1lBQzlGLE9BQU9ULGFBQWFZLElBQUlULE9BQU8sRUFBRVMsSUFBSVYsV0FBVztRQUNwRDtJQUNKO0lBQ0FKLCtEQUFjQSxDQUFDVyxTQUFTLFFBQVEsT0FBUUEsVUFBVyxVQUFVLHVCQUF1QixTQUFTQTtJQUM3RixNQUFNSyxTQUFTQyxPQUFPQyxJQUFJLENBQUNQLE9BQU9MLEdBQUcsQ0FBQyxDQUFDSDtRQUNuQyxNQUFNQyxjQUFjTyxLQUFLLENBQUNSLEtBQUssQ0FBQ2dCLE1BQU0sQ0FBQyxDQUFDQyxPQUFPYjtZQUMzQ2EsS0FBSyxDQUFDYixXQUFXLEdBQUc7WUFDcEIsT0FBT2E7UUFDWCxHQUFHLENBQUM7UUFDSixPQUFPbEIsYUFBYUMsTUFBTWMsT0FBT0MsSUFBSSxDQUFDZCxhQUFhaUIsSUFBSTtJQUMzRDtJQUNBTCxPQUFPSyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBT0QsRUFBRWpCLE9BQU8sQ0FBQ21CLGFBQWEsQ0FBQ0QsRUFBRWxCLE9BQU87SUFDeEQsT0FBT1c7QUFDWCxFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL3lpZC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS90cmFuc2FjdGlvbi9hY2Nlc3NsaXN0LmpzP2VlNTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCIuLi9hZGRyZXNzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhc3NlcnRBcmd1bWVudCwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiLi4vdXRpbHMvaW5kZXguanNcIjtcbmZ1bmN0aW9uIGFjY2Vzc1NldGlmeShhZGRyLCBzdG9yYWdlS2V5cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3MoYWRkciksXG4gICAgICAgIHN0b3JhZ2VLZXlzOiBzdG9yYWdlS2V5cy5tYXAoKHN0b3JhZ2VLZXksIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChpc0hleFN0cmluZyhzdG9yYWdlS2V5LCAzMiksIFwiaW52YWxpZCBzbG90XCIsIGBzdG9yYWdlS2V5c1ske2luZGV4fV1gLCBzdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlS2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pXG4gICAgfTtcbn1cbi8qKlxuICogIFJldHVybnMgYSBbW0FjY2Vzc0xpc3RdXSBmcm9tIGFueSBldGhlcnMtc3VwcG9ydGVkIGFjY2Vzcy1saXN0IHN0cnVjdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFjY2Vzc0xpc3RpZnkodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgoc2V0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2V0KSkge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHNldC5sZW5ndGggPT09IDIsIFwiaW52YWxpZCBzbG90IHNldFwiLCBgdmFsdWVbJHtpbmRleH1dYCwgc2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KHNldFswXSwgc2V0WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHNldCAhPSBudWxsICYmIHR5cGVvZiAoc2V0KSA9PT0gXCJvYmplY3RcIiwgXCJpbnZhbGlkIGFkZHJlc3Mtc2xvdCBzZXRcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KHNldC5hZGRyZXNzLCBzZXQuc3RvcmFnZUtleXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiwgXCJpbnZhbGlkIGFjY2VzcyBsaXN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoKGFkZHIpID0+IHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUtleXMgPSB2YWx1ZVthZGRyXS5yZWR1Y2UoKGFjY3VtLCBzdG9yYWdlS2V5KSA9PiB7XG4gICAgICAgICAgICBhY2N1bVtzdG9yYWdlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShhZGRyLCBPYmplY3Qua2V5cyhzdG9yYWdlS2V5cykuc29ydCgpKTtcbiAgICB9KTtcbiAgICByZXN1bHQuc29ydCgoYSwgYikgPT4gKGEuYWRkcmVzcy5sb2NhbGVDb21wYXJlKGIuYWRkcmVzcykpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjZXNzbGlzdC5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0QWRkcmVzcyIsImFzc2VydEFyZ3VtZW50IiwiaXNIZXhTdHJpbmciLCJhY2Nlc3NTZXRpZnkiLCJhZGRyIiwic3RvcmFnZUtleXMiLCJhZGRyZXNzIiwibWFwIiwic3RvcmFnZUtleSIsImluZGV4IiwidG9Mb3dlckNhc2UiLCJhY2Nlc3NMaXN0aWZ5IiwidmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJzZXQiLCJsZW5ndGgiLCJyZXN1bHQiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwiYWNjdW0iLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/transaction/accesslist.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/data.js":
/*!***************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/data.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   dataLength: () => (/* binding */ dataLength),\n/* harmony export */   dataSlice: () => (/* binding */ dataSlice),\n/* harmony export */   getBytes: () => (/* binding */ getBytes),\n/* harmony export */   getBytesCopy: () => (/* binding */ getBytesCopy),\n/* harmony export */   hexlify: () => (/* binding */ hexlify),\n/* harmony export */   isBytesLike: () => (/* binding */ isBytesLike),\n/* harmony export */   isHexString: () => (/* binding */ isHexString),\n/* harmony export */   stripZerosLeft: () => (/* binding */ stripZerosLeft),\n/* harmony export */   zeroPadBytes: () => (/* binding */ zeroPadBytes),\n/* harmony export */   zeroPadValue: () => (/* binding */ zeroPadValue)\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */ \nfunction _getBytes(value, name, copy) {\n    if (value instanceof Uint8Array) {\n        if (copy) {\n            return new Uint8Array(value);\n        }\n        return value;\n    }\n    if (typeof value === \"string\" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for(let i = 0; i < result.length; i++){\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */ function getBytes(value, name) {\n    return _getBytes(value, name, false);\n}\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */ function getBytesCopy(value, name) {\n    return _getBytes(value, name, true);\n}\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */ function isHexString(value, length) {\n    if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (typeof length === \"number\" && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    if (length === true && value.length % 2 !== 0) {\n        return false;\n    }\n    return true;\n}\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */ function isBytesLike(value) {\n    return isHexString(value, true) || value instanceof Uint8Array;\n}\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */ function hexlify(data) {\n    const bytes = getBytes(data);\n    let result = \"0x\";\n    for(let i = 0; i < bytes.length; i++){\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */ function concat(datas) {\n    return \"0x\" + datas.map((d)=>hexlify(d).substring(2)).join(\"\");\n}\n/**\n *  Returns the length of %%data%%, in bytes.\n */ function dataLength(data) {\n    if (isHexString(data, true)) {\n        return (data.length - 2) / 2;\n    }\n    return getBytes(data).length;\n}\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */ function dataSlice(data, start, end) {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes,\n            length: bytes.length,\n            offset: end\n        });\n    }\n    return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));\n}\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */ function stripZerosLeft(data) {\n    let bytes = hexlify(data).substring(2);\n    while(bytes.startsWith(\"00\")){\n        bytes = bytes.substring(2);\n    }\n    return \"0x\" + bytes;\n}\nfunction zeroPad(data, length, left) {\n    const bytes = getBytes(data);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    } else {\n        result.set(bytes, 0);\n    }\n    return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */ function zeroPadValue(data, length) {\n    return zeroPad(data, length, true);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */ function zeroPadBytes(data, length) {\n    return zeroPad(data, length, false);\n} //# sourceMappingURL=data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUNvRDtBQUNyRCxTQUFTRSxVQUFVQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsSUFBSTtJQUNoQyxJQUFJRixpQkFBaUJHLFlBQVk7UUFDN0IsSUFBSUQsTUFBTTtZQUNOLE9BQU8sSUFBSUMsV0FBV0g7UUFDMUI7UUFDQSxPQUFPQTtJQUNYO0lBQ0EsSUFBSSxPQUFRQSxVQUFXLFlBQVlBLE1BQU1JLEtBQUssQ0FBQywrQkFBK0I7UUFDMUUsTUFBTUMsU0FBUyxJQUFJRixXQUFXLENBQUNILE1BQU1NLE1BQU0sR0FBRyxLQUFLO1FBQ25ELElBQUlDLFNBQVM7UUFDYixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsT0FBT0MsTUFBTSxFQUFFRSxJQUFLO1lBQ3BDSCxNQUFNLENBQUNHLEVBQUUsR0FBR0MsU0FBU1QsTUFBTVUsU0FBUyxDQUFDSCxRQUFRQSxTQUFTLElBQUk7WUFDMURBLFVBQVU7UUFDZDtRQUNBLE9BQU9GO0lBQ1g7SUFDQVAsMERBQWNBLENBQUMsT0FBTywyQkFBMkJHLFFBQVEsU0FBU0Q7QUFDdEU7QUFDQTs7Ozs7O0NBTUMsR0FDTSxTQUFTVyxTQUFTWCxLQUFLLEVBQUVDLElBQUk7SUFDaEMsT0FBT0YsVUFBVUMsT0FBT0MsTUFBTTtBQUNsQztBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNXLGFBQWFaLEtBQUssRUFBRUMsSUFBSTtJQUNwQyxPQUFPRixVQUFVQyxPQUFPQyxNQUFNO0FBQ2xDO0FBQ0E7Ozs7OztDQU1DLEdBQ00sU0FBU1ksWUFBWWIsS0FBSyxFQUFFTSxNQUFNO0lBQ3JDLElBQUksT0FBUU4sVUFBVyxZQUFZLENBQUNBLE1BQU1JLEtBQUssQ0FBQyxxQkFBcUI7UUFDakUsT0FBTztJQUNYO0lBQ0EsSUFBSSxPQUFRRSxXQUFZLFlBQVlOLE1BQU1NLE1BQU0s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YWNrOi8veWlkLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL2RhdGEuanM/YzY4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBTb21lIGRhdGEgaGVscGVycy5cbiAqXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6RGF0YSBIZWxwZXJzICBbYWJvdXQtZGF0YV1cbiAqL1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRBcmd1bWVudCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZnVuY3Rpb24gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCBjb3B5KSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5tYXRjaCgvXjB4KD86WzAtOWEtZl1bMC05YS1mXSkqJC9pKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgodmFsdWUubGVuZ3RoIC0gMikgLyAyKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgKyAyKSwgMTYpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBCeXRlc0xpa2UgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbi8qKlxuICogIEdldCBhIHR5cGVkIFVpbnQ4QXJyYXkgZm9yICUldmFsdWUlJS4gSWYgYWxyZWFkeSBhIFVpbnQ4QXJyYXlcbiAqICB0aGUgb3JpZ2luYWwgJSV2YWx1ZSUlIGlzIHJldHVybmVkOyBpZiBhIGNvcHkgaXMgcmVxdWlyZWQgdXNlXG4gKiAgW1tnZXRCeXRlc0NvcHldXS5cbiAqXG4gKiAgQHNlZTogZ2V0Qnl0ZXNDb3B5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCeXRlcyh2YWx1ZSwgbmFtZSkge1xuICAgIHJldHVybiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIGZhbHNlKTtcbn1cbi8qKlxuICogIEdldCBhIHR5cGVkIFVpbnQ4QXJyYXkgZm9yICUldmFsdWUlJSwgY3JlYXRpbmcgYSBjb3B5IGlmIG5lY2Vzc2FyeVxuICogIHRvIHByZXZlbnQgYW55IG1vZGlmaWNhdGlvbnMgb2YgdGhlIHJldHVybmVkIHZhbHVlIGZyb20gYmVpbmdcbiAqICByZWZsZWN0ZWQgZWxzZXdoZXJlLlxuICpcbiAqICBAc2VlOiBnZXRCeXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qnl0ZXNDb3B5KHZhbHVlLCBuYW1lKSB7XG4gICAgcmV0dXJuIF9nZXRCeXRlcyh2YWx1ZSwgbmFtZSwgdHJ1ZSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgW1tIZXhTdHJpbmddXS5cbiAqXG4gKiAgSWYgJSVsZW5ndGglJSBpcyBgYHRydWVgYCBvciBhIC8vbnVtYmVyLy8sIGl0IGFsc28gY2hlY2tzIHRoYXRcbiAqICAlJXZhbHVlJSUgaXMgYSB2YWxpZCBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWxlbmd0aCUlIChpZiBhIC8vbnVtYmVyLy8pXG4gKiAgYnl0ZXMgb2YgZGF0YSAoZS5nLiBgYDB4MTIzNGBgIGlzIDIgYnl0ZXMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKGxlbmd0aCkgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPT09IHRydWUgJiYgKHZhbHVlLmxlbmd0aCAlIDIpICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYXJiaXRyYXJ5XG4gKiAgZGF0YSAoaS5lLiBhIHZhbGlkIFtbRGF0YUhleFN0cmluZ11dIG9yIGEgVWludDhBcnJheSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzTGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaXNIZXhTdHJpbmcodmFsdWUsIHRydWUpIHx8ICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKTtcbn1cbmNvbnN0IEhleENoYXJhY3RlcnMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qKlxuICogIFJldHVybnMgYSBbW0RhdGFIZXhTdHJpbmddXSByZXByZXNlbnRhdGlvbiBvZiAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleGxpZnkoZGF0YSkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHYgPSBieXRlc1tpXTtcbiAgICAgICAgcmVzdWx0ICs9IEhleENoYXJhY3RlcnNbKHYgJiAweGYwKSA+PiA0XSArIEhleENoYXJhY3RlcnNbdiAmIDB4MGZdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIGJ5IGNvbmNhdGVuYXRpbmcgYWxsIHZhbHVlc1xuICogIHdpdGhpbiAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdChkYXRhcykge1xuICAgIHJldHVybiBcIjB4XCIgKyBkYXRhcy5tYXAoKGQpID0+IGhleGxpZnkoZCkuc3Vic3RyaW5nKDIpKS5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLCBpbiBieXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGFMZW5ndGgoZGF0YSkge1xuICAgIGlmIChpc0hleFN0cmluZyhkYXRhLCB0cnVlKSkge1xuICAgICAgICByZXR1cm4gKGRhdGEubGVuZ3RoIC0gMikgLyAyO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Qnl0ZXMoZGF0YSkubGVuZ3RoO1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIGJ5IHNsaWNpbmcgJSVkYXRhJSUgZnJvbSB0aGUgJSVzdGFydCUlXG4gKiAgb2Zmc2V0IHRvIHRoZSAlJWVuZCUlIG9mZnNldC5cbiAqXG4gKiAgQnkgZGVmYXVsdCAlJXN0YXJ0JSUgaXMgMCBhbmQgJSVlbmQlJSBpcyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0YVNsaWNlKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgIGlmIChlbmQgIT0gbnVsbCAmJiBlbmQgPiBieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImNhbm5vdCBzbGljZSBiZXlvbmQgZGF0YSBib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICBidWZmZXI6IGJ5dGVzLCBsZW5ndGg6IGJ5dGVzLmxlbmd0aCwgb2Zmc2V0OiBlbmRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzLnNsaWNlKChzdGFydCA9PSBudWxsKSA/IDAgOiBzdGFydCwgKGVuZCA9PSBudWxsKSA/IGJ5dGVzLmxlbmd0aCA6IGVuZCkpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSByZXN1bHQgYnkgc3RyaXBwaW5nIGFsbCAqKmxlYWRpbmcqKlxuICoqIHplcm8gYnl0ZXMgZnJvbSAlJWRhdGElJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwWmVyb3NMZWZ0KGRhdGEpIHtcbiAgICBsZXQgYnl0ZXMgPSBoZXhsaWZ5KGRhdGEpLnN1YnN0cmluZygyKTtcbiAgICB3aGlsZSAoYnl0ZXMuc3RhcnRzV2l0aChcIjAwXCIpKSB7XG4gICAgICAgIGJ5dGVzID0gYnl0ZXMuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgYnl0ZXM7XG59XG5mdW5jdGlvbiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgbGVmdCkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgYXNzZXJ0KGxlbmd0aCA+PSBieXRlcy5sZW5ndGgsIFwicGFkZGluZyBleGNlZWRzIGRhdGEgbGVuZ3RoXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICBidWZmZXI6IG5ldyBVaW50OEFycmF5KGJ5dGVzKSxcbiAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgIG9mZnNldDogbGVuZ3RoICsgMVxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgcmVzdWx0LmZpbGwoMCk7XG4gICAgaWYgKGxlZnQpIHtcbiAgICAgICAgcmVzdWx0LnNldChieXRlcywgbGVuZ3RoIC0gYnl0ZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5zZXQoYnl0ZXMsIDApO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWRhdGElJSBwYWRkZWQgb24gdGhlICoqbGVmdCoqXG4gKiAgdG8gJSVsZW5ndGglJSBieXRlcy5cbiAqXG4gKiAgSWYgJSVkYXRhJSUgYWxyZWFkeSBleGNlZWRzICUlbGVuZ3RoJSUsIGEgW1tCdWZmZXJPdmVycnVuRXJyb3JdXSBpc1xuICogIHRocm93bi5cbiAqXG4gKiAgVGhpcyBwYWRzIGRhdGEgdGhlIHNhbWUgYXMgKip2YWx1ZXMqKiBhcmUgaW4gU29saWRpdHlcbiAqICAoZS5nLiBgYHVpbnQxMjhgYCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvUGFkVmFsdWUoZGF0YSwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCB0cnVlKTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVkYXRhJSUgcGFkZGVkIG9uIHRoZSAqKnJpZ2h0KipcbiAqICB0byAlJWxlbmd0aCUlIGJ5dGVzLlxuICpcbiAqICBJZiAlJWRhdGElJSBhbHJlYWR5IGV4Y2VlZHMgJSVsZW5ndGglJSwgYSBbW0J1ZmZlck92ZXJydW5FcnJvcl1dIGlzXG4gKiAgdGhyb3duLlxuICpcbiAqICBUaGlzIHBhZHMgZGF0YSB0aGUgc2FtZSBhcyAqKmJ5dGVzKiogYXJlIGluIFNvbGlkaXR5XG4gKiAgKGUuZy4gYGBieXRlczE2YGApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gemVyb1BhZEJ5dGVzKGRhdGEsIGxlbmd0aCkge1xuICAgIHJldHVybiB6ZXJvUGFkKGRhdGEsIGxlbmd0aCwgZmFsc2UpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS5qcy5tYXAiXSwibmFtZXMiOlsiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJfZ2V0Qnl0ZXMiLCJ2YWx1ZSIsIm5hbWUiLCJjb3B5IiwiVWludDhBcnJheSIsIm1hdGNoIiwicmVzdWx0IiwibGVuZ3RoIiwib2Zmc2V0IiwiaSIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwiZ2V0Qnl0ZXMiLCJnZXRCeXRlc0NvcHkiLCJpc0hleFN0cmluZyIsImlzQnl0ZXNMaWtlIiwiSGV4Q2hhcmFjdGVycyIsImhleGxpZnkiLCJkYXRhIiwiYnl0ZXMiLCJ2IiwiY29uY2F0IiwiZGF0YXMiLCJtYXAiLCJkIiwiam9pbiIsImRhdGFMZW5ndGgiLCJkYXRhU2xpY2UiLCJzdGFydCIsImVuZCIsImJ1ZmZlciIsInNsaWNlIiwic3RyaXBaZXJvc0xlZnQiLCJzdGFydHNXaXRoIiwiemVyb1BhZCIsImxlZnQiLCJmaWxsIiwic2V0IiwiemVyb1BhZFZhbHVlIiwiemVyb1BhZEJ5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/errors.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertArgument: () => (/* binding */ assertArgument),\n/* harmony export */   assertArgumentCount: () => (/* binding */ assertArgumentCount),\n/* harmony export */   assertNormalize: () => (/* binding */ assertNormalize),\n/* harmony export */   assertPrivate: () => (/* binding */ assertPrivate),\n/* harmony export */   isCallException: () => (/* binding */ isCallException),\n/* harmony export */   isError: () => (/* binding */ isError),\n/* harmony export */   makeError: () => (/* binding */ makeError)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"(ssr)/./node_modules/ethers/lib.esm/_version.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */ \n\nfunction stringify(value, seen) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (seen == null) {\n        seen = new Set();\n    }\n    if (typeof value === \"object\") {\n        if (seen.has(value)) {\n            return \"[Circular]\";\n        }\n        seen.add(value);\n    }\n    if (Array.isArray(value)) {\n        return \"[ \" + value.map((v)=>stringify(v, seen)).join(\", \") + \" ]\";\n    }\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for(let i = 0; i < value.length; i++){\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n    if (typeof value === \"object\" && typeof value.toJSON === \"function\") {\n        return stringify(value.toJSON(), seen);\n    }\n    switch(typeof value){\n        case \"boolean\":\n        case \"number\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\":\n            {\n                const keys = Object.keys(value);\n                keys.sort();\n                return \"{ \" + keys.map((k)=>`${stringify(k, seen)}: ${stringify(value[k], seen)}`).join(\", \") + \" }\";\n            }\n    }\n    return `[ COULD NOT SERIALIZE ]`;\n}\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript environments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */ function isError(error, code) {\n    return error && error.code === code;\n}\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */ function isCallException(error) {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depending on %%code%%, additional\n *  required properties. The error message will also include the %%message%%,\n *  ethers version, %%code%% and all additional properties, serialized.\n */ function makeError(message, code, info) {\n    let shortMessage = message;\n    {\n        const details = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${stringify(info)}`);\n            }\n            for(const key in info){\n                if (key === \"shortMessage\") {\n                    continue;\n                }\n                const value = info[key];\n                //                try {\n                details.push(key + \"=\" + stringify(value));\n            //                } catch (error: any) {\n            //                console.log(\"MMM\", error.message);\n            //                    details.push(key + \"=[could not serialize object]\");\n            //                }\n            }\n        }\n        details.push(`code=${code}`);\n        details.push(`version=${_version_js__WEBPACK_IMPORTED_MODULE_0__.version}`);\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n    let error;\n    switch(code){\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n    (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, {\n        code\n    });\n    if (info) {\n        Object.assign(error, info);\n    }\n    if (error.shortMessage == null) {\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_1__.defineProperties)(error, {\n            shortMessage\n        });\n    }\n    return error;\n}\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */ function assert(check, message, code, info) {\n    if (!check) {\n        throw makeError(message, code, info);\n    }\n}\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */ function assertArgument(check, message, name, value) {\n    assert(check, message, \"INVALID_ARGUMENT\", {\n        argument: name,\n        value: value\n    });\n}\nfunction assertArgumentCount(count, expectedCount, message) {\n    if (message == null) {\n        message = \"\";\n    }\n    if (message) {\n        message = \": \" + message;\n    }\n    assert(count >= expectedCount, \"missing argument\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n    assert(count <= expectedCount, \"too many arguments\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\nconst _normalizeForms = [\n    \"NFD\",\n    \"NFC\",\n    \"NFKD\",\n    \"NFKC\"\n].reduce((accum, form)=>{\n    try {\n        // General test for normalize\n        /* c8 ignore start */ if (\"test\".normalize(form) !== \"test\") {\n            throw new Error(\"bad\");\n        }\n        ;\n        /* c8 ignore stop */ if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301);\n            /* c8 ignore start */ if (check !== expected) {\n                throw new Error(\"broken\");\n            }\n        /* c8 ignore stop */ }\n        accum.push(form);\n    } catch (error) {}\n    return accum;\n}, []);\n/**\n *  Throws if the normalization %%form%% is not supported.\n */ function assertNormalize(form) {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\",\n        info: {\n            form\n        }\n    });\n}\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */ function assertPrivate(givenGuard, guard, className) {\n    if (className == null) {\n        className = \"\";\n    }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${method}from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Q0FRQyxHQUN3QztBQUNVO0FBQ25ELFNBQVNFLFVBQVVDLEtBQUssRUFBRUMsSUFBSTtJQUMxQixJQUFJRCxTQUFTLE1BQU07UUFDZixPQUFPO0lBQ1g7SUFDQSxJQUFJQyxRQUFRLE1BQU07UUFDZEEsT0FBTyxJQUFJQztJQUNmO0lBQ0EsSUFBSSxPQUFRRixVQUFXLFVBQVU7UUFDN0IsSUFBSUMsS0FBS0UsR0FBRyxDQUFDSCxRQUFRO1lBQ2pCLE9BQU87UUFDWDtRQUNBQyxLQUFLRyxHQUFHLENBQUNKO0lBQ2I7SUFDQSxJQUFJSyxNQUFNQyxPQUFPLENBQUNOLFFBQVE7UUFDdEIsT0FBTyxPQUFPLE1BQU9PLEdBQUcsQ0FBQyxDQUFDQyxJQUFNVCxVQUFVUyxHQUFHUCxPQUFRUSxJQUFJLENBQUMsUUFBUTtJQUN0RTtJQUNBLElBQUlULGlCQUFpQlUsWUFBWTtRQUM3QixNQUFNQyxNQUFNO1FBQ1osSUFBSUMsU0FBUztRQUNiLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJYixNQUFNYyxNQUFNLEVBQUVELElBQUs7WUFDbkNELFVBQVVELEdBQUcsQ0FBQ1gsS0FBSyxDQUFDYSxFQUFFLElBQUksRUFBRTtZQUM1QkQsVUFBVUQsR0FBRyxDQUFDWCxLQUFLLENBQUNhLEVBQUUsR0FBRyxJQUFJO1FBQ2pDO1FBQ0EsT0FBT0Q7SUFDWDtJQUNBLElBQUksT0FBUVosVUFBVyxZQUFZLE9BQVFBLE1BQU1lLE1BQU0sS0FBTSxZQUFZO1FBQ3JFLE9BQU9oQixVQUFVQyxNQUFNZSxNQUFNLElBQUlkO0lBQ3JDO0lBQ0EsT0FBUSxPQUFRRDtRQUNaLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNELE9BQU9BLE1BQU1nQixRQUFRO1FBQ3pCLEtBQUs7WUFDRCxPQUFPQyxPQUFPakIsT0FBT2dCLFFBQVE7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LGVBQWVDLE9BQU87UUFDdEIsSUFBSUUsU0FBU0QsV0FBV0osWUFBWTtRQUNwQyxJQUFJSSxXQUFXO1lBQ1hDLFVBQVU7WUFDVkwsYUFBYSxNQUFNSTtRQUN2QjtRQUNBdEIsT0FBTyxPQUFPLENBQUMseUJBQXlCLEVBQUV1QixPQUFPLGFBQWEsQ0FBQyxFQUFFLHlCQUF5QjtZQUN0Rkw7UUFDSjtJQUNKO0FBQ0osRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95aWQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXJyb3JzLmpzPzg2NmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQWxsIGVycm9ycyBpbiBldGhlcnMgaW5jbHVkZSBwcm9wZXJ0aWVzIHRvIGVuc3VyZSB0aGV5IGFyZSBib3RoXG4gKiAgaHVtYW4tcmVhZGFibGUgKGkuZS4gYGAubWVzc2FnZWBgKSBhbmQgbWFjaGluZS1yZWFkYWJsZSAoaS5lLiBgYC5jb2RlYGApLlxuICpcbiAqICBUaGUgW1tpc0Vycm9yXV0gZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gY2hlY2sgdGhlIGVycm9yIGBgY29kZWBgIGFuZFxuICogIHByb3ZpZGUgYSB0eXBlIGd1YXJkIGZvciB0aGUgcHJvcGVydGllcyBwcmVzZW50IG9uIHRoYXQgZXJyb3IgaW50ZXJmYWNlLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS91dGlscy9lcnJvcnM6RXJyb3JzICBbYWJvdXQtZXJyb3JzXVxuICovXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL192ZXJzaW9uLmpzXCI7XG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlLCBzZWVuKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICBpZiAoc2VlbiA9PSBudWxsKSB7XG4gICAgICAgIHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5hZGQodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiWyBcIiArICh2YWx1ZS5tYXAoKHYpID0+IHN0cmluZ2lmeSh2LCBzZWVuKSkpLmpvaW4oXCIsIFwiKSArIFwiIF1cIjtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBjb25zdCBIRVggPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IEhFWFt2YWx1ZVtpXSA+PiA0XTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBIRVhbdmFsdWVbaV0gJiAweGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgKHZhbHVlLnRvSlNPTikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5KHZhbHVlLnRvSlNPTigpLCBzZWVuKTtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgICAgICBrZXlzLnNvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBcInsgXCIgKyBrZXlzLm1hcCgoaykgPT4gYCR7c3RyaW5naWZ5KGssIHNlZW4pfTogJHtzdHJpbmdpZnkodmFsdWVba10sIHNlZW4pfWApLmpvaW4oXCIsIFwiKSArIFwiIH1cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYFsgQ09VTEQgTk9UIFNFUklBTElaRSBdYDtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiB0aGUgJSVlcnJvciUlIG1hdGNoZXMgYW4gZXJyb3IgdGhyb3duIGJ5IGV0aGVyc1xuICogIHRoYXQgbWF0Y2hlcyB0aGUgZXJyb3IgJSVjb2RlJSUuXG4gKlxuICogIEluIFR5cGVTY3JpcHQgZW52aXJvbm1lbnRzLCB0aGlzIGNhbiBiZSB1c2VkIHRvIGNoZWNrIHRoYXQgJSVlcnJvciUlXG4gKiAgbWF0Y2hlcyBhbiBFdGhlcnNFcnJvciB0eXBlLCB3aGljaCBtZWFucyB0aGUgZXhwZWN0ZWQgcHJvcGVydGllcyB3aWxsXG4gKiAgYmUgc2V0LlxuICpcbiAqICBAU2VlIFtFcnJvckNvZGVzXShhcGk6RXJyb3JDb2RlKVxuICogIEBleGFtcGxlXG4gKiAgICB0cnkge1xuICogICAgICAvLyBjb2RlLi4uLlxuICogICAgfSBjYXRjaCAoZSkge1xuICogICAgICBpZiAoaXNFcnJvcihlLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gKiAgICAgICAgICAvLyBUaGUgVHlwZSBHdWFyZCBoYXMgdmFsaWRhdGVkIHRoaXMgb2JqZWN0XG4gKiAgICAgICAgICBjb25zb2xlLmxvZyhlLmRhdGEpO1xuICogICAgICB9XG4gKiAgICB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Vycm9yKGVycm9yLCBjb2RlKSB7XG4gICAgcmV0dXJuIChlcnJvciAmJiBlcnJvci5jb2RlID09PSBjb2RlKTtcbn1cbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJWVycm9yJSUgaXMgYSBbW0NhbGxFeGNlcHRpb25FcnJvcl0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NhbGxFeGNlcHRpb24oZXJyb3IpIHtcbiAgICByZXR1cm4gaXNFcnJvcihlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKTtcbn1cbi8qKlxuICogIFJldHVybnMgYSBuZXcgRXJyb3IgY29uZmlndXJlZCB0byB0aGUgZm9ybWF0IGV0aGVycyBlbWl0cyBlcnJvcnMsIHdpdGhcbiAqICB0aGUgJSVtZXNzYWdlJSUsIFtbYXBpOkVycm9yQ29kZV1dICUlY29kZSUlIGFuZCBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqICBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgRXRoZXJzRXJyb3IuXG4gKlxuICogIEVhY2ggZXJyb3IgaW4gZXRoZXJzIGluY2x1ZGVzIHRoZSB2ZXJzaW9uIG9mIGV0aGVycywgYVxuICogIG1hY2hpbmUtcmVhZGFibGUgW1tFcnJvckNvZGVdXSwgYW5kIGRlcGVuZGluZyBvbiAlJWNvZGUlJSwgYWRkaXRpb25hbFxuICogIHJlcXVpcmVkIHByb3BlcnRpZXMuIFRoZSBlcnJvciBtZXNzYWdlIHdpbGwgYWxzbyBpbmNsdWRlIHRoZSAlJW1lc3NhZ2UlJSxcbiAqICBldGhlcnMgdmVyc2lvbiwgJSVjb2RlJSUgYW5kIGFsbCBhZGRpdGlvbmFsIHByb3BlcnRpZXMsIHNlcmlhbGl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgaW5mbykge1xuICAgIGxldCBzaG9ydE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IFtdO1xuICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgaWYgKFwibWVzc2FnZVwiIGluIGluZm8gfHwgXCJjb2RlXCIgaW4gaW5mbyB8fCBcIm5hbWVcIiBpbiBpbmZvKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YWx1ZSB3aWxsIG92ZXJ3cml0ZSBwb3B1bGF0ZWQgdmFsdWVzOiAke3N0cmluZ2lmeShpbmZvKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcInNob3J0TWVzc2FnZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IChpbmZvW2tleV0pO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTU1NXCIsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLnB1c2goa2V5ICsgXCI9W2NvdWxkIG5vdCBzZXJpYWxpemUgb2JqZWN0XVwiKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWlscy5wdXNoKGBjb2RlPSR7Y29kZX1gKTtcbiAgICAgICAgZGV0YWlscy5wdXNoKGB2ZXJzaW9uPSR7dmVyc2lvbn1gKTtcbiAgICAgICAgaWYgKGRldGFpbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChcIiArIGRldGFpbHMuam9pbihcIiwgXCIpICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGVycm9yO1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIFwiSU5WQUxJRF9BUkdVTUVOVFwiOlxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgVHlwZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJOVU1FUklDX0ZBVUxUXCI6XG4gICAgICAgIGNhc2UgXCJCVUZGRVJfT1ZFUlJVTlwiOlxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgUmFuZ2VFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIGRlZmluZVByb3BlcnRpZXMoZXJyb3IsIHsgY29kZSB9KTtcbiAgICBpZiAoaW5mbykge1xuICAgICAgICBPYmplY3QuYXNzaWduKGVycm9yLCBpbmZvKTtcbiAgICB9XG4gICAgaWYgKGVycm9yLnNob3J0TWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoZXJyb3IsIHsgc2hvcnRNZXNzYWdlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG59XG4vKipcbiAqICBUaHJvd3MgYW4gRXRoZXJzRXJyb3Igd2l0aCAlJW1lc3NhZ2UlJSwgJSVjb2RlJSUgYW5kIGFkZGl0aW9uYWwgZXJyb3JcbiAqICAlJWluZm8lJSB3aGVuICUlY2hlY2slJSBpcyBmYWxzaXNoLi5cbiAqXG4gKiAgQHNlZSBbW2FwaTptYWtlRXJyb3JdXVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGNoZWNrLCBtZXNzYWdlLCBjb2RlLCBpbmZvKSB7XG4gICAgaWYgKCFjaGVjaykge1xuICAgICAgICB0aHJvdyBtYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgaW5mbyk7XG4gICAgfVxufVxuLyoqXG4gKiAgQSBzaW1wbGUgaGVscGVyIHRvIHNpbXBseSBlbnN1cmluZyBwcm92aWRlZCBhcmd1bWVudHMgbWF0Y2ggZXhwZWN0ZWRcbiAqICBjb25zdHJhaW50cywgdGhyb3dpbmcgaWYgbm90LlxuICpcbiAqICBJbiBUeXBlU2NyaXB0IGVudmlyb25tZW50cywgdGhlICUlY2hlY2slJSBoYXMgYmVlbiBhc3NlcnRlZCB0cnVlLCBzb1xuICogIGFueSBmdXJ0aGVyIGNvZGUgZG9lcyBub3QgbmVlZCBhZGRpdGlvbmFsIGNvbXBpbGUtdGltZSBjaGVja3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRBcmd1bWVudChjaGVjaywgbWVzc2FnZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBhc3NlcnQoY2hlY2ssIG1lc3NhZ2UsIFwiSU5WQUxJRF9BUkdVTUVOVFwiLCB7IGFyZ3VtZW50OiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0QXJndW1lbnRDb3VudChjb3VudCwgZXhwZWN0ZWRDb3VudCwgbWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIjogXCIgKyBtZXNzYWdlO1xuICAgIH1cbiAgICBhc3NlcnQoY291bnQgPj0gZXhwZWN0ZWRDb3VudCwgXCJtaXNzaW5nIGFyZ3VtZW50XCIgKyBtZXNzYWdlLCBcIk1JU1NJTkdfQVJHVU1FTlRcIiwge1xuICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICB9KTtcbiAgICBhc3NlcnQoY291bnQgPD0gZXhwZWN0ZWRDb3VudCwgXCJ0b28gbWFueSBhcmd1bWVudHNcIiArIG1lc3NhZ2UsIFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiLCB7XG4gICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgIH0pO1xufVxuY29uc3QgX25vcm1hbGl6ZUZvcm1zID0gW1wiTkZEXCIsIFwiTkZDXCIsIFwiTkZLRFwiLCBcIk5GS0NcIl0ucmVkdWNlKChhY2N1bSwgZm9ybSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEdlbmVyYWwgdGVzdCBmb3Igbm9ybWFsaXplXG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoXCJ0ZXN0XCIubm9ybWFsaXplKGZvcm0pICE9PSBcInRlc3RcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkXCIpO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKGZvcm0gPT09IFwiTkZEXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGU5KS5ub3JtYWxpemUoXCJORkRcIik7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg2NSwgMHgwMzAxKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKGNoZWNrICE9PSBleHBlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJyb2tlblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIH1cbiAgICAgICAgYWNjdW0ucHVzaChmb3JtKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gYWNjdW07XG59LCBbXSk7XG4vKipcbiAqICBUaHJvd3MgaWYgdGhlIG5vcm1hbGl6YXRpb24gJSVmb3JtJSUgaXMgbm90IHN1cHBvcnRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5vcm1hbGl6ZShmb3JtKSB7XG4gICAgYXNzZXJ0KF9ub3JtYWxpemVGb3Jtcy5pbmRleE9mKGZvcm0pID49IDAsIFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBpbmZvOiB7IGZvcm0gfVxuICAgIH0pO1xufVxuLyoqXG4gKiAgTWFueSBjbGFzc2VzIHVzZSBmaWxlLXNjb3BlZCB2YWx1ZXMgdG8gZ3VhcmQgdGhlIGNvbnN0cnVjdG9yLFxuICogIG1ha2luZyBpdCBlZmZlY3RpdmVseSBwcml2YXRlLiBUaGlzIGZhY2lsaXRhdGVzIHRoYXQgcGF0dGVyblxuICogIGJ5IGVuc3VyaW5nIHRoZSAlJWdpdmVuR2F1cmQlJSBtYXRjaGVzIHRoZSBmaWxlLXNjb3BlZCAlJWd1YXJkJSUsXG4gKiAgdGhyb3dpbmcgaWYgbm90LCBpbmRpY2F0aW5nIHRoZSAlJWNsYXNzTmFtZSUlIGlmIHByb3ZpZGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UHJpdmF0ZShnaXZlbkd1YXJkLCBndWFyZCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGNsYXNzTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IFwiXCI7XG4gICAgfVxuICAgIGlmIChnaXZlbkd1YXJkICE9PSBndWFyZCkge1xuICAgICAgICBsZXQgbWV0aG9kID0gY2xhc3NOYW1lLCBvcGVyYXRpb24gPSBcIm5ld1wiO1xuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gXCIuXCI7XG4gICAgICAgICAgICBvcGVyYXRpb24gKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KGZhbHNlLCBgcHJpdmF0ZSBjb25zdHJ1Y3RvcjsgdXNlICR7bWV0aG9kfWZyb20qIG1ldGhvZHNgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6WyJ2ZXJzaW9uIiwiZGVmaW5lUHJvcGVydGllcyIsInN0cmluZ2lmeSIsInZhbHVlIiwic2VlbiIsIlNldCIsImhhcyIsImFkZCIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsInYiLCJqb2luIiwiVWludDhBcnJheSIsIkhFWCIsInJlc3VsdCIsImkiLCJsZW5ndGgiLCJ0b0pTT04iLCJ0b1N0cmluZyIsIkJpZ0ludCIsIkpTT04iLCJrZXlzIiwiT2JqZWN0Iiwic29ydCIsImsiLCJpc0Vycm9yIiwiZXJyb3IiLCJjb2RlIiwiaXNDYWxsRXhjZXB0aW9uIiwibWFrZUVycm9yIiwibWVzc2FnZSIsImluZm8iLCJzaG9ydE1lc3NhZ2UiLCJkZXRhaWxzIiwiRXJyb3IiLCJrZXkiLCJwdXNoIiwiVHlwZUVycm9yIiwiUmFuZ2VFcnJvciIsImFzc2lnbiIsImFzc2VydCIsImNoZWNrIiwiYXNzZXJ0QXJndW1lbnQiLCJuYW1lIiwiYXJndW1lbnQiLCJhc3NlcnRBcmd1bWVudENvdW50IiwiY291bnQiLCJleHBlY3RlZENvdW50IiwiX25vcm1hbGl6ZUZvcm1zIiwicmVkdWNlIiwiYWNjdW0iLCJmb3JtIiwibm9ybWFsaXplIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZXhwZWN0ZWQiLCJhc3NlcnROb3JtYWxpemUiLCJpbmRleE9mIiwib3BlcmF0aW9uIiwiYXNzZXJ0UHJpdmF0ZSIsImdpdmVuR3VhcmQiLCJndWFyZCIsImNsYXNzTmFtZSIsIm1ldGhvZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/events.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/events.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventPayload: () => (/* binding */ EventPayload)\n/* harmony export */ });\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./properties.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  Events allow for applications to use the observer pattern, which\n *  allows subscribing and publishing events, outside the normal\n *  execution paths.\n *\n *  @_section api/utils/events:Events  [about-events]\n */ \n/**\n *  When an [[EventEmitterable]] triggers a [[Listener]], the\n *  callback always ahas one additional argument passed, which is\n *  an **EventPayload**.\n */ class EventPayload {\n    #listener;\n    /**\n     *  Create a new **EventPayload** for %%emitter%% with\n     *  the %%listener%% and for %%filter%%.\n     */ constructor(emitter, listener, filter){\n        this.#listener = listener;\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_0__.defineProperties)(this, {\n            emitter,\n            filter\n        });\n    }\n    /**\n     *  Unregister the triggered listener for future events.\n     */ async removeListener() {\n        if (this.#listener == null) {\n            return;\n        }\n        await this.emitter.off(this.filter, this.#listener);\n    }\n} //# sourceMappingURL=events.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXZlbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7OztDQU1DLEdBQ2tEO0FBQ25EOzs7O0NBSUMsR0FDTSxNQUFNQztJQVNULENBQUNDLFFBQVEsQ0FBQztJQUNWOzs7S0FHQyxHQUNEQyxZQUFZQyxPQUFPLEVBQUVGLFFBQVEsRUFBRUcsTUFBTSxDQUFFO1FBQ25DLElBQUksQ0FBQyxDQUFDSCxRQUFRLEdBQUdBO1FBQ2pCRixnRUFBZ0JBLENBQUMsSUFBSSxFQUFFO1lBQUVJO1lBQVNDO1FBQU87SUFDN0M7SUFDQTs7S0FFQyxHQUNELE1BQU1DLGlCQUFpQjtRQUNuQixJQUFJLElBQUksQ0FBQyxDQUFDSixRQUFRLElBQUksTUFBTTtZQUN4QjtRQUNKO1FBQ0EsTUFBTSxJQUFJLENBQUNFLE9BQU8sQ0FBQ0csR0FBRyxDQUFDLElBQUksQ0FBQ0YsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDSCxRQUFRO0lBQ3REO0FBQ0osRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95aWQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZXZlbnRzLmpzPzczM2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgRXZlbnRzIGFsbG93IGZvciBhcHBsaWNhdGlvbnMgdG8gdXNlIHRoZSBvYnNlcnZlciBwYXR0ZXJuLCB3aGljaFxuICogIGFsbG93cyBzdWJzY3JpYmluZyBhbmQgcHVibGlzaGluZyBldmVudHMsIG91dHNpZGUgdGhlIG5vcm1hbFxuICogIGV4ZWN1dGlvbiBwYXRocy5cbiAqXG4gKiAgQF9zZWN0aW9uIGFwaS91dGlscy9ldmVudHM6RXZlbnRzICBbYWJvdXQtZXZlbnRzXVxuICovXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4vcHJvcGVydGllcy5qc1wiO1xuLyoqXG4gKiAgV2hlbiBhbiBbW0V2ZW50RW1pdHRlcmFibGVdXSB0cmlnZ2VycyBhIFtbTGlzdGVuZXJdXSwgdGhlXG4gKiAgY2FsbGJhY2sgYWx3YXlzIGFoYXMgb25lIGFkZGl0aW9uYWwgYXJndW1lbnQgcGFzc2VkLCB3aGljaCBpc1xuICogIGFuICoqRXZlbnRQYXlsb2FkKiouXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudFBheWxvYWQge1xuICAgIC8qKlxuICAgICAqICBUaGUgZXZlbnQgZmlsdGVyLlxuICAgICAqL1xuICAgIGZpbHRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlICoqRXZlbnRFbWl0dGVyYWJsZSoqLlxuICAgICAqL1xuICAgIGVtaXR0ZXI7XG4gICAgI2xpc3RlbmVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipFdmVudFBheWxvYWQqKiBmb3IgJSVlbWl0dGVyJSUgd2l0aFxuICAgICAqICB0aGUgJSVsaXN0ZW5lciUlIGFuZCBmb3IgJSVmaWx0ZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbWl0dGVyLCBsaXN0ZW5lciwgZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuI2xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBlbWl0dGVyLCBmaWx0ZXIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVbnJlZ2lzdGVyIHRoZSB0cmlnZ2VyZWQgbGlzdGVuZXIgZm9yIGZ1dHVyZSBldmVudHMuXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLiNsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5lbWl0dGVyLm9mZih0aGlzLmZpbHRlciwgdGhpcy4jbGlzdGVuZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50cy5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUHJvcGVydGllcyIsIkV2ZW50UGF5bG9hZCIsImxpc3RlbmVyIiwiY29uc3RydWN0b3IiLCJlbWl0dGVyIiwiZmlsdGVyIiwicmVtb3ZlTGlzdGVuZXIiLCJvZmYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/events.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/maths.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/maths.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromTwos: () => (/* binding */ fromTwos),\n/* harmony export */   getBigInt: () => (/* binding */ getBigInt),\n/* harmony export */   getNumber: () => (/* binding */ getNumber),\n/* harmony export */   getUint: () => (/* binding */ getUint),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   toBeArray: () => (/* binding */ toBeArray),\n/* harmony export */   toBeHex: () => (/* binding */ toBeHex),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toQuantity: () => (/* binding */ toQuantity),\n/* harmony export */   toTwos: () => (/* binding */ toTwos)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */ \n\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */ function fromTwos(_value, _width) {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value >> width === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\",\n        fault: \"overflow\",\n        value: _value\n    });\n    // Top bit set; treat as a negative value\n    if (value >> width - BN_1) {\n        const mask = (BN_1 << width) - BN_1;\n        return -((~value & mask) + BN_1);\n    }\n    return value;\n}\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */ function toTwos(_value, _width) {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    const limit = BN_1 << width - BN_1;\n    if (value < BN_0) {\n        value = -value;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\",\n            fault: \"overflow\",\n            value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return (~value & mask) + BN_1;\n    } else {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\",\n            fault: \"overflow\",\n            value: _value\n        });\n    }\n    return value;\n}\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */ function mask(_value, _bits) {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & (BN_1 << bits) - BN_1;\n}\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */ function getBigInt(value, name) {\n    switch(typeof value){\n        case \"bigint\":\n            return value;\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            } catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid BigNumberish string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */ function getUint(value, name) {\n    const result = getBigInt(value, name);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\",\n        operation: \"getUint\",\n        value\n    });\n    return result;\n}\nconst Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */ function toBigInt(value) {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value){\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n    return getBigInt(value);\n}\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */ function getNumber(value, name) {\n    switch(typeof value){\n        case \"bigint\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                return getNumber(BigInt(value), name);\n            } catch (e) {\n                (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid numeric string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, \"invalid numeric value\", name || \"value\", value);\n}\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */ function toNumber(value) {\n    return getNumber(toBigInt(value));\n}\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */ function toBeHex(_value, _width) {\n    const value = getUint(_value, \"value\");\n    let result = value.toString(16);\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) {\n            result = \"0\" + result;\n        }\n    } else {\n        const width = getNumber(_width, \"width\");\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(width * 2 >= result.length, `value exceeds width (${width} bytes)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n        // Pad the value to the required width\n        while(result.length < width * 2){\n            result = \"0\" + result;\n        }\n    }\n    return \"0x\" + result;\n}\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */ function toBeArray(_value) {\n    const value = getUint(_value, \"value\");\n    if (value === BN_0) {\n        return new Uint8Array([]);\n    }\n    let hex = value.toString(16);\n    if (hex.length % 2) {\n        hex = \"0\" + hex;\n    }\n    const result = new Uint8Array(hex.length / 2);\n    for(let i = 0; i < result.length; i++){\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n    return result;\n}\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */ function toQuantity(value) {\n    let result = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_data_js__WEBPACK_IMPORTED_MODULE_1__.isBytesLike)(value) ? value : toBeArray(value)).substring(2);\n    while(result.startsWith(\"0\")){\n        result = result.substring(1);\n    }\n    if (result === \"\") {\n        result = \"0\";\n    }\n    return \"0x\" + result;\n} //# sourceMappingURL=maths.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvbWF0aHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FDZ0Q7QUFDSTtBQUNyRCxNQUFNSSxPQUFPQyxPQUFPO0FBQ3BCLE1BQU1DLE9BQU9ELE9BQU87QUFDcEIsaURBQWlEO0FBQ2pELHVDQUF1QztBQUN2QyxNQUFNRSxXQUFXO0FBQ2pCOzs7OztDQUtDLEdBQ00sU0FBU0MsU0FBU0MsTUFBTSxFQUFFQyxNQUFNO0lBQ25DLE1BQU1DLFFBQVFDLFFBQVFILFFBQVE7SUFDOUIsTUFBTUksUUFBUVIsT0FBT1MsVUFBVUosUUFBUTtJQUN2Q1Isa0RBQU1BLENBQUMsU0FBVVcsVUFBV1QsTUFBTSxZQUFZLGlCQUFpQjtRQUMzRFcsV0FBVztRQUFZQyxPQUFPO1FBQVlMLE9BQU9GO0lBQ3JEO0lBQ0EseUNBQXlDO0lBQ3pDLElBQUlFLFNBQVVFLFFBQVFQLE1BQU87UUFDekIsTUFBTVcsT0FBTyxDQUFDWCxRQUFRTyxLQUFJLElBQUtQO1FBQy9CLE9BQU8sQ0FBRSxFQUFDLENBQUVLLFFBQVNNLElBQUcsSUFBS1gsSUFBRztJQUNwQztJQUNBLE9BQU9LO0FBQ1g7QUFDQTs7Ozs7Q0FLQyxHQUNNLFNBQVNPLE9BQU9ULE1BQU0sRUFBRUMsTUFBTTtJQUNqQyxJQUFJQyxRQUFRUSxVQUFVVixRQUFRO0lBQzlCLE1BQU1JLFFBQVFSLE9BQU9TLFVBQVVKLFFBQVE7SUFDdkMsTUFBTVUsUUFBU2QsUUFBU08sUUFBUVA7SUFDaEMsSUFBSUssUUFBUVAsTUFBTTtRQUNkTyxRQUFRLENBQUNBO1FBQ1RULGtEQUFNQSxDQUFDUyxTQUFTUyxPQUFPLFdBQVcsaUJBQWlCO1lBQy9DTCxXQUFXO1lBQVVDLE9BQU87WUFBWUwsT0FBT0Y7UUFDbkQ7UUFDQSxNQUFNUSxPQUFPLENBQUNYLFFBQVFPLEtBQUksSUFBS1A7UUFDL0IsT0FBTyxDQUFDLENBQUVLLFFBQVNNLElB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SUFBSSxHQUFHQSxJQUFJWCxPQUFPUSxNQUFNLEVBQUVHLElBQUs7UUFDcEMsTUFBTUMsU0FBU0QsSUFBSTtRQUNuQlgsTUFBTSxDQUFDVyxFQUFFLEdBQUdFLFNBQVNILElBQUliLFNBQVMsQ0FBQ2UsUUFBUUEsU0FBUyxJQUFJO0lBQzVEO0lBQ0EsT0FBT1o7QUFDWDtBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNjLFdBQVdqQyxLQUFLO0lBQzVCLElBQUltQixTQUFTOUIsaURBQU9BLENBQUNDLHFEQUFXQSxDQUFDVSxTQUFTQSxRQUFRNEIsVUFBVTVCLFFBQVFnQixTQUFTLENBQUM7SUFDOUUsTUFBT0csT0FBT2UsVUFBVSxDQUFDLEtBQU07UUFDM0JmLFNBQVNBLE9BQU9ILFNBQVMsQ0FBQztJQUM5QjtJQUNBLElBQUlHLFdBQVcsSUFBSTtRQUNmQSxTQUFTO0lBQ2I7SUFDQSxPQUFPLE9BQU9BO0FBQ2xCLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veWlkLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL21hdGhzLmpzP2JjZTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgU29tZSBtYXRoZW1hdGljIG9wZXJhdGlvbnMuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3V0aWxzOk1hdGggSGVscGVycyAgW2Fib3V0LW1hdGhzXVxuICovXG5pbXBvcnQgeyBoZXhsaWZ5LCBpc0J5dGVzTGlrZSB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0QXJndW1lbnQgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuLy9jb25zdCBCTl9NYXgyNTYgPSAoQk5fMSA8PCBCaWdJbnQoMjU2KSkgLSBCTl8xO1xuLy8gSUVFRSA3NTQgc3VwcG9ydCA1My1iaXRzIG9mIG1hbnRpc3NhXG5jb25zdCBtYXhWYWx1ZSA9IDB4MWZmZmZmZmZmZmZmZmY7XG4vKipcbiAqICBDb252ZXJ0ICUldmFsdWUlJSBmcm9tIGEgdHdvcy1jb21wbGltZW50IHJlcHJlc2VudGF0aW9uIG9mICUld2lkdGglJVxuICogIGJpdHMgdG8gaXRzIHZhbHVlLlxuICpcbiAqICBJZiB0aGUgaGlnaGVzdCBiaXQgaXMgYGAxYGAsIHRoZSByZXN1bHQgd2lsbCBiZSBuZWdhdGl2ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Ud29zKF92YWx1ZSwgX3dpZHRoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVaW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBjb25zdCB3aWR0aCA9IEJpZ0ludChnZXROdW1iZXIoX3dpZHRoLCBcIndpZHRoXCIpKTtcbiAgICBhc3NlcnQoKHZhbHVlID4+IHdpZHRoKSA9PT0gQk5fMCwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICBvcGVyYXRpb246IFwiZnJvbVR3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgIH0pO1xuICAgIC8vIFRvcCBiaXQgc2V0OyB0cmVhdCBhcyBhIG5lZ2F0aXZlIHZhbHVlXG4gICAgaWYgKHZhbHVlID4+ICh3aWR0aCAtIEJOXzEpKSB7XG4gICAgICAgIGNvbnN0IG1hc2sgPSAoQk5fMSA8PCB3aWR0aCkgLSBCTl8xO1xuICAgICAgICByZXR1cm4gLSgoKH52YWx1ZSkgJiBtYXNrKSArIEJOXzEpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqICBDb252ZXJ0ICUldmFsdWUlJSB0byBhIHR3b3MtY29tcGxpbWVudCByZXByZXNlbnRhdGlvbiBvZlxuICogICUld2lkdGglJSBiaXRzLlxuICpcbiAqICBUaGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIHBvc2l0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Ud29zKF92YWx1ZSwgX3dpZHRoKSB7XG4gICAgbGV0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBjb25zdCB3aWR0aCA9IEJpZ0ludChnZXROdW1iZXIoX3dpZHRoLCBcIndpZHRoXCIpKTtcbiAgICBjb25zdCBsaW1pdCA9IChCTl8xIDw8ICh3aWR0aCAtIEJOXzEpKTtcbiAgICBpZiAodmFsdWUgPCBCTl8wKSB7XG4gICAgICAgIHZhbHVlID0gLXZhbHVlO1xuICAgICAgICBhc3NlcnQodmFsdWUgPD0gbGltaXQsIFwidG9vIGxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRvVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtYXNrID0gKEJOXzEgPDwgd2lkdGgpIC0gQk5fMTtcbiAgICAgICAgcmV0dXJuICgofnZhbHVlKSAmIG1hc2spICsgQk5fMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydCh2YWx1ZSA8IGxpbWl0LCBcInRvbyBoaWdoXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwidG9Ud29zXCIsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogIE1hc2sgJSV2YWx1ZSUlIHdpdGggYSBiaXRtYXNrIG9mICUlYml0cyUlIG9uZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXNrKF92YWx1ZSwgX2JpdHMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IGJpdHMgPSBCaWdJbnQoZ2V0TnVtYmVyKF9iaXRzLCBcImJpdHNcIikpO1xuICAgIHJldHVybiB2YWx1ZSAmICgoQk5fMSA8PCBiaXRzKSAtIEJOXzEpO1xufVxuLyoqXG4gKiAgR2V0cyBhIEJpZ0ludCBmcm9tICUldmFsdWUlJS4gSWYgaXQgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3JcbiAqICBhIEJpZ0ludCwgdGhlbiBhbiBBcmd1bWVudEVycm9yIHdpbGwgYmUgdGhyb3duIGZvciAlJW5hbWUlJS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJpZ0ludCh2YWx1ZSwgbmFtZSkge1xuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOiByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcInVuZGVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodmFsdWUgPj0gLW1heFZhbHVlICYmIHZhbHVlIDw9IG1heFZhbHVlLCBcIm92ZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbMF0gPT09IFwiLVwiICYmIHZhbHVlWzFdICE9PSBcIi1cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLUJpZ0ludCh2YWx1ZS5zdWJzdHJpbmcoMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIEJpZ051bWJlcmlzaCBzdHJpbmc6ICR7ZS5tZXNzYWdlfWAsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBcImludmFsaWQgQmlnTnVtYmVyaXNoIHZhbHVlXCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG4vKipcbiAqICBSZXR1cm5zICUldmFsdWUlJSBhcyBhIGJpZ2ludCwgdmFsaWRhdGluZyBpdCBpcyB2YWxpZCBhcyBhIGJpZ2ludFxuICogIHZhbHVlIGFuZCB0aGF0IGl0IGlzIHBvc2l0aXZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VWludCh2YWx1ZSwgbmFtZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGdldEJpZ0ludCh2YWx1ZSwgbmFtZSk7XG4gICAgYXNzZXJ0KHJlc3VsdCA+PSBCTl8wLCBcInVuc2lnbmVkIHZhbHVlIGNhbm5vdCBiZSBuZWdhdGl2ZVwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICBmYXVsdDogXCJvdmVyZmxvd1wiLCBvcGVyYXRpb246IFwiZ2V0VWludFwiLCB2YWx1ZVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBOaWJibGVzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4vKlxuICogQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgQmlnSW50LiBJZiAlJXZhbHVlJSUgaXMgYSBVaW50OEFycmF5LCBpdFxuICogaXMgdHJlYXRlZCBhcyBCaWcgRW5kaWFuIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JpZ0ludCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiMHgwXCI7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiA+PiA0XTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBOaWJibGVzW3YgJiAweDBmXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnSW50KHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBnZXRCaWdJbnQodmFsdWUpO1xufVxuLyoqXG4gKiAgR2V0cyBhIC8vbnVtYmVyLy8gZnJvbSAlJXZhbHVlJSUuIElmIGl0IGlzIGFuIGludmFsaWQgdmFsdWUgZm9yXG4gKiAgYSAvL251bWJlci8vLCB0aGVuIGFuIEFyZ3VtZW50RXJyb3Igd2lsbCBiZSB0aHJvd24gZm9yICUlbmFtZSUlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TnVtYmVyKHZhbHVlLCBuYW1lKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgKHZhbHVlKSkge1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudCh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSwgXCJ1bmRlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXROdW1iZXIoQmlnSW50KHZhbHVlKSwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGFzc2VydEFyZ3VtZW50KGZhbHNlLCBgaW52YWxpZCBudW1lcmljIHN0cmluZzogJHtlLm1lc3NhZ2V9YCwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIFwiaW52YWxpZCBudW1lcmljIHZhbHVlXCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG4vKipcbiAqICBDb252ZXJ0cyAlJXZhbHVlJSUgdG8gYSBudW1iZXIuIElmICUldmFsdWUlJSBpcyBhIFVpbnQ4QXJyYXksIGl0XG4gKiAgaXMgdHJlYXRlZCBhcyBCaWcgRW5kaWFuIGRhdGEuIFRocm93cyBpZiB0aGUgdmFsdWUgaXMgbm90IHNhZmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBnZXROdW1iZXIodG9CaWdJbnQodmFsdWUpKTtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIEJpZyBFbmRpYW4gaGV4c3RyaW5nLCBvcHRpb25hbGx5IHBhZGRlZCB0b1xuICogICUld2lkdGglJSBieXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmVIZXgoX3ZhbHVlLCBfd2lkdGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGxldCByZXN1bHQgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgaWYgKF93aWR0aCA9PSBudWxsKSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgdmFsdWUgaXMgb2YgZXZlbiBsZW5ndGhcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBnZXROdW1iZXIoX3dpZHRoLCBcIndpZHRoXCIpO1xuICAgICAgICBhc3NlcnQod2lkdGggKiAyID49IHJlc3VsdC5sZW5ndGgsIGB2YWx1ZSBleGNlZWRzIHdpZHRoICgke3dpZHRofSBieXRlcylgLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRvQmVIZXhcIixcbiAgICAgICAgICAgIGZhdWx0OiBcIm92ZXJmbG93XCIsXG4gICAgICAgICAgICB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBQYWQgdGhlIHZhbHVlIHRvIHRoZSByZXF1aXJlZCB3aWR0aFxuICAgICAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8ICh3aWR0aCAqIDIpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xufVxuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgQmlnIEVuZGlhbiBVaW50OEFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CZUFycmF5KF92YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgaWYgKHZhbHVlID09PSBCTl8wKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXSk7XG4gICAgfVxuICAgIGxldCBoZXggPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgaWYgKGhleC5sZW5ndGggJSAyKSB7XG4gICAgICAgIGhleCA9IFwiMFwiICsgaGV4O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShoZXgubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIDI7XG4gICAgICAgIHJlc3VsdFtpXSA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgKyAyKSwgMTYpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgUmV0dXJucyBhIFtbSGV4U3RyaW5nXV0gZm9yICUldmFsdWUlJSBzYWZlIHRvIHVzZSBhcyBhIC8vUXVhbnRpdHkvLy5cbiAqXG4gKiAgQSAvL1F1YW50aXR5Ly8gZG9lcyBub3QgaGF2ZSBhbmQgbGVhZGluZyAwIHZhbHVlcyB1bmxlc3MgdGhlIHZhbHVlIGlzXG4gKiAgdGhlIGxpdGVyYWwgdmFsdWUgYDB4MGAuIFRoaXMgaXMgbW9zdCBjb21tb25seSB1c2VkIGZvciBKU1NPTi1SUENcbiAqICBudW1lcmljIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUXVhbnRpdHkodmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gaGV4bGlmeShpc0J5dGVzTGlrZSh2YWx1ZSkgPyB2YWx1ZSA6IHRvQmVBcnJheSh2YWx1ZSkpLnN1YnN0cmluZygyKTtcbiAgICB3aGlsZSAocmVzdWx0LnN0YXJ0c1dpdGgoXCIwXCIpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgPT09IFwiXCIpIHtcbiAgICAgICAgcmVzdWx0ID0gXCIwXCI7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRocy5qcy5tYXAiXSwibmFtZXMiOlsiaGV4bGlmeSIsImlzQnl0ZXNMaWtlIiwiYXNzZXJ0IiwiYXNzZXJ0QXJndW1lbnQiLCJCTl8wIiwiQmlnSW50IiwiQk5fMSIsIm1heFZhbHVlIiwiZnJvbVR3b3MiLCJfdmFsdWUiLCJfd2lkdGgiLCJ2YWx1ZSIsImdldFVpbnQiLCJ3aWR0aCIsImdldE51bWJlciIsIm9wZXJhdGlvbiIsImZhdWx0IiwibWFzayIsInRvVHdvcyIsImdldEJpZ0ludCIsImxpbWl0IiwiX2JpdHMiLCJiaXRzIiwibmFtZSIsIk51bWJlciIsImlzSW50ZWdlciIsIkVycm9yIiwic3Vic3RyaW5nIiwiZSIsIm1lc3NhZ2UiLCJyZXN1bHQiLCJOaWJibGVzIiwidG9CaWdJbnQiLCJVaW50OEFycmF5IiwidiIsInRvTnVtYmVyIiwidG9CZUhleCIsInRvU3RyaW5nIiwibGVuZ3RoIiwidG9CZUFycmF5IiwiaGV4IiwiaSIsIm9mZnNldCIsInBhcnNlSW50IiwidG9RdWFudGl0eSIsInN0YXJ0c1dpdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/maths.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/properties.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/properties.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineProperties: () => (/* binding */ defineProperties),\n/* harmony export */   resolveProperties: () => (/* binding */ resolveProperties)\n/* harmony export */ });\n/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */ function checkType(value, type, name) {\n    const types = type.split(\"|\").map((t)=>t.trim());\n    for(let i = 0; i < types.length; i++){\n        switch(type){\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof value === type) {\n                    return;\n                }\n        }\n    }\n    const error = new Error(`invalid value for type ${type}`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${name}`;\n    error.value = value;\n    throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */ async function resolveProperties(value) {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k)=>Promise.resolve(value[k])));\n    return results.reduce((accum, v, index)=>{\n        accum[keys[index]] = v;\n        return accum;\n    }, {});\n}\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */ function defineProperties(target, values, types) {\n    for(let key in values){\n        let value = values[key];\n        const type = types ? types[key] : null;\n        if (type) {\n            checkType(value, type, key);\n        }\n        Object.defineProperty(target, key, {\n            enumerable: true,\n            value,\n            writable: false\n        });\n    }\n} //# sourceMappingURL=properties.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvcHJvcGVydGllcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7O0NBSUMsR0FDRCxTQUFTQSxVQUFVQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsSUFBSTtJQUNoQyxNQUFNQyxRQUFRRixLQUFLRyxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxJQUFJO0lBQzdDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTCxNQUFNTSxNQUFNLEVBQUVELElBQUs7UUFDbkMsT0FBUVA7WUFDSixLQUFLO2dCQUNEO1lBQ0osS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDRCxJQUFJLE9BQVFELFVBQVdDLE1BQU07b0JBQ3pCO2dCQUNKO1FBQ1I7SUFDSjtJQUNBLE1BQU1TLFFBQVEsSUFBSUMsTUFBTSxDQUFDLHVCQUF1QixFQUFFVixLQUFLLENBQUM7SUFDeERTLE1BQU1FLElBQUksR0FBRztJQUNiRixNQUFNRyxRQUFRLEdBQUcsQ0FBQyxNQUFNLEVBQUVYLEtBQUssQ0FBQztJQUNoQ1EsTUFBTVYsS0FBSyxHQUFHQTtJQUNkLE1BQU1VO0FBQ1Y7QUFDQTs7O0NBR0MsR0FDTSxlQUFlSSxrQkFBa0JkLEtBQUs7SUFDekMsTUFBTWUsT0FBT0MsT0FBT0QsSUFBSSxDQUFDZjtJQUN6QixNQUFNaUIsVUFBVSxNQUFNQyxRQUFRQyxHQUFHLENBQUNKLEtBQUtWLEdBQUcsQ0FBQyxDQUFDZSxJQUFNRixRQUFRRyxPQUFPLENBQUNyQixLQUFLLENBQUNvQixFQUFFO0lBQzFFLE9BQU9ILFFBQVFLLE1BQU0sQ0FBQyxDQUFDQyxPQUFPQyxHQUFHQztRQUM3QkYsS0FBSyxDQUFDUixJQUFJLENBQUNVLE1BQU0sQ0FBQyxHQUFHRDtRQUNyQixPQUFPRDtJQUNYLEdBQUcsQ0FBQztBQUNSO0FBQ0E7Ozs7Q0FJQyxHQUNNLFNBQVNHLGlCQUFpQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUV6QixLQUFLO0lBQ2xELElBQUssSUFBSTBCLE9BQU9ELE9BQVE7UUFDcEIsSUFBSTVCLFFBQVE0QixNQUFNLENBQUNDLElBQUk7UUFDdkIsTUFBTTVCLE9BQVFFLFFBQVFBLEtBQUssQ0FBQzBCLElBQUksR0FBRztRQUNuQyxJQUFJNUIsTUFBTTtZQUNORixVQUFVQyxPQUFPQyxNQUFNNEI7UUFDM0I7UUFDQWIsT0FBT2MsY0FBYyxDQUFDSCxRQUFRRSxLQUFLO1lBQUVFLFlBQVk7WUFBTS9CO1lBQU9nQyxVQUFVO1FBQU07SUFDbEY7QUFDSixFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL3lpZC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9wcm9wZXJ0aWVzLmpzPzUyMDciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgUHJvcGVydHkgaGVscGVyIGZ1bmN0aW9ucy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpQcm9wZXJ0aWVzICBbYWJvdXQtcHJvcGVydGllc11cbiAqL1xuZnVuY3Rpb24gY2hlY2tUeXBlKHZhbHVlLCB0eXBlLCBuYW1lKSB7XG4gICAgY29uc3QgdHlwZXMgPSB0eXBlLnNwbGl0KFwifFwiKS5tYXAodCA9PiB0LnRyaW0oKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhbnlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBpbnZhbGlkIHZhbHVlIGZvciB0eXBlICR7dHlwZX1gKTtcbiAgICBlcnJvci5jb2RlID0gXCJJTlZBTElEX0FSR1VNRU5UXCI7XG4gICAgZXJyb3IuYXJndW1lbnQgPSBgdmFsdWUuJHtuYW1lfWA7XG4gICAgZXJyb3IudmFsdWUgPSB2YWx1ZTtcbiAgICB0aHJvdyBlcnJvcjtcbn1cbi8qKlxuICogIFJlc29sdmVzIHRvIGEgbmV3IG9iamVjdCB0aGF0IGlzIGEgY29weSBvZiAlJXZhbHVlJSUsIGJ1dCB3aXRoIGFsbFxuICogIHZhbHVlcyByZXNvbHZlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVQcm9wZXJ0aWVzKHZhbHVlKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoa2V5cy5tYXAoKGspID0+IFByb21pc2UucmVzb2x2ZSh2YWx1ZVtrXSkpKTtcbiAgICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoKGFjY3VtLCB2LCBpbmRleCkgPT4ge1xuICAgICAgICBhY2N1bVtrZXlzW2luZGV4XV0gPSB2O1xuICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgfSwge30pO1xufVxuLyoqXG4gKiAgQXNzaWducyB0aGUgJSV2YWx1ZXMlJSB0byAlJXRhcmdldCUlIGFzIHJlYWQtb25seSB2YWx1ZXMuXG4gKlxuICogIEl0ICUldHlwZXMlJSBpcyBzcGVjaWZpZWQsIHRoZSB2YWx1ZXMgYXJlIGNoZWNrZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgdmFsdWVzLCB0eXBlcykge1xuICAgIGZvciAobGV0IGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgICAgIGNvbnN0IHR5cGUgPSAodHlwZXMgPyB0eXBlc1trZXldIDogbnVsbCk7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICBjaGVja1R5cGUodmFsdWUsIHR5cGUsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlLCB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydGllcy5qcy5tYXAiXSwibmFtZXMiOlsiY2hlY2tUeXBlIiwidmFsdWUiLCJ0eXBlIiwibmFtZSIsInR5cGVzIiwic3BsaXQiLCJtYXAiLCJ0IiwidHJpbSIsImkiLCJsZW5ndGgiLCJlcnJvciIsIkVycm9yIiwiY29kZSIsImFyZ3VtZW50IiwicmVzb2x2ZVByb3BlcnRpZXMiLCJrZXlzIiwiT2JqZWN0IiwicmVzdWx0cyIsIlByb21pc2UiLCJhbGwiLCJrIiwicmVzb2x2ZSIsInJlZHVjZSIsImFjY3VtIiwidiIsImluZGV4IiwiZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInZhbHVlcyIsImtleSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/properties.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js":
/*!***************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/utf8.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utf8ErrorFuncs: () => (/* binding */ Utf8ErrorFuncs),\n/* harmony export */   toUtf8Bytes: () => (/* binding */ toUtf8Bytes),\n/* harmony export */   toUtf8CodePoints: () => (/* binding */ toUtf8CodePoints),\n/* harmony export */   toUtf8String: () => (/* binding */ toUtf8String)\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/**\n *  Using strings in Ethereum (or any security-basd system) requires\n *  additional care. These utilities attempt to mitigate some of the\n *  safety issues as well as provide the ability to recover and analyse\n *  strings.\n *\n *  @_subsection api/utils:Strings and UTF-8  [about-strings]\n */ \n\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(false, `invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === \"BAD_PREFIX\" || reason === \"UNEXPECTED_CONTINUE\") {\n        let i = 0;\n        for(let o = offset + 1; o < bytes.length; o++){\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === \"OVERRUN\") {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === \"OVERLONG\") {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof badCodepoint === \"number\", \"invalid bad code point for replacement\", \"badCodepoint\", badCodepoint);\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n/**\n *  A handful of popular, built-in UTF-8 error handling strategies.\n *\n *  **``\"error\"``** - throws on ANY illegal UTF-8 sequence or\n *  non-canonical (overlong) codepoints (this is the default)\n *\n *  **``\"ignore\"``** - silently drops any illegal UTF-8 sequence\n *  and accepts non-canonical (overlong) codepoints\n *\n *  **``\"replace\"``** - replace any illegal UTF-8 sequence with the\n *  UTF-8 replacement character (i.e. ``\"\\\\ufffd\"``) and accepts\n *  non-canonical (overlong) codepoints\n *\n *  @returns: Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>\n */ const Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(_bytes, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    const bytes = (0,_data_js__WEBPACK_IMPORTED_MODULE_1__.getBytes)(_bytes, \"bytes\");\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while(i < bytes.length){\n        const c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(\"UNEXPECTED_CONTINUE\", i - 1, bytes, result);\n            } else {\n                i += onError(\"BAD_PREFIX\", i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(\"OVERRUN\", i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & (1 << 8 - extraLength - 1) - 1;\n        for(let j = 0; j < extraLength; j++){\n            let nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(\"MISSING_CONTINUE\", i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = res << 6 | nextChar & 0x3f;\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(\"OUT_OF_RANGE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(\"UTF16_SURROGATE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(\"OVERLONG\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n/**\n *  Returns the UTF-8 byte representation of %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */ function toUtf8Bytes(str, form) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof str === \"string\", \"invalid string value\", \"str\", str);\n    if (form != null) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertNormalize)(form);\n        str = str.normalize(form);\n    }\n    let result = [];\n    for(let i = 0; i < str.length; i++){\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        } else if (c < 0x800) {\n            result.push(c >> 6 | 0xc0);\n            result.push(c & 0x3f | 0x80);\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(i < str.length && (c2 & 0xfc00) === 0xdc00, \"invalid surrogate pair\", \"str\", str);\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push(pair >> 18 | 0xf0);\n            result.push(pair >> 12 & 0x3f | 0x80);\n            result.push(pair >> 6 & 0x3f | 0x80);\n            result.push(pair & 0x3f | 0x80);\n        } else {\n            result.push(c >> 12 | 0xe0);\n            result.push(c >> 6 & 0x3f | 0x80);\n            result.push(c & 0x3f | 0x80);\n        }\n    }\n    return new Uint8Array(result);\n}\n;\n//export \nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint)=>{\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\");\n}\n/**\n *  Returns the string represented by the UTF-8 data %%bytes%%.\n *\n *  When %%onError%% function is specified, it is called on UTF-8\n *  errors allowing recovery using the [[Utf8ErrorFunc]] API.\n *  (default: [error](Utf8ErrorFuncs))\n */ function toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n/**\n *  Returns the UTF-8 code-points for %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */ function toUtf8CodePoints(str, form) {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n} //# sourceMappingURL=utf8.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvdXRmOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7Ozs7OztDQU9DLEdBQ29DO0FBQ3lCO0FBQzlELFNBQVNHLFVBQVVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsWUFBWTtJQUMxRFAsMERBQWNBLENBQUMsT0FBTyxDQUFDLDRCQUE0QixFQUFFSSxPQUFPLEVBQUUsRUFBRUQsT0FBTyxDQUFDLEVBQUUsU0FBU0U7QUFDdkY7QUFDQSxTQUFTRyxXQUFXTCxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLFlBQVk7SUFDM0QsdUdBQXVHO0lBQ3ZHLElBQUlKLFdBQVcsZ0JBQWdCQSxXQUFXLHVCQUF1QjtRQUM3RCxJQUFJTSxJQUFJO1FBQ1IsSUFBSyxJQUFJQyxJQUFJTixTQUFTLEdBQUdNLElBQUlMLE1BQU1NLE1BQU0sRUFBRUQsSUFBSztZQUM1QyxJQUFJTCxLQUFLLENBQUNLLEVBQUUsSUFBSSxNQUFNLE1BQU07Z0JBQ3hCO1lBQ0o7WUFDQUQ7UUFDSjtRQUNBLE9BQU9BO0lBQ1g7SUFDQSx3RUFBd0U7SUFDeEUsbUVBQW1FO0lBQ25FLElBQUlOLFdBQVcsV0FBVztRQUN0QixPQUFPRSxNQUFNTSxNQUFNLEdBQUdQLFNBQVM7SUFDbkM7SUFDQSxrQkFBa0I7SUFDbEIsT0FBTztBQUNYO0FBQ0EsU0FBU1EsWUFBWVQsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxZQUFZO0lBQzVELHNGQUFzRjtJQUN0RixJQUFJSixXQUFXLFlBQVk7UUFDdkJILDBEQUFjQSxDQUFDLE9BQVFPLGlCQUFrQixVQUFVLDBDQUEwQyxnQkFBZ0JBO1FBQzdHRCxPQUFPTyxJQUFJLENBQUNOO1FBQ1osT0FBTztJQUNYO0lBQ0EsZ0RBQWdEO0lBQ2hERCxPQUFPTyxJQUFJLENBQUM7SUFDWiwyQ0FB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Q0o7SUFDQSxPQUFPLElBQUl3QixXQUFXZDtBQUMxQjs7QUFFQSxTQUFTO0FBQ1QsU0FBU2UsY0FBY0MsVUFBVTtJQUM3QixPQUFPQSxXQUFXQyxHQUFHLENBQUMsQ0FBQ0M7UUFDbkIsSUFBSUEsYUFBYSxRQUFRO1lBQ3JCLE9BQU9DLE9BQU9DLFlBQVksQ0FBQ0Y7UUFDL0I7UUFDQUEsYUFBYTtRQUNiLE9BQU9DLE9BQU9DLFlBQVksQ0FBRSxDQUFDLGFBQWMsS0FBTSxLQUFJLElBQUssUUFBVSxDQUFDRixZQUFZLEtBQUksSUFBSztJQUM5RixHQUFHRyxJQUFJLENBQUM7QUFDWjtBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNDLGFBQWF4QyxLQUFLLEVBQUVpQixPQUFPO0lBQ3ZDLE9BQU9nQixjQUFjbEIsa0JBQWtCZixPQUFPaUI7QUFDbEQ7QUFDQTs7OztDQUlDLEdBQ00sU0FBU3dCLGlCQUFpQmYsR0FBRyxFQUFFQyxJQUFJO0lBQ3RDLE9BQU9aLGtCQUFrQlUsWUFBWUMsS0FBS0M7QUFDOUMsRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95aWQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvdXRmOC5qcz8zMmJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFVzaW5nIHN0cmluZ3MgaW4gRXRoZXJldW0gKG9yIGFueSBzZWN1cml0eS1iYXNkIHN5c3RlbSkgcmVxdWlyZXNcbiAqICBhZGRpdGlvbmFsIGNhcmUuIFRoZXNlIHV0aWxpdGllcyBhdHRlbXB0IHRvIG1pdGlnYXRlIHNvbWUgb2YgdGhlXG4gKiAgc2FmZXR5IGlzc3VlcyBhcyB3ZWxsIGFzIHByb3ZpZGUgdGhlIGFiaWxpdHkgdG8gcmVjb3ZlciBhbmQgYW5hbHlzZVxuICogIHN0cmluZ3MuXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6U3RyaW5ncyBhbmQgVVRGLTggIFthYm91dC1zdHJpbmdzXVxuICovXG5pbXBvcnQgeyBnZXRCeXRlcyB9IGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50LCBhc3NlcnROb3JtYWxpemUgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmZ1bmN0aW9uIGVycm9yRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgYXNzZXJ0QXJndW1lbnQoZmFsc2UsIGBpbnZhbGlkIGNvZGVwb2ludCBhdCBvZmZzZXQgJHtvZmZzZXR9OyAke3JlYXNvbn1gLCBcImJ5dGVzXCIsIGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIGludmFsaWQgcHJlZml4IChpbmNsdWRpbmcgc3RyYXkgY29udGludWF0aW9uKSwgc2tpcCBhbnkgYWRkaXRpb25hbCBjb250aW51YXRpb24gYnl0ZXNcbiAgICBpZiAocmVhc29uID09PSBcIkJBRF9QUkVGSVhcIiB8fCByZWFzb24gPT09IFwiVU5FWFBFQ1RFRF9DT05USU5VRVwiKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgbyA9IG9mZnNldCArIDE7IG8gPCBieXRlcy5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgaWYgKGJ5dGVzW29dID4+IDYgIT09IDB4MDIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgLy8gVGhpcyBieXRlIHJ1bnMgdXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHNvIGp1c3QganVtcCB0byB0aGUgZW5kXG4gICAgLy8gKGJ1dCB0aGUgZmlyc3QgYnl0ZSB3YXMgcmVhZCBhbHJlYWR5IHJlYWQgYW5kIHRoZXJlZm9yZSBza2lwcGVkKVxuICAgIGlmIChyZWFzb24gPT09IFwiT1ZFUlJVTlwiKSB7XG4gICAgICAgIHJldHVybiBieXRlcy5sZW5ndGggLSBvZmZzZXQgLSAxO1xuICAgIH1cbiAgICAvLyBOb3RoaW5nIHRvIHNraXBcbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICAvLyBPdmVybG9uZyByZXByZXNlbnRhdGlvbnMgYXJlIG90aGVyd2lzZSBcInZhbGlkXCIgY29kZSBwb2ludHM7IGp1c3Qgbm9uLWRlaXN0aW5ndGlzaGVkXG4gICAgaWYgKHJlYXNvbiA9PT0gXCJPVkVSTE9OR1wiKSB7XG4gICAgICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoYmFkQ29kZXBvaW50KSA9PT0gXCJudW1iZXJcIiwgXCJpbnZhbGlkIGJhZCBjb2RlIHBvaW50IGZvciByZXBsYWNlbWVudFwiLCBcImJhZENvZGVwb2ludFwiLCBiYWRDb2RlcG9pbnQpO1xuICAgICAgICBvdXRwdXQucHVzaChiYWRDb2RlcG9pbnQpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8gUHV0IHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaW50byB0aGUgb3V0cHV0XG4gICAgb3V0cHV0LnB1c2goMHhmZmZkKTtcbiAgICAvLyBPdGhlcndpc2UsIHByb2Nlc3MgYXMgaWYgaWdub3JpbmcgZXJyb3JzXG4gICAgcmV0dXJuIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCk7XG59XG4vKipcbiAqICBBIGhhbmRmdWwgb2YgcG9wdWxhciwgYnVpbHQtaW4gVVRGLTggZXJyb3IgaGFuZGxpbmcgc3RyYXRlZ2llcy5cbiAqXG4gKiAgKipgYFwiZXJyb3JcImBgKiogLSB0aHJvd3Mgb24gQU5ZIGlsbGVnYWwgVVRGLTggc2VxdWVuY2Ugb3JcbiAqICBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50cyAodGhpcyBpcyB0aGUgZGVmYXVsdClcbiAqXG4gKiAgKipgYFwiaWdub3JlXCJgYCoqIC0gc2lsZW50bHkgZHJvcHMgYW55IGlsbGVnYWwgVVRGLTggc2VxdWVuY2VcbiAqICBhbmQgYWNjZXB0cyBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50c1xuICpcbiAqICAqKmBgXCJyZXBsYWNlXCJgYCoqIC0gcmVwbGFjZSBhbnkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZSB3aXRoIHRoZVxuICogIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoaS5lLiBgYFwiXFxcXHVmZmZkXCJgYCkgYW5kIGFjY2VwdHNcbiAqICBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50c1xuICpcbiAqICBAcmV0dXJuczogUmVjb3JkPFwiZXJyb3JcIiB8IFwiaWdub3JlXCIgfCBcInJlcGxhY2VcIiwgVXRmOEVycm9yRnVuYz5cbiAqL1xuZXhwb3J0IGNvbnN0IFV0ZjhFcnJvckZ1bmNzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZXJyb3I6IGVycm9yRnVuYyxcbiAgICBpZ25vcmU6IGlnbm9yZUZ1bmMsXG4gICAgcmVwbGFjZTogcmVwbGFjZUZ1bmNcbn0pO1xuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM1NjQ5My9kZWNvZGUtdXRmLTgtd2l0aC1qYXZhc2NyaXB0IzEzNjkxNDk5XG5mdW5jdGlvbiBnZXRVdGY4Q29kZVBvaW50cyhfYnl0ZXMsIG9uRXJyb3IpIHtcbiAgICBpZiAob25FcnJvciA9PSBudWxsKSB7XG4gICAgICAgIG9uRXJyb3IgPSBVdGY4RXJyb3JGdW5jcy5lcnJvcjtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhfYnl0ZXMsIFwiYnl0ZXNcIik7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIC8vIEludmFsaWQgYnl0ZXMgYXJlIGlnbm9yZWRcbiAgICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgLy8gMHh4eCB4eHh4XG4gICAgICAgIGlmIChjID4+IDcgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlieXRlOyBob3cgbWFueSBieXRlcyBsZWZ0IGZvciB0aGlzIGNoYXJhY3Rlcj9cbiAgICAgICAgbGV0IGV4dHJhTGVuZ3RoID0gbnVsbDtcbiAgICAgICAgbGV0IG92ZXJsb25nTWFzayA9IG51bGw7XG4gICAgICAgIC8vIDExMHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgaWYgKChjICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMTtcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2Y7XG4gICAgICAgICAgICAvLyAxMTEwIHh4eHggMTB4eCB4eHh4IDEweHggeHh4eFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMjtcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2ZmO1xuICAgICAgICAgICAgLy8gMTExMSAweHh4IDEweHggeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAzO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHhmZmZmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKChjICYgMHhjMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCIsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIkJBRF9QUkVGSVhcIiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gd2UgaGF2ZSBlbm91Z2ggYnl0ZXMgaW4gb3VyIGRhdGE/XG4gICAgICAgIGlmIChpIC0gMSArIGV4dHJhTGVuZ3RoID49IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiT1ZFUlJVTlwiLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxlbmd0aCBwcmVmaXggZnJvbSB0aGUgY2hhclxuICAgICAgICBsZXQgcmVzID0gYyAmICgoMSA8PCAoOCAtIGV4dHJhTGVuZ3RoIC0gMSkpIC0gMSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZXh0cmFMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IG5leHRDaGFyID0gYnl0ZXNbaV07XG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgICAgICBpZiAoKG5leHRDaGFyICYgMHhjMCkgIT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk1JU1NJTkdfQ09OVElOVUVcIiwgaSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHJlcyA9IChyZXMgPDwgNikgfCAobmV4dENoYXIgJiAweDNmKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWUgYWJvdmUgbG9vcCBmb3IgaW52YWxpZCBjb250aW51YXRpb24gYnl0ZVxuICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXhpbXVtIGNvZGUgcG9pbnRcbiAgICAgICAgaWYgKHJlcyA+IDB4MTBmZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVVRfT0ZfUkFOR0VcIiwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2VydmVkIGZvciBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICBpZiAocmVzID49IDB4ZDgwMCAmJiByZXMgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJVVEYxNl9TVVJST0dBVEVcIiwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBvdmVybG9uZyBzZXF1ZW5jZXMgKG1vcmUgYnl0ZXMgdGhhbiBuZWVkZWQpXG4gICAgICAgIGlmIChyZXMgPD0gb3ZlcmxvbmdNYXNrKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVkVSTE9OR1wiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTg3Mjk0MDUvaG93LXRvLWNvbnZlcnQtdXRmOC1zdHJpbmctdG8tYnl0ZS1hcnJheVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgVVRGLTggYnl0ZSByZXByZXNlbnRhdGlvbiBvZiAlJXN0ciUlLlxuICpcbiAqICBJZiAlJWZvcm0lJSBpcyBzcGVjaWZpZWQsIHRoZSBzdHJpbmcgaXMgbm9ybWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkge1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAoc3RyKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIHN0cmluZyB2YWx1ZVwiLCBcInN0clwiLCBzdHIpO1xuICAgIGlmIChmb3JtICE9IG51bGwpIHtcbiAgICAgICAgYXNzZXJ0Tm9ybWFsaXplKGZvcm0pO1xuICAgICAgICBzdHIgPSBzdHIubm9ybWFsaXplKGZvcm0pO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgPj4gNikgfCAweGMwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT0gMHhkODAwKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb25zdCBjMiA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQoaSA8IHN0ci5sZW5ndGggJiYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCksIFwiaW52YWxpZCBzdXJyb2dhdGUgcGFpclwiLCBcInN0clwiLCBzdHIpO1xuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoYzIgJiAweDAzZmYpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgPj4gMTgpIHwgMHhmMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gMTIpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiAxMikgfCAweGUwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgoYyA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG47XG4vL2V4cG9ydCBcbmZ1bmN0aW9uIF90b1V0ZjhTdHJpbmcoY29kZVBvaW50cykge1xuICAgIHJldHVybiBjb2RlUG9pbnRzLm1hcCgoY29kZVBvaW50KSA9PiB7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoKChjb2RlUG9pbnQgPj4gMTApICYgMHgzZmYpICsgMHhkODAwKSwgKChjb2RlUG9pbnQgJiAweDNmZikgKyAweGRjMDApKTtcbiAgICB9KS5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGVkIGJ5IHRoZSBVVEYtOCBkYXRhICUlYnl0ZXMlJS5cbiAqXG4gKiAgV2hlbiAlJW9uRXJyb3IlJSBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IGlzIGNhbGxlZCBvbiBVVEYtOFxuICogIGVycm9ycyBhbGxvd2luZyByZWNvdmVyeSB1c2luZyB0aGUgW1tVdGY4RXJyb3JGdW5jXV0gQVBJLlxuICogIChkZWZhdWx0OiBbZXJyb3JdKFV0ZjhFcnJvckZ1bmNzKSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOFN0cmluZyhieXRlcywgb25FcnJvcikge1xuICAgIHJldHVybiBfdG9VdGY4U3RyaW5nKGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLCBvbkVycm9yKSk7XG59XG4vKipcbiAqICBSZXR1cm5zIHRoZSBVVEYtOCBjb2RlLXBvaW50cyBmb3IgJSVzdHIlJS5cbiAqXG4gKiAgSWYgJSVmb3JtJSUgaXMgc3BlY2lmaWVkLCB0aGUgc3RyaW5nIGlzIG5vcm1hbGl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjhDb2RlUG9pbnRzKHN0ciwgZm9ybSkge1xuICAgIHJldHVybiBnZXRVdGY4Q29kZVBvaW50cyh0b1V0ZjhCeXRlcyhzdHIsIGZvcm0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0ZjguanMubWFwIl0sIm5hbWVzIjpbImdldEJ5dGVzIiwiYXNzZXJ0QXJndW1lbnQiLCJhc3NlcnROb3JtYWxpemUiLCJlcnJvckZ1bmMiLCJyZWFzb24iLCJvZmZzZXQiLCJieXRlcyIsIm91dHB1dCIsImJhZENvZGVwb2ludCIsImlnbm9yZUZ1bmMiLCJpIiwibyIsImxlbmd0aCIsInJlcGxhY2VGdW5jIiwicHVzaCIsIlV0ZjhFcnJvckZ1bmNzIiwiT2JqZWN0IiwiZnJlZXplIiwiZXJyb3IiLCJpZ25vcmUiLCJyZXBsYWNlIiwiZ2V0VXRmOENvZGVQb2ludHMiLCJfYnl0ZXMiLCJvbkVycm9yIiwicmVzdWx0IiwiYyIsImV4dHJhTGVuZ3RoIiwib3ZlcmxvbmdNYXNrIiwicmVzIiwiaiIsIm5leHRDaGFyIiwidG9VdGY4Qnl0ZXMiLCJzdHIiLCJmb3JtIiwibm9ybWFsaXplIiwiY2hhckNvZGVBdCIsImMyIiwicGFpciIsIlVpbnQ4QXJyYXkiLCJfdG9VdGY4U3RyaW5nIiwiY29kZVBvaW50cyIsIm1hcCIsImNvZGVQb2ludCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImpvaW4iLCJ0b1V0ZjhTdHJpbmciLCJ0b1V0ZjhDb2RlUG9pbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethers/lib.esm/utils/utf8.js\n");

/***/ })

};
;